// @generated by Thrift for src/interface/storage.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `storage`.

#![allow(clippy::redundant_closure)]


#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RequestCommon {
    pub session_id: ::std::option::Option<common::types::SessionID>,
    pub plan_id: ::std::option::Option<common::types::ExecutionPlanID>,
    pub profile_detail: ::std::option::Option<::std::primitive::bool>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PartitionResult {
    pub code: common::types::ErrorCode,
    pub part_id: common::types::PartitionID,
    pub leader: ::std::option::Option<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ResponseCommon {
    pub failed_parts: ::std::vec::Vec<crate::types::PartitionResult>,
    pub latency_in_us: ::std::primitive::i64,
    pub latency_detail_us: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StatProp {
    pub alias: ::std::vec::Vec<::std::primitive::u8>,
    pub prop: ::std::vec::Vec<::std::primitive::u8>,
    pub stat: crate::types::StatType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Expr {
    pub alias: ::std::vec::Vec<::std::primitive::u8>,
    pub expr: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EdgeProp {
    pub r#type: common::types::EdgeType,
    pub props: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VertexProp {
    pub tag: common::types::TagID,
    pub props: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct OrderBy {
    pub prop: ::std::vec::Vec<::std::primitive::u8>,
    pub direction: crate::types::OrderDirection,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TraverseSpec {
    pub edge_types: ::std::vec::Vec<common::types::EdgeType>,
    pub edge_direction: crate::types::EdgeDirection,
    pub dedup: ::std::primitive::bool,
    pub stat_props: ::std::option::Option<::std::vec::Vec<crate::types::StatProp>>,
    pub vertex_props: ::std::option::Option<::std::vec::Vec<crate::types::VertexProp>>,
    pub edge_props: ::std::option::Option<::std::vec::Vec<crate::types::EdgeProp>>,
    pub expressions: ::std::option::Option<::std::vec::Vec<crate::types::Expr>>,
    pub order_by: ::std::option::Option<::std::vec::Vec<crate::types::OrderBy>>,
    pub random: ::std::option::Option<::std::primitive::bool>,
    pub limit: ::std::option::Option<::std::primitive::i64>,
    pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub tag_filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetNeighborsRequest {
    pub space_id: common::types::GraphSpaceID,
    pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Value>>,
    pub traverse_spec: crate::types::TraverseSpec,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetNeighborsResponse {
    pub result: crate::types::ResponseCommon,
    pub vertices: ::std::option::Option<common::types::DataSet>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetDstBySrcRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Value>>,
    pub edge_types: ::std::vec::Vec<common::types::EdgeType>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetDstBySrcResponse {
    pub result: crate::types::ResponseCommon,
    pub dsts: ::std::option::Option<common::types::DataSet>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecResponse {
    pub result: crate::types::ResponseCommon,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetPropRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Row>>,
    pub vertex_props: ::std::option::Option<::std::vec::Vec<crate::types::VertexProp>>,
    pub edge_props: ::std::option::Option<::std::vec::Vec<crate::types::EdgeProp>>,
    pub expressions: ::std::option::Option<::std::vec::Vec<crate::types::Expr>>,
    pub dedup: ::std::primitive::bool,
    pub order_by: ::std::option::Option<::std::vec::Vec<crate::types::OrderBy>>,
    pub limit: ::std::option::Option<::std::primitive::i64>,
    pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetPropResponse {
    pub result: crate::types::ResponseCommon,
    pub props: ::std::option::Option<common::types::DataSet>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct NewTag {
    pub tag_id: common::types::TagID,
    pub props: ::std::vec::Vec<common::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct NewVertex {
    pub id: common::types::Value,
    pub tags: ::std::vec::Vec<crate::types::NewTag>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgeKey {
    pub src: common::types::Value,
    pub edge_type: common::types::EdgeType,
    pub ranking: common::types::EdgeRanking,
    pub dst: common::types::Value,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct NewEdge {
    pub key: crate::types::EdgeKey,
    pub props: ::std::vec::Vec<common::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddVerticesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::NewVertex>>,
    pub prop_names: ::std::collections::BTreeMap<common::types::TagID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub if_not_exists: ::std::primitive::bool,
    pub ignore_existed_index: ::std::primitive::bool,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::NewEdge>>,
    pub prop_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub if_not_exists: ::std::primitive::bool,
    pub ignore_existed_index: ::std::primitive::bool,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DeleteVerticesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Value>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DeleteEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DelTags {
    pub id: common::types::Value,
    pub tags: ::std::vec::Vec<common::types::TagID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DeleteTagsRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::DelTags>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateResponse {
    pub result: crate::types::ResponseCommon,
    pub props: ::std::option::Option<common::types::DataSet>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UpdatedProp {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateVertexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub vertex_id: common::types::Value,
    pub tag_id: common::types::TagID,
    pub updated_props: ::std::vec::Vec<crate::types::UpdatedProp>,
    pub insertable: ::std::option::Option<::std::primitive::bool>,
    pub return_props: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub condition: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateEdgeRequest {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub edge_key: crate::types::EdgeKey,
    pub updated_props: ::std::vec::Vec<crate::types::UpdatedProp>,
    pub insertable: ::std::option::Option<::std::primitive::bool>,
    pub return_props: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub condition: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetUUIDReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetUUIDResp {
    pub result: crate::types::ResponseCommon,
    pub id: common::types::Value,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LookupIndexResp {
    pub result: crate::types::ResponseCommon,
    pub data: ::std::option::Option<common::types::DataSet>,
    pub stat_data: ::std::option::Option<common::types::DataSet>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IndexColumnHint {
    pub column_name: ::std::vec::Vec<::std::primitive::u8>,
    pub scan_type: crate::types::ScanType,
    pub begin_value: common::types::Value,
    pub end_value: common::types::Value,
    pub include_begin: ::std::primitive::bool,
    pub include_end: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IndexQueryContext {
    pub index_id: common::types::IndexID,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub column_hints: ::std::vec::Vec<crate::types::IndexColumnHint>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IndexSpec {
    pub contexts: ::std::vec::Vec<crate::types::IndexQueryContext>,
    pub schema_id: common::types::SchemaID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LookupIndexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    pub indices: crate::types::IndexSpec,
    pub return_columns: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    pub limit: ::std::option::Option<::std::primitive::i64>,
    pub order_by: ::std::option::Option<::std::vec::Vec<crate::types::OrderBy>>,
    pub stat_columns: ::std::option::Option<::std::vec::Vec<crate::types::StatProp>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LookupAndTraverseRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    pub indices: crate::types::IndexSpec,
    pub traverse_spec: crate::types::TraverseSpec,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScanCursor {
    pub next_cursor: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanVertexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, crate::types::ScanCursor>,
    pub return_columns: ::std::vec::Vec<crate::types::VertexProp>,
    pub limit: ::std::primitive::i64,
    pub start_time: ::std::option::Option<::std::primitive::i64>,
    pub end_time: ::std::option::Option<::std::primitive::i64>,
    pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub only_latest_version: ::std::primitive::bool,
    pub enable_read_from_follower: ::std::primitive::bool,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanEdgeRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, crate::types::ScanCursor>,
    pub return_columns: ::std::vec::Vec<crate::types::EdgeProp>,
    pub limit: ::std::primitive::i64,
    pub start_time: ::std::option::Option<::std::primitive::i64>,
    pub end_time: ::std::option::Option<::std::primitive::i64>,
    pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub only_latest_version: ::std::primitive::bool,
    pub enable_read_from_follower: ::std::primitive::bool,
    pub common: ::std::option::Option<crate::types::RequestCommon>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanResponse {
    pub result: crate::types::ResponseCommon,
    pub props: ::std::option::Option<common::types::DataSet>,
    pub cursors: ::std::collections::BTreeMap<common::types::PartitionID, crate::types::ScanCursor>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TaskPara {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::option::Option<::std::vec::Vec<common::types::PartitionID>>,
    pub task_specific_paras: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KVGetRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub return_partly: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KVGetResponse {
    pub result: crate::types::ResponseCommon,
    pub key_values: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KVPutRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::KeyValue>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KVRemoveRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminExecResp {
    pub result: crate::types::ResponseCommon,
    pub stats: ::std::option::Option<meta::types::StatsItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TransLeaderReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub new_leader: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddPartReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub as_learner: ::std::primitive::bool,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddLearnerReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub learner: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemovePartReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MemberChangeReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub peer: common::types::HostAddr,
    pub add: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CatchUpDataReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub target: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetLeaderReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateCPRequest {
    pub space_ids: ::std::vec::Vec<common::types::GraphSpaceID>,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateCPResp {
    pub code: common::types::ErrorCode,
    pub info: ::std::vec::Vec<common::types::CheckpointInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropCPRequest {
    pub space_ids: ::std::vec::Vec<common::types::GraphSpaceID>,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropCPResp {
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BlockingSignRequest {
    pub space_ids: ::std::vec::Vec<common::types::GraphSpaceID>,
    pub sign: crate::types::EngineSignType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BlockingSignResp {
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetLeaderPartsResp {
    pub code: common::types::ErrorCode,
    pub leader_parts: ::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CheckPeersReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RebuildIndexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    pub index_id: common::types::IndexID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListClusterInfoResp {
    pub result: crate::types::ResponseCommon,
    pub dir: common::types::DirInfo,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListClusterInfoReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddTaskRequest {
    pub job_type: meta::types::JobType,
    pub job_id: ::std::primitive::i32,
    pub task_id: ::std::primitive::i32,
    pub para: crate::types::TaskPara,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AddTaskResp {
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StopTaskRequest {
    pub job_id: ::std::primitive::i32,
    pub task_id: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StopTaskResp {
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ClearSpaceReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ClearSpaceResp {
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ChainAddEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::NewEdge>>,
    pub prop_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub if_not_exists: ::std::primitive::bool,
    pub term: ::std::primitive::i64,
    pub edge_version: ::std::option::Option<::std::primitive::i64>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ChainUpdateEdgeRequest {
    pub update_edge_request: crate::types::UpdateEdgeRequest,
    pub term: ::std::primitive::i64,
    pub edge_version: ::std::option::Option<::std::primitive::i64>,
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ChainDeleteEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    pub txn_id: ::std::vec::Vec<::std::primitive::u8>,
    pub term: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct StatType(pub ::std::primitive::i32);

impl StatType {
    pub const SUM: Self = StatType(1i32);
    pub const COUNT: Self = StatType(2i32);
    pub const AVG: Self = StatType(3i32);
    pub const MAX: Self = StatType(4i32);
    pub const MIN: Self = StatType(5i32);
}

impl ::fbthrift::ThriftEnum for StatType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUM, "SUM"),
            (Self::COUNT, "COUNT"),
            (Self::AVG, "AVG"),
            (Self::MAX, "MAX"),
            (Self::MIN, "MIN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUM",
            "COUNT",
            "AVG",
            "MAX",
            "MIN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUM,
            Self::COUNT,
            Self::AVG,
            Self::MAX,
            Self::MIN,
        ]
    }
}

impl ::std::default::Default for StatType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a StatType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a StatType) -> Self {
        x.0
    }
}

impl ::std::convert::From<StatType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: StatType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for StatType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for StatType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SUM", 1),
            ("COUNT", 2),
            ("AVG", 3),
            ("MAX", 4),
            ("MIN", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for StatType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "StatType::{}", self)
    }
}

impl ::std::str::FromStr for StatType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("AVG", 3),
            ("COUNT", 2),
            ("MAX", 4),
            ("MIN", 5),
            ("SUM", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "StatType").map(Self)
    }
}

impl ::fbthrift::GetTType for StatType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for StatType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for StatType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct OrderDirection(pub ::std::primitive::i32);

impl OrderDirection {
    pub const ASCENDING: Self = OrderDirection(1i32);
    pub const DESCENDING: Self = OrderDirection(2i32);
}

impl ::fbthrift::ThriftEnum for OrderDirection {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ASCENDING, "ASCENDING"),
            (Self::DESCENDING, "DESCENDING"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ASCENDING",
            "DESCENDING",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ASCENDING,
            Self::DESCENDING,
        ]
    }
}

impl ::std::default::Default for OrderDirection {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a OrderDirection> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a OrderDirection) -> Self {
        x.0
    }
}

impl ::std::convert::From<OrderDirection> for ::std::primitive::i32 {
    #[inline]
    fn from(x: OrderDirection) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for OrderDirection {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for OrderDirection {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ASCENDING", 1),
            ("DESCENDING", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for OrderDirection {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "OrderDirection::{}", self)
    }
}

impl ::std::str::FromStr for OrderDirection {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ASCENDING", 1),
            ("DESCENDING", 2),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "OrderDirection").map(Self)
    }
}

impl ::fbthrift::GetTType for OrderDirection {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for OrderDirection
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for OrderDirection
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EdgeDirection(pub ::std::primitive::i32);

impl EdgeDirection {
    pub const BOTH: Self = EdgeDirection(1i32);
    pub const IN_EDGE: Self = EdgeDirection(2i32);
    pub const OUT_EDGE: Self = EdgeDirection(3i32);
}

impl ::fbthrift::ThriftEnum for EdgeDirection {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::BOTH, "BOTH"),
            (Self::IN_EDGE, "IN_EDGE"),
            (Self::OUT_EDGE, "OUT_EDGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "BOTH",
            "IN_EDGE",
            "OUT_EDGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::BOTH,
            Self::IN_EDGE,
            Self::OUT_EDGE,
        ]
    }
}

impl ::std::default::Default for EdgeDirection {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a EdgeDirection> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a EdgeDirection) -> Self {
        x.0
    }
}

impl ::std::convert::From<EdgeDirection> for ::std::primitive::i32 {
    #[inline]
    fn from(x: EdgeDirection) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for EdgeDirection {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for EdgeDirection {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BOTH", 1),
            ("IN_EDGE", 2),
            ("OUT_EDGE", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for EdgeDirection {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "EdgeDirection::{}", self)
    }
}

impl ::std::str::FromStr for EdgeDirection {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BOTH", 1),
            ("IN_EDGE", 2),
            ("OUT_EDGE", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "EdgeDirection").map(Self)
    }
}

impl ::fbthrift::GetTType for EdgeDirection {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for EdgeDirection
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for EdgeDirection
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ScanType(pub ::std::primitive::i32);

impl ScanType {
    pub const PREFIX: Self = ScanType(1i32);
    pub const RANGE: Self = ScanType(2i32);
}

impl ::fbthrift::ThriftEnum for ScanType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::PREFIX, "PREFIX"),
            (Self::RANGE, "RANGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "PREFIX",
            "RANGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::PREFIX,
            Self::RANGE,
        ]
    }
}

impl ::std::default::Default for ScanType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ScanType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ScanType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ScanType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ScanType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ScanType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ScanType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("PREFIX", 1),
            ("RANGE", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ScanType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ScanType::{}", self)
    }
}

impl ::std::str::FromStr for ScanType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("PREFIX", 1),
            ("RANGE", 2),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ScanType").map(Self)
    }
}

impl ::fbthrift::GetTType for ScanType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ScanType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ScanType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EngineSignType(pub ::std::primitive::i32);

impl EngineSignType {
    pub const BLOCK_ON: Self = EngineSignType(1i32);
    pub const BLOCK_OFF: Self = EngineSignType(2i32);
}

impl ::fbthrift::ThriftEnum for EngineSignType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::BLOCK_ON, "BLOCK_ON"),
            (Self::BLOCK_OFF, "BLOCK_OFF"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "BLOCK_ON",
            "BLOCK_OFF",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::BLOCK_ON,
            Self::BLOCK_OFF,
        ]
    }
}

impl ::std::default::Default for EngineSignType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a EngineSignType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a EngineSignType) -> Self {
        x.0
    }
}

impl ::std::convert::From<EngineSignType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: EngineSignType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for EngineSignType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for EngineSignType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BLOCK_ON", 1),
            ("BLOCK_OFF", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for EngineSignType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "EngineSignType::{}", self)
    }
}

impl ::std::str::FromStr for EngineSignType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BLOCK_OFF", 2),
            ("BLOCK_ON", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "EngineSignType").map(Self)
    }
}

impl ::fbthrift::GetTType for EngineSignType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for EngineSignType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for EngineSignType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RequestCommon {
    fn default() -> Self {
        Self {
            session_id: ::std::option::Option::None,
            plan_id: ::std::option::Option::None,
            profile_detail: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RequestCommon {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RequestCommon")
            .field("session_id", &self.session_id)
            .field("plan_id", &self.plan_id)
            .field("profile_detail", &self.profile_detail)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RequestCommon {}
unsafe impl ::std::marker::Sync for self::RequestCommon {}

impl ::fbthrift::GetTType for self::RequestCommon {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RequestCommon
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RequestCommon");
        if let ::std::option::Option::Some(some) = &self.session_id {
            p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.plan_id {
            p.write_field_begin("plan_id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.profile_detail {
            p.write_field_begin("profile_detail", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RequestCommon
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("plan_id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("profile_detail", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let mut field_plan_id = ::std::option::Option::None;
        let mut field_profile_detail = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_plan_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_profile_detail = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id,
            plan_id: field_plan_id,
            profile_detail: field_profile_detail,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartitionResult {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            leader: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartitionResult {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartitionResult")
            .field("code", &self.code)
            .field("part_id", &self.part_id)
            .field("leader", &self.leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartitionResult {}
unsafe impl ::std::marker::Sync for self::PartitionResult {}

impl ::fbthrift::GetTType for self::PartitionResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartitionResult
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartitionResult");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader {
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartitionResult
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            leader: field_leader,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ResponseCommon {
    fn default() -> Self {
        Self {
            failed_parts: ::std::default::Default::default(),
            latency_in_us: ::std::default::Default::default(),
            latency_detail_us: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ResponseCommon {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ResponseCommon")
            .field("failed_parts", &self.failed_parts)
            .field("latency_in_us", &self.latency_in_us)
            .field("latency_detail_us", &self.latency_detail_us)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ResponseCommon {}
unsafe impl ::std::marker::Sync for self::ResponseCommon {}

impl ::fbthrift::GetTType for self::ResponseCommon {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ResponseCommon
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ResponseCommon");
        p.write_field_begin("failed_parts", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.failed_parts, p);
        p.write_field_end();
        p.write_field_begin("latency_in_us", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.latency_in_us, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.latency_detail_us {
            p.write_field_begin("latency_detail_us", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ResponseCommon
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("failed_parts", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("latency_detail_us", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("latency_in_us", ::fbthrift::TType::I64, 2),
        ];
        let mut field_failed_parts = ::std::option::Option::None;
        let mut field_latency_in_us = ::std::option::Option::None;
        let mut field_latency_detail_us = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_failed_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_latency_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_latency_detail_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            failed_parts: field_failed_parts.unwrap_or_default(),
            latency_in_us: field_latency_in_us.unwrap_or_default(),
            latency_detail_us: field_latency_detail_us,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::StatProp {
    fn default() -> Self {
        Self {
            alias: ::std::default::Default::default(),
            prop: ::std::default::Default::default(),
            stat: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::StatProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("StatProp")
            .field("alias", &self.alias)
            .field("prop", &self.prop)
            .field("stat", &self.stat)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::StatProp {}
unsafe impl ::std::marker::Sync for self::StatProp {}

impl ::fbthrift::GetTType for self::StatProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::StatProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("StatProp");
        p.write_field_begin("alias", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.alias, p);
        p.write_field_end();
        p.write_field_begin("prop", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.prop, p);
        p.write_field_end();
        p.write_field_begin("stat", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.stat, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::StatProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("alias", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("prop", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("stat", ::fbthrift::TType::I32, 3),
        ];
        let mut field_alias = ::std::option::Option::None;
        let mut field_prop = ::std::option::Option::None;
        let mut field_stat = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_alias = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_stat = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            alias: field_alias.unwrap_or_default(),
            prop: field_prop.unwrap_or_default(),
            stat: field_stat.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Expr {
    fn default() -> Self {
        Self {
            alias: ::std::default::Default::default(),
            expr: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Expr {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Expr")
            .field("alias", &self.alias)
            .field("expr", &self.expr)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Expr {}
unsafe impl ::std::marker::Sync for self::Expr {}

impl ::fbthrift::GetTType for self::Expr {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Expr
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Expr");
        p.write_field_begin("alias", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.alias, p);
        p.write_field_end();
        p.write_field_begin("expr", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.expr, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Expr
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("alias", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("expr", ::fbthrift::TType::String, 2),
        ];
        let mut field_alias = ::std::option::Option::None;
        let mut field_expr = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_alias = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_expr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            alias: field_alias.unwrap_or_default(),
            expr: field_expr.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeProp {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeProp")
            .field("r#type", &self.r#type)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeProp {}
unsafe impl ::std::marker::Sync for self::EdgeProp {}

impl ::fbthrift::GetTType for self::EdgeProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeProp");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VertexProp {
    fn default() -> Self {
        Self {
            tag: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VertexProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VertexProp")
            .field("tag", &self.tag)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VertexProp {}
unsafe impl ::std::marker::Sync for self::VertexProp {}

impl ::fbthrift::GetTType for self::VertexProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VertexProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VertexProp");
        p.write_field_begin("tag", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VertexProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("tag", ::fbthrift::TType::I32, 1),
        ];
        let mut field_tag = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag: field_tag.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OrderBy {
    fn default() -> Self {
        Self {
            prop: ::std::default::Default::default(),
            direction: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OrderBy {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OrderBy")
            .field("prop", &self.prop)
            .field("direction", &self.direction)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OrderBy {}
unsafe impl ::std::marker::Sync for self::OrderBy {}

impl ::fbthrift::GetTType for self::OrderBy {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::OrderBy
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OrderBy");
        p.write_field_begin("prop", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.prop, p);
        p.write_field_end();
        p.write_field_begin("direction", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.direction, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OrderBy
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("direction", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("prop", ::fbthrift::TType::String, 1),
        ];
        let mut field_prop = ::std::option::Option::None;
        let mut field_direction = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_direction = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            prop: field_prop.unwrap_or_default(),
            direction: field_direction.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TraverseSpec {
    fn default() -> Self {
        Self {
            edge_types: ::std::default::Default::default(),
            edge_direction: crate::types::EdgeDirection::BOTH,
            dedup: false,
            stat_props: ::std::option::Option::None,
            vertex_props: ::std::option::Option::None,
            edge_props: ::std::option::Option::None,
            expressions: ::std::option::Option::None,
            order_by: ::std::option::Option::None,
            random: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            filter: ::std::option::Option::None,
            tag_filter: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TraverseSpec {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TraverseSpec")
            .field("edge_types", &self.edge_types)
            .field("edge_direction", &self.edge_direction)
            .field("dedup", &self.dedup)
            .field("stat_props", &self.stat_props)
            .field("vertex_props", &self.vertex_props)
            .field("edge_props", &self.edge_props)
            .field("expressions", &self.expressions)
            .field("order_by", &self.order_by)
            .field("random", &self.random)
            .field("limit", &self.limit)
            .field("filter", &self.filter)
            .field("tag_filter", &self.tag_filter)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TraverseSpec {}
unsafe impl ::std::marker::Sync for self::TraverseSpec {}

impl ::fbthrift::GetTType for self::TraverseSpec {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TraverseSpec
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TraverseSpec");
        p.write_field_begin("edge_types", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.edge_types, p);
        p.write_field_end();
        p.write_field_begin("edge_direction", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.edge_direction, p);
        p.write_field_end();
        p.write_field_begin("dedup", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.dedup, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.stat_props {
            p.write_field_begin("stat_props", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.vertex_props {
            p.write_field_begin("vertex_props", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.edge_props {
            p.write_field_begin("edge_props", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.expressions {
            p.write_field_begin("expressions", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.order_by {
            p.write_field_begin("order_by", ::fbthrift::TType::List, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.random {
            p.write_field_begin("random", ::fbthrift::TType::Bool, 9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.limit {
            p.write_field_begin("limit", ::fbthrift::TType::I64, 10);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.filter {
            p.write_field_begin("filter", ::fbthrift::TType::String, 11);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.tag_filter {
            p.write_field_begin("tag_filter", ::fbthrift::TType::String, 12);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TraverseSpec
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dedup", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("edge_direction", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("edge_props", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("edge_types", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("expressions", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 11),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I64, 10),
            ::fbthrift::Field::new("order_by", ::fbthrift::TType::List, 8),
            ::fbthrift::Field::new("random", ::fbthrift::TType::Bool, 9),
            ::fbthrift::Field::new("stat_props", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("tag_filter", ::fbthrift::TType::String, 12),
            ::fbthrift::Field::new("vertex_props", ::fbthrift::TType::List, 5),
        ];
        let mut field_edge_types = ::std::option::Option::None;
        let mut field_edge_direction = ::std::option::Option::None;
        let mut field_dedup = ::std::option::Option::None;
        let mut field_stat_props = ::std::option::Option::None;
        let mut field_vertex_props = ::std::option::Option::None;
        let mut field_edge_props = ::std::option::Option::None;
        let mut field_expressions = ::std::option::Option::None;
        let mut field_order_by = ::std::option::Option::None;
        let mut field_random = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_tag_filter = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_edge_types = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_edge_direction = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_dedup = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_stat_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_vertex_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_edge_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_expressions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_order_by = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 9) => field_random = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 10) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 11) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 12) => field_tag_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            edge_types: field_edge_types.unwrap_or_default(),
            edge_direction: field_edge_direction.unwrap_or(crate::types::EdgeDirection::BOTH),
            dedup: field_dedup.unwrap_or(false),
            stat_props: field_stat_props,
            vertex_props: field_vertex_props,
            edge_props: field_edge_props,
            expressions: field_expressions,
            order_by: field_order_by,
            random: field_random,
            limit: field_limit,
            filter: field_filter,
            tag_filter: field_tag_filter,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetNeighborsRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            column_names: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            traverse_spec: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetNeighborsRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetNeighborsRequest")
            .field("space_id", &self.space_id)
            .field("column_names", &self.column_names)
            .field("parts", &self.parts)
            .field("traverse_spec", &self.traverse_spec)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetNeighborsRequest {}
unsafe impl ::std::marker::Sync for self::GetNeighborsRequest {}

impl ::fbthrift::GetTType for self::GetNeighborsRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetNeighborsRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("column_names", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.column_names, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("traverse_spec", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.traverse_spec, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("column_names", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("traverse_spec", ::fbthrift::TType::Struct, 4),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_column_names = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_traverse_spec = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_traverse_spec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            column_names: field_column_names.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            traverse_spec: field_traverse_spec.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetNeighborsResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            vertices: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetNeighborsResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetNeighborsResponse")
            .field("result", &self.result)
            .field("vertices", &self.vertices)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetNeighborsResponse {}
unsafe impl ::std::marker::Sync for self::GetNeighborsResponse {}

impl ::fbthrift::GetTType for self::GetNeighborsResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetNeighborsResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.vertices {
            p.write_field_begin("vertices", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("vertices", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_vertices = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            vertices: field_vertices,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetDstBySrcRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            edge_types: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetDstBySrcRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetDstBySrcRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("edge_types", &self.edge_types)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetDstBySrcRequest {}
unsafe impl ::std::marker::Sync for self::GetDstBySrcRequest {}

impl ::fbthrift::GetTType for self::GetDstBySrcRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetDstBySrcRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetDstBySrcRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("edge_types", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_types, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetDstBySrcRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("edge_types", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_edge_types = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_types = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            edge_types: field_edge_types.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetDstBySrcResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            dsts: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetDstBySrcResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetDstBySrcResponse")
            .field("result", &self.result)
            .field("dsts", &self.dsts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetDstBySrcResponse {}
unsafe impl ::std::marker::Sync for self::GetDstBySrcResponse {}

impl ::fbthrift::GetTType for self::GetDstBySrcResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetDstBySrcResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetDstBySrcResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.dsts {
            p.write_field_begin("dsts", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetDstBySrcResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dsts", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_dsts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dsts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            dsts: field_dsts,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecResponse")
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecResponse {}
unsafe impl ::std::marker::Sync for self::ExecResponse {}

impl ::fbthrift::GetTType for self::ExecResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPropRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            vertex_props: ::std::option::Option::None,
            edge_props: ::std::option::Option::None,
            expressions: ::std::option::Option::None,
            dedup: false,
            order_by: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            filter: ::std::option::Option::None,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPropRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPropRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("vertex_props", &self.vertex_props)
            .field("edge_props", &self.edge_props)
            .field("expressions", &self.expressions)
            .field("dedup", &self.dedup)
            .field("order_by", &self.order_by)
            .field("limit", &self.limit)
            .field("filter", &self.filter)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPropRequest {}
unsafe impl ::std::marker::Sync for self::GetPropRequest {}

impl ::fbthrift::GetTType for self::GetPropRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPropRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPropRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.vertex_props {
            p.write_field_begin("vertex_props", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.edge_props {
            p.write_field_begin("edge_props", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.expressions {
            p.write_field_begin("expressions", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("dedup", ::fbthrift::TType::Bool, 6);
        ::fbthrift::Serialize::write(&self.dedup, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.order_by {
            p.write_field_begin("order_by", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.limit {
            p.write_field_begin("limit", ::fbthrift::TType::I64, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.filter {
            p.write_field_begin("filter", ::fbthrift::TType::String, 9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 10);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPropRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("dedup", ::fbthrift::TType::Bool, 6),
            ::fbthrift::Field::new("edge_props", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("expressions", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 9),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("order_by", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("vertex_props", ::fbthrift::TType::List, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_vertex_props = ::std::option::Option::None;
        let mut field_edge_props = ::std::option::Option::None;
        let mut field_expressions = ::std::option::Option::None;
        let mut field_dedup = ::std::option::Option::None;
        let mut field_order_by = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_vertex_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_edge_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_expressions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 6) => field_dedup = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_order_by = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 9) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 10) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            vertex_props: field_vertex_props,
            edge_props: field_edge_props,
            expressions: field_expressions,
            dedup: field_dedup.unwrap_or(false),
            order_by: field_order_by,
            limit: field_limit,
            filter: field_filter,
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPropResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            props: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPropResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPropResponse")
            .field("result", &self.result)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPropResponse {}
unsafe impl ::std::marker::Sync for self::GetPropResponse {}

impl ::fbthrift::GetTType for self::GetPropResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPropResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPropResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.props {
            p.write_field_begin("props", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPropResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            props: field_props,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NewTag {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NewTag {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NewTag")
            .field("tag_id", &self.tag_id)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NewTag {}
unsafe impl ::std::marker::Sync for self::NewTag {}

impl ::fbthrift::GetTType for self::NewTag {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NewTag
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NewTag");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NewTag
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NewVertex {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NewVertex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NewVertex")
            .field("id", &self.id)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NewVertex {}
unsafe impl ::std::marker::Sync for self::NewVertex {}

impl ::fbthrift::GetTType for self::NewVertex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NewVertex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NewVertex");
        p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NewVertex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeKey {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            edge_type: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            dst: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeKey {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeKey")
            .field("src", &self.src)
            .field("edge_type", &self.edge_type)
            .field("ranking", &self.ranking)
            .field("dst", &self.dst)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeKey {}
unsafe impl ::std::marker::Sync for self::EdgeKey {}

impl ::fbthrift::GetTType for self::EdgeKey {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeKey
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeKey");
        p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("dst", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeKey
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_dst = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            edge_type: field_edge_type.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            dst: field_dst.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NewEdge {
    fn default() -> Self {
        Self {
            key: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NewEdge {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NewEdge")
            .field("key", &self.key)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NewEdge {}
unsafe impl ::std::marker::Sync for self::NewEdge {}

impl ::fbthrift::GetTType for self::NewEdge {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NewEdge
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NewEdge");
        p.write_field_begin("key", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NewEdge
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("props", ::fbthrift::TType::List, 2),
        ];
        let mut field_key = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            key: field_key.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddVerticesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            prop_names: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            ignore_existed_index: false,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddVerticesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddVerticesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("prop_names", &self.prop_names)
            .field("if_not_exists", &self.if_not_exists)
            .field("ignore_existed_index", &self.ignore_existed_index)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddVerticesRequest {}
unsafe impl ::std::marker::Sync for self::AddVerticesRequest {}

impl ::fbthrift::GetTType for self::AddVerticesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddVerticesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddVerticesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("prop_names", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.prop_names, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_begin("ignore_existed_index", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.ignore_existed_index, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddVerticesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("ignore_existed_index", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("prop_names", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_prop_names = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_ignore_existed_index = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_prop_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_ignore_existed_index = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            prop_names: field_prop_names.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            ignore_existed_index: field_ignore_existed_index.unwrap_or(false),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            prop_names: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            ignore_existed_index: false,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("prop_names", &self.prop_names)
            .field("if_not_exists", &self.if_not_exists)
            .field("ignore_existed_index", &self.ignore_existed_index)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddEdgesRequest {}
unsafe impl ::std::marker::Sync for self::AddEdgesRequest {}

impl ::fbthrift::GetTType for self::AddEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("prop_names", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.prop_names, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_begin("ignore_existed_index", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.ignore_existed_index, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("ignore_existed_index", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("prop_names", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_prop_names = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_ignore_existed_index = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_prop_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_ignore_existed_index = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            prop_names: field_prop_names.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            ignore_existed_index: field_ignore_existed_index.unwrap_or(false),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DeleteVerticesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DeleteVerticesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DeleteVerticesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DeleteVerticesRequest {}
unsafe impl ::std::marker::Sync for self::DeleteVerticesRequest {}

impl ::fbthrift::GetTType for self::DeleteVerticesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DeleteVerticesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DeleteVerticesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DeleteVerticesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DeleteEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DeleteEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DeleteEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DeleteEdgesRequest {}
unsafe impl ::std::marker::Sync for self::DeleteEdgesRequest {}

impl ::fbthrift::GetTType for self::DeleteEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DeleteEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DeleteEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DeleteEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DelTags {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DelTags {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DelTags")
            .field("id", &self.id)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DelTags {}
unsafe impl ::std::marker::Sync for self::DelTags {}

impl ::fbthrift::GetTType for self::DelTags {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DelTags
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DelTags");
        p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DelTags
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DeleteTagsRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DeleteTagsRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DeleteTagsRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DeleteTagsRequest {}
unsafe impl ::std::marker::Sync for self::DeleteTagsRequest {}

impl ::fbthrift::GetTType for self::DeleteTagsRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DeleteTagsRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DeleteTagsRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DeleteTagsRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            props: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateResponse")
            .field("result", &self.result)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateResponse {}
unsafe impl ::std::marker::Sync for self::UpdateResponse {}

impl ::fbthrift::GetTType for self::UpdateResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.props {
            p.write_field_begin("props", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            props: field_props,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdatedProp {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdatedProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdatedProp")
            .field("name", &self.name)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdatedProp {}
unsafe impl ::std::marker::Sync for self::UpdatedProp {}

impl ::fbthrift::GetTType for self::UpdatedProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdatedProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdatedProp");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdatedProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateVertexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            vertex_id: ::std::default::Default::default(),
            tag_id: ::std::default::Default::default(),
            updated_props: ::std::default::Default::default(),
            insertable: ::std::option::Option::Some(false),
            return_props: ::std::option::Option::None,
            condition: ::std::option::Option::None,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateVertexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateVertexRequest")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("vertex_id", &self.vertex_id)
            .field("tag_id", &self.tag_id)
            .field("updated_props", &self.updated_props)
            .field("insertable", &self.insertable)
            .field("return_props", &self.return_props)
            .field("condition", &self.condition)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateVertexRequest {}
unsafe impl ::std::marker::Sync for self::UpdateVertexRequest {}

impl ::fbthrift::GetTType for self::UpdateVertexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateVertexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateVertexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("vertex_id", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.vertex_id, p);
        p.write_field_end();
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("updated_props", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.updated_props, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.insertable {
            p.write_field_begin("insertable", ::fbthrift::TType::Bool, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.return_props {
            p.write_field_begin("return_props", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.condition {
            p.write_field_begin("condition", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateVertexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 9),
            ::fbthrift::Field::new("condition", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("insertable", ::fbthrift::TType::Bool, 6),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("return_props", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("updated_props", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("vertex_id", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_vertex_id = ::std::option::Option::None;
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_updated_props = ::std::option::Option::None;
        let mut field_insertable = ::std::option::Option::None;
        let mut field_return_props = ::std::option::Option::None;
        let mut field_condition = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_updated_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 6) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_return_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_condition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 9) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            vertex_id: field_vertex_id.unwrap_or_default(),
            tag_id: field_tag_id.unwrap_or_default(),
            updated_props: field_updated_props.unwrap_or_default(),
            insertable: field_insertable,
            return_props: field_return_props,
            condition: field_condition,
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateEdgeRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            edge_key: ::std::default::Default::default(),
            updated_props: ::std::default::Default::default(),
            insertable: ::std::option::Option::Some(false),
            return_props: ::std::option::Option::None,
            condition: ::std::option::Option::None,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateEdgeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateEdgeRequest")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("edge_key", &self.edge_key)
            .field("updated_props", &self.updated_props)
            .field("insertable", &self.insertable)
            .field("return_props", &self.return_props)
            .field("condition", &self.condition)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateEdgeRequest {}
unsafe impl ::std::marker::Sync for self::UpdateEdgeRequest {}

impl ::fbthrift::GetTType for self::UpdateEdgeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateEdgeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateEdgeRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("edge_key", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.edge_key, p);
        p.write_field_end();
        p.write_field_begin("updated_props", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.updated_props, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.insertable {
            p.write_field_begin("insertable", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.return_props {
            p.write_field_begin("return_props", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.condition {
            p.write_field_begin("condition", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateEdgeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 8),
            ::fbthrift::Field::new("condition", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("edge_key", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("insertable", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("return_props", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("updated_props", ::fbthrift::TType::List, 4),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_edge_key = ::std::option::Option::None;
        let mut field_updated_props = ::std::option::Option::None;
        let mut field_insertable = ::std::option::Option::None;
        let mut field_return_props = ::std::option::Option::None;
        let mut field_condition = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_edge_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_updated_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_return_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_condition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 8) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            edge_key: field_edge_key.unwrap_or_default(),
            updated_props: field_updated_props.unwrap_or_default(),
            insertable: field_insertable,
            return_props: field_return_props,
            condition: field_condition,
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUUIDReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUUIDReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUUIDReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("name", &self.name)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUUIDReq {}
unsafe impl ::std::marker::Sync for self::GetUUIDReq {}

impl ::fbthrift::GetTType for self::GetUUIDReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUUIDReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUUIDReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUUIDResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUUIDResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUUIDResp")
            .field("result", &self.result)
            .field("id", &self.id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUUIDResp {}
unsafe impl ::std::marker::Sync for self::GetUUIDResp {}

impl ::fbthrift::GetTType for self::GetUUIDResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUUIDResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUUIDResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LookupIndexResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            data: ::std::option::Option::None,
            stat_data: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LookupIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LookupIndexResp")
            .field("result", &self.result)
            .field("data", &self.data)
            .field("stat_data", &self.stat_data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LookupIndexResp {}
unsafe impl ::std::marker::Sync for self::LookupIndexResp {}

impl ::fbthrift::GetTType for self::LookupIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LookupIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LookupIndexResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.data {
            p.write_field_begin("data", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.stat_data {
            p.write_field_begin("stat_data", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LookupIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("stat_data", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let mut field_stat_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_stat_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            data: field_data,
            stat_data: field_stat_data,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexColumnHint {
    fn default() -> Self {
        Self {
            column_name: ::std::default::Default::default(),
            scan_type: ::std::default::Default::default(),
            begin_value: ::std::default::Default::default(),
            end_value: ::std::default::Default::default(),
            include_begin: true,
            include_end: false,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexColumnHint {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexColumnHint")
            .field("column_name", &self.column_name)
            .field("scan_type", &self.scan_type)
            .field("begin_value", &self.begin_value)
            .field("end_value", &self.end_value)
            .field("include_begin", &self.include_begin)
            .field("include_end", &self.include_end)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexColumnHint {}
unsafe impl ::std::marker::Sync for self::IndexColumnHint {}

impl ::fbthrift::GetTType for self::IndexColumnHint {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexColumnHint
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexColumnHint");
        p.write_field_begin("column_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.column_name, p);
        p.write_field_end();
        p.write_field_begin("scan_type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.scan_type, p);
        p.write_field_end();
        p.write_field_begin("begin_value", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.begin_value, p);
        p.write_field_end();
        p.write_field_begin("end_value", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.end_value, p);
        p.write_field_end();
        p.write_field_begin("include_begin", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.include_begin, p);
        p.write_field_end();
        p.write_field_begin("include_end", ::fbthrift::TType::Bool, 6);
        ::fbthrift::Serialize::write(&self.include_end, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexColumnHint
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("begin_value", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("column_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("end_value", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("include_begin", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("include_end", ::fbthrift::TType::Bool, 6),
            ::fbthrift::Field::new("scan_type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_column_name = ::std::option::Option::None;
        let mut field_scan_type = ::std::option::Option::None;
        let mut field_begin_value = ::std::option::Option::None;
        let mut field_end_value = ::std::option::Option::None;
        let mut field_include_begin = ::std::option::Option::None;
        let mut field_include_end = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_column_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_scan_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_begin_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_end_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_include_begin = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 6) => field_include_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            column_name: field_column_name.unwrap_or_default(),
            scan_type: field_scan_type.unwrap_or_default(),
            begin_value: field_begin_value.unwrap_or_default(),
            end_value: field_end_value.unwrap_or_default(),
            include_begin: field_include_begin.unwrap_or(true),
            include_end: field_include_end.unwrap_or(false),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexQueryContext {
    fn default() -> Self {
        Self {
            index_id: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            column_hints: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexQueryContext {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexQueryContext")
            .field("index_id", &self.index_id)
            .field("filter", &self.filter)
            .field("column_hints", &self.column_hints)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexQueryContext {}
unsafe impl ::std::marker::Sync for self::IndexQueryContext {}

impl ::fbthrift::GetTType for self::IndexQueryContext {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexQueryContext
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexQueryContext");
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("column_hints", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.column_hints, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexQueryContext
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("column_hints", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_index_id = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_column_hints = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_column_hints = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            index_id: field_index_id.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            column_hints: field_column_hints.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexSpec {
    fn default() -> Self {
        Self {
            contexts: ::std::default::Default::default(),
            schema_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexSpec {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexSpec")
            .field("contexts", &self.contexts)
            .field("schema_id", &self.schema_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexSpec {}
unsafe impl ::std::marker::Sync for self::IndexSpec {}

impl ::fbthrift::GetTType for self::IndexSpec {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexSpec
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexSpec");
        p.write_field_begin("contexts", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.contexts, p);
        p.write_field_end();
        p.write_field_begin("schema_id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexSpec
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("contexts", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("schema_id", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_contexts = ::std::option::Option::None;
        let mut field_schema_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_contexts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            contexts: field_contexts.unwrap_or_default(),
            schema_id: field_schema_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LookupIndexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            indices: ::std::default::Default::default(),
            return_columns: ::std::option::Option::None,
            common: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            order_by: ::std::option::Option::None,
            stat_columns: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LookupIndexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LookupIndexRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("indices", &self.indices)
            .field("return_columns", &self.return_columns)
            .field("common", &self.common)
            .field("limit", &self.limit)
            .field("order_by", &self.order_by)
            .field("stat_columns", &self.stat_columns)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LookupIndexRequest {}
unsafe impl ::std::marker::Sync for self::LookupIndexRequest {}

impl ::fbthrift::GetTType for self::LookupIndexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LookupIndexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LookupIndexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("indices", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.indices, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.return_columns {
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.limit {
            p.write_field_begin("limit", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.order_by {
            p.write_field_begin("order_by", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.stat_columns {
            p.write_field_begin("stat_columns", ::fbthrift::TType::List, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LookupIndexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("indices", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("order_by", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("stat_columns", ::fbthrift::TType::List, 8),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_indices = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_order_by = ::std::option::Option::None;
        let mut field_stat_columns = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_indices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_order_by = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_stat_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            indices: field_indices.unwrap_or_default(),
            return_columns: field_return_columns,
            common: field_common,
            limit: field_limit,
            order_by: field_order_by,
            stat_columns: field_stat_columns,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LookupAndTraverseRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            indices: ::std::default::Default::default(),
            traverse_spec: ::std::default::Default::default(),
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LookupAndTraverseRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LookupAndTraverseRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("indices", &self.indices)
            .field("traverse_spec", &self.traverse_spec)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LookupAndTraverseRequest {}
unsafe impl ::std::marker::Sync for self::LookupAndTraverseRequest {}

impl ::fbthrift::GetTType for self::LookupAndTraverseRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LookupAndTraverseRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LookupAndTraverseRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("indices", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.indices, p);
        p.write_field_end();
        p.write_field_begin("traverse_spec", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.traverse_spec, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LookupAndTraverseRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("indices", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("traverse_spec", ::fbthrift::TType::Struct, 4),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_indices = ::std::option::Option::None;
        let mut field_traverse_spec = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_indices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_traverse_spec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            indices: field_indices.unwrap_or_default(),
            traverse_spec: field_traverse_spec.unwrap_or_default(),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanCursor {
    fn default() -> Self {
        Self {
            next_cursor: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanCursor {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanCursor")
            .field("next_cursor", &self.next_cursor)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanCursor {}
unsafe impl ::std::marker::Sync for self::ScanCursor {}

impl ::fbthrift::GetTType for self::ScanCursor {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanCursor
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanCursor");
        if let ::std::option::Option::Some(some) = &self.next_cursor {
            p.write_field_begin("next_cursor", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanCursor
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("next_cursor", ::fbthrift::TType::String, 1),
        ];
        let mut field_next_cursor = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_next_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            next_cursor: field_next_cursor,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanVertexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            limit: ::std::default::Default::default(),
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            filter: ::std::option::Option::None,
            only_latest_version: false,
            enable_read_from_follower: true,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanVertexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanVertexRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("return_columns", &self.return_columns)
            .field("limit", &self.limit)
            .field("start_time", &self.start_time)
            .field("end_time", &self.end_time)
            .field("filter", &self.filter)
            .field("only_latest_version", &self.only_latest_version)
            .field("enable_read_from_follower", &self.enable_read_from_follower)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanVertexRequest {}
unsafe impl ::std::marker::Sync for self::ScanVertexRequest {}

impl ::fbthrift::GetTType for self::ScanVertexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanVertexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanVertexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("limit", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.limit, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.start_time {
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.end_time {
            p.write_field_begin("end_time", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.filter {
            p.write_field_begin("filter", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("only_latest_version", ::fbthrift::TType::Bool, 8);
        ::fbthrift::Serialize::write(&self.only_latest_version, p);
        p.write_field_end();
        p.write_field_begin("enable_read_from_follower", ::fbthrift::TType::Bool, 9);
        ::fbthrift::Serialize::write(&self.enable_read_from_follower, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 10);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanVertexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("enable_read_from_follower", ::fbthrift::TType::Bool, 9),
            ::fbthrift::Field::new("end_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("only_latest_version", ::fbthrift::TType::Bool, 8),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_end_time = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_only_latest_version = ::std::option::Option::None;
        let mut field_enable_read_from_follower = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 8) => field_only_latest_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 9) => field_enable_read_from_follower = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 10) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            limit: field_limit.unwrap_or_default(),
            start_time: field_start_time,
            end_time: field_end_time,
            filter: field_filter,
            only_latest_version: field_only_latest_version.unwrap_or(false),
            enable_read_from_follower: field_enable_read_from_follower.unwrap_or(true),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanEdgeRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            limit: ::std::default::Default::default(),
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            filter: ::std::option::Option::None,
            only_latest_version: false,
            enable_read_from_follower: true,
            common: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanEdgeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanEdgeRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("return_columns", &self.return_columns)
            .field("limit", &self.limit)
            .field("start_time", &self.start_time)
            .field("end_time", &self.end_time)
            .field("filter", &self.filter)
            .field("only_latest_version", &self.only_latest_version)
            .field("enable_read_from_follower", &self.enable_read_from_follower)
            .field("common", &self.common)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanEdgeRequest {}
unsafe impl ::std::marker::Sync for self::ScanEdgeRequest {}

impl ::fbthrift::GetTType for self::ScanEdgeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanEdgeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanEdgeRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("limit", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.limit, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.start_time {
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.end_time {
            p.write_field_begin("end_time", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.filter {
            p.write_field_begin("filter", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("only_latest_version", ::fbthrift::TType::Bool, 8);
        ::fbthrift::Serialize::write(&self.only_latest_version, p);
        p.write_field_end();
        p.write_field_begin("enable_read_from_follower", ::fbthrift::TType::Bool, 9);
        ::fbthrift::Serialize::write(&self.enable_read_from_follower, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.common {
            p.write_field_begin("common", ::fbthrift::TType::Struct, 10);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanEdgeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("common", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("enable_read_from_follower", ::fbthrift::TType::Bool, 9),
            ::fbthrift::Field::new("end_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("only_latest_version", ::fbthrift::TType::Bool, 8),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_end_time = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_only_latest_version = ::std::option::Option::None;
        let mut field_enable_read_from_follower = ::std::option::Option::None;
        let mut field_common = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 8) => field_only_latest_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 9) => field_enable_read_from_follower = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 10) => field_common = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            limit: field_limit.unwrap_or_default(),
            start_time: field_start_time,
            end_time: field_end_time,
            filter: field_filter,
            only_latest_version: field_only_latest_version.unwrap_or(false),
            enable_read_from_follower: field_enable_read_from_follower.unwrap_or(true),
            common: field_common,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            props: ::std::option::Option::None,
            cursors: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanResponse")
            .field("result", &self.result)
            .field("props", &self.props)
            .field("cursors", &self.cursors)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanResponse {}
unsafe impl ::std::marker::Sync for self::ScanResponse {}

impl ::fbthrift::GetTType for self::ScanResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.props {
            p.write_field_begin("props", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("cursors", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.cursors, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cursors", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let mut field_cursors = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_cursors = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            props: field_props,
            cursors: field_cursors.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TaskPara {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::option::Option::None,
            task_specific_paras: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TaskPara {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TaskPara")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("task_specific_paras", &self.task_specific_paras)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TaskPara {}
unsafe impl ::std::marker::Sync for self::TaskPara {}

impl ::fbthrift::GetTType for self::TaskPara {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TaskPara
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TaskPara");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.parts {
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.task_specific_paras {
            p.write_field_begin("task_specific_paras", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TaskPara
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("task_specific_paras", ::fbthrift::TType::List, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_task_specific_paras = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_task_specific_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts,
            task_specific_paras: field_task_specific_paras,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KVGetRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            return_partly: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KVGetRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KVGetRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("return_partly", &self.return_partly)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KVGetRequest {}
unsafe impl ::std::marker::Sync for self::KVGetRequest {}

impl ::fbthrift::GetTType for self::KVGetRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KVGetRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KVGetRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("return_partly", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.return_partly, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KVGetRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_partly", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_return_partly = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_return_partly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            return_partly: field_return_partly.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KVGetResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            key_values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KVGetResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KVGetResponse")
            .field("result", &self.result)
            .field("key_values", &self.key_values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KVGetResponse {}
unsafe impl ::std::marker::Sync for self::KVGetResponse {}

impl ::fbthrift::GetTType for self::KVGetResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KVGetResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KVGetResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("key_values", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.key_values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KVGetResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key_values", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_key_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_key_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            key_values: field_key_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KVPutRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KVPutRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KVPutRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KVPutRequest {}
unsafe impl ::std::marker::Sync for self::KVPutRequest {}

impl ::fbthrift::GetTType for self::KVPutRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KVPutRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KVPutRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KVPutRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KVRemoveRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KVRemoveRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KVRemoveRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KVRemoveRequest {}
unsafe impl ::std::marker::Sync for self::KVRemoveRequest {}

impl ::fbthrift::GetTType for self::KVRemoveRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KVRemoveRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KVRemoveRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KVRemoveRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminExecResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            stats: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminExecResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminExecResp")
            .field("result", &self.result)
            .field("stats", &self.stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminExecResp {}
unsafe impl ::std::marker::Sync for self::AdminExecResp {}

impl ::fbthrift::GetTType for self::AdminExecResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminExecResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminExecResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.stats {
            p.write_field_begin("stats", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminExecResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("stats", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            stats: field_stats,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TransLeaderReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            new_leader: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TransLeaderReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TransLeaderReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("new_leader", &self.new_leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TransLeaderReq {}
unsafe impl ::std::marker::Sync for self::TransLeaderReq {}

impl ::fbthrift::GetTType for self::TransLeaderReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TransLeaderReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TransLeaderReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("new_leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.new_leader, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TransLeaderReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("new_leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_new_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_new_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            new_leader: field_new_leader.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddPartReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            as_learner: ::std::default::Default::default(),
            peers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddPartReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddPartReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("as_learner", &self.as_learner)
            .field("peers", &self.peers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddPartReq {}
unsafe impl ::std::marker::Sync for self::AddPartReq {}

impl ::fbthrift::GetTType for self::AddPartReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddPartReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddPartReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("as_learner", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.as_learner, p);
        p.write_field_end();
        p.write_field_begin("peers", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddPartReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("as_learner", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_as_learner = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_as_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            as_learner: field_as_learner.unwrap_or_default(),
            peers: field_peers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddLearnerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            learner: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddLearnerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddLearnerReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("learner", &self.learner)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddLearnerReq {}
unsafe impl ::std::marker::Sync for self::AddLearnerReq {}

impl ::fbthrift::GetTType for self::AddLearnerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddLearnerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddLearnerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("learner", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.learner, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddLearnerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("learner", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_learner = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            learner: field_learner.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemovePartReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemovePartReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemovePartReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemovePartReq {}
unsafe impl ::std::marker::Sync for self::RemovePartReq {}

impl ::fbthrift::GetTType for self::RemovePartReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemovePartReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemovePartReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemovePartReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MemberChangeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            peer: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MemberChangeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MemberChangeReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("peer", &self.peer)
            .field("add", &self.add)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MemberChangeReq {}
unsafe impl ::std::marker::Sync for self::MemberChangeReq {}

impl ::fbthrift::GetTType for self::MemberChangeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MemberChangeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MemberChangeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("peer", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.peer, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MemberChangeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peer", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_peer = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_peer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            peer: field_peer.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CatchUpDataReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            target: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CatchUpDataReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CatchUpDataReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("target", &self.target)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CatchUpDataReq {}
unsafe impl ::std::marker::Sync for self::CatchUpDataReq {}

impl ::fbthrift::GetTType for self::CatchUpDataReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CatchUpDataReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CatchUpDataReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("target", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.target, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CatchUpDataReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("target", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_target = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_target = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            target: field_target.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetLeaderReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetLeaderReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetLeaderReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetLeaderReq {}
unsafe impl ::std::marker::Sync for self::GetLeaderReq {}

impl ::fbthrift::GetTType for self::GetLeaderReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetLeaderReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetLeaderReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateCPRequest {
    fn default() -> Self {
        Self {
            space_ids: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateCPRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateCPRequest")
            .field("space_ids", &self.space_ids)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateCPRequest {}
unsafe impl ::std::marker::Sync for self::CreateCPRequest {}

impl ::fbthrift::GetTType for self::CreateCPRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateCPRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateCPRequest");
        p.write_field_begin("space_ids", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.space_ids, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateCPRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_ids", ::fbthrift::TType::List, 1),
        ];
        let mut field_space_ids = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_space_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_ids: field_space_ids.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateCPResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            info: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateCPResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateCPResp")
            .field("code", &self.code)
            .field("info", &self.info)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateCPResp {}
unsafe impl ::std::marker::Sync for self::CreateCPResp {}

impl ::fbthrift::GetTType for self::CreateCPResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateCPResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateCPResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("info", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.info, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateCPResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("info", ::fbthrift::TType::List, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_info = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            info: field_info.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropCPRequest {
    fn default() -> Self {
        Self {
            space_ids: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropCPRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropCPRequest")
            .field("space_ids", &self.space_ids)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropCPRequest {}
unsafe impl ::std::marker::Sync for self::DropCPRequest {}

impl ::fbthrift::GetTType for self::DropCPRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropCPRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropCPRequest");
        p.write_field_begin("space_ids", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.space_ids, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropCPRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_ids", ::fbthrift::TType::List, 1),
        ];
        let mut field_space_ids = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_space_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_ids: field_space_ids.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropCPResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropCPResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropCPResp")
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropCPResp {}
unsafe impl ::std::marker::Sync for self::DropCPResp {}

impl ::fbthrift::GetTType for self::DropCPResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropCPResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropCPResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropCPResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BlockingSignRequest {
    fn default() -> Self {
        Self {
            space_ids: ::std::default::Default::default(),
            sign: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BlockingSignRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BlockingSignRequest")
            .field("space_ids", &self.space_ids)
            .field("sign", &self.sign)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BlockingSignRequest {}
unsafe impl ::std::marker::Sync for self::BlockingSignRequest {}

impl ::fbthrift::GetTType for self::BlockingSignRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BlockingSignRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BlockingSignRequest");
        p.write_field_begin("space_ids", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.space_ids, p);
        p.write_field_end();
        p.write_field_begin("sign", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.sign, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BlockingSignRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("sign", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_ids", ::fbthrift::TType::List, 1),
        ];
        let mut field_space_ids = ::std::option::Option::None;
        let mut field_sign = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_space_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_sign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_ids: field_space_ids.unwrap_or_default(),
            sign: field_sign.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BlockingSignResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BlockingSignResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BlockingSignResp")
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BlockingSignResp {}
unsafe impl ::std::marker::Sync for self::BlockingSignResp {}

impl ::fbthrift::GetTType for self::BlockingSignResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BlockingSignResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BlockingSignResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BlockingSignResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetLeaderPartsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader_parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetLeaderPartsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetLeaderPartsResp")
            .field("code", &self.code)
            .field("leader_parts", &self.leader_parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetLeaderPartsResp {}
unsafe impl ::std::marker::Sync for self::GetLeaderPartsResp {}

impl ::fbthrift::GetTType for self::GetLeaderPartsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetLeaderPartsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetLeaderPartsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.leader_parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderPartsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader_parts: field_leader_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CheckPeersReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            peers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CheckPeersReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CheckPeersReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("peers", &self.peers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CheckPeersReq {}
unsafe impl ::std::marker::Sync for self::CheckPeersReq {}

impl ::fbthrift::GetTType for self::CheckPeersReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CheckPeersReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CheckPeersReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("peers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CheckPeersReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            peers: field_peers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RebuildIndexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            index_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RebuildIndexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RebuildIndexRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("index_id", &self.index_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RebuildIndexRequest {}
unsafe impl ::std::marker::Sync for self::RebuildIndexRequest {}

impl ::fbthrift::GetTType for self::RebuildIndexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RebuildIndexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_index_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            index_id: field_index_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            dir: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoResp")
            .field("result", &self.result)
            .field("dir", &self.dir)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoResp {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoResp {}

impl ::fbthrift::GetTType for self::ListClusterInfoResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("dir", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dir, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_dir = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            dir: field_dir.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoReq {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoReq {}

impl ::fbthrift::GetTType for self::ListClusterInfoReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddTaskRequest {
    fn default() -> Self {
        Self {
            job_type: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            task_id: ::std::default::Default::default(),
            para: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddTaskRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddTaskRequest")
            .field("job_type", &self.job_type)
            .field("job_id", &self.job_id)
            .field("task_id", &self.task_id)
            .field("para", &self.para)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddTaskRequest {}
unsafe impl ::std::marker::Sync for self::AddTaskRequest {}

impl ::fbthrift::GetTType for self::AddTaskRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddTaskRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddTaskRequest");
        p.write_field_begin("job_type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.job_type, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        p.write_field_begin("para", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.para, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddTaskRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("job_type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("para", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 3),
        ];
        let mut field_job_type = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let mut field_task_id = ::std::option::Option::None;
        let mut field_para = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_job_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_para = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            job_type: field_job_type.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            task_id: field_task_id.unwrap_or_default(),
            para: field_para.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddTaskResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddTaskResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddTaskResp")
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddTaskResp {}
unsafe impl ::std::marker::Sync for self::AddTaskResp {}

impl ::fbthrift::GetTType for self::AddTaskResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddTaskResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddTaskResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddTaskResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::StopTaskRequest {
    fn default() -> Self {
        Self {
            job_id: ::std::default::Default::default(),
            task_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::StopTaskRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("StopTaskRequest")
            .field("job_id", &self.job_id)
            .field("task_id", &self.task_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::StopTaskRequest {}
unsafe impl ::std::marker::Sync for self::StopTaskRequest {}

impl ::fbthrift::GetTType for self::StopTaskRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::StopTaskRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("StopTaskRequest");
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::StopTaskRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 2),
        ];
        let mut field_job_id = ::std::option::Option::None;
        let mut field_task_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            job_id: field_job_id.unwrap_or_default(),
            task_id: field_task_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::StopTaskResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::StopTaskResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("StopTaskResp")
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::StopTaskResp {}
unsafe impl ::std::marker::Sync for self::StopTaskResp {}

impl ::fbthrift::GetTType for self::StopTaskResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::StopTaskResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("StopTaskResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::StopTaskResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ClearSpaceReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ClearSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ClearSpaceReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ClearSpaceReq {}
unsafe impl ::std::marker::Sync for self::ClearSpaceReq {}

impl ::fbthrift::GetTType for self::ClearSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ClearSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ClearSpaceReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ClearSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ClearSpaceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ClearSpaceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ClearSpaceResp")
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ClearSpaceResp {}
unsafe impl ::std::marker::Sync for self::ClearSpaceResp {}

impl ::fbthrift::GetTType for self::ClearSpaceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ClearSpaceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ClearSpaceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ClearSpaceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChainAddEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            prop_names: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            edge_version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChainAddEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChainAddEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("prop_names", &self.prop_names)
            .field("if_not_exists", &self.if_not_exists)
            .field("term", &self.term)
            .field("edge_version", &self.edge_version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChainAddEdgesRequest {}
unsafe impl ::std::marker::Sync for self::ChainAddEdgesRequest {}

impl ::fbthrift::GetTType for self::ChainAddEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChainAddEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChainAddEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("prop_names", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.prop_names, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.edge_version {
            p.write_field_begin("edge_version", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChainAddEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_version", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("prop_names", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 5),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_prop_names = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_edge_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_prop_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_edge_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            prop_names: field_prop_names.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            edge_version: field_edge_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChainUpdateEdgeRequest {
    fn default() -> Self {
        Self {
            update_edge_request: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            edge_version: ::std::option::Option::None,
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChainUpdateEdgeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChainUpdateEdgeRequest")
            .field("update_edge_request", &self.update_edge_request)
            .field("term", &self.term)
            .field("edge_version", &self.edge_version)
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChainUpdateEdgeRequest {}
unsafe impl ::std::marker::Sync for self::ChainUpdateEdgeRequest {}

impl ::fbthrift::GetTType for self::ChainUpdateEdgeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChainUpdateEdgeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChainUpdateEdgeRequest");
        p.write_field_begin("update_edge_request", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.update_edge_request, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.edge_version {
            p.write_field_begin("edge_version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChainUpdateEdgeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_version", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("update_edge_request", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_update_edge_request = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_edge_version = ::std::option::Option::None;
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_update_edge_request = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_edge_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            update_edge_request: field_update_edge_request.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            edge_version: field_edge_version,
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChainDeleteEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            txn_id: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChainDeleteEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChainDeleteEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("txn_id", &self.txn_id)
            .field("term", &self.term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChainDeleteEdgesRequest {}
unsafe impl ::std::marker::Sync for self::ChainDeleteEdgesRequest {}

impl ::fbthrift::GetTType for self::ChainDeleteEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChainDeleteEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChainDeleteEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("txn_id", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.txn_id, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChainDeleteEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("txn_id", ::fbthrift::TType::String, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_txn_id = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_txn_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            txn_id: field_txn_id.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
