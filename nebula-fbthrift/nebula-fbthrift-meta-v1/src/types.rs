// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `meta`.

#![allow(clippy::redundant_closure)]


#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ID {
    space_id(common::types::GraphSpaceID),
    tag_id(common::types::TagID),
    edge_type(common::types::EdgeType),
    index_id(common::types::IndexID),
    cluster_id(common::types::ClusterID),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq)]
pub struct IdName {
    pub id: crate::types::ID,
    pub name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SpaceProperties {
    pub space_name: ::std::string::String,
    pub partition_num: ::std::primitive::i32,
    pub replica_factor: ::std::primitive::i32,
    pub charset_name: ::std::string::String,
    pub collate_name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceItem {
    pub space_id: common::types::GraphSpaceID,
    pub properties: crate::types::SpaceProperties,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TagItem {
    pub tag_id: common::types::TagID,
    pub tag_name: ::std::string::String,
    pub version: common::types::SchemaVer,
    pub schema: common::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterSchemaItem {
    pub op: crate::types::AlterSchemaOp,
    pub schema: common::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgeItem {
    pub edge_type: common::types::EdgeType,
    pub edge_name: ::std::string::String,
    pub version: common::types::SchemaVer,
    pub schema: common::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostItem {
    pub hostAddr: common::types::HostAddr,
    pub status: crate::types::HostStatus,
    pub leader_parts: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<common::types::PartitionID>>,
    pub all_parts: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<common::types::PartitionID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecResp {
    pub code: crate::types::ErrorCode,
    pub id: crate::types::ID,
    pub leader: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSpaceReq {
    pub properties: crate::types::SpaceProperties,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSpaceReq {
    pub space_name: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AdminJobReq {
    pub op: crate::types::AdminJobOp,
    pub paras: ::std::vec::Vec<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct JobDesc {
    pub id: ::std::primitive::i32,
    pub cmd: ::std::string::String,
    pub paras: ::std::vec::Vec<::std::string::String>,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TaskDesc {
    pub task_id: ::std::primitive::i32,
    pub host: common::types::HostAddr,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    pub job_id: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResult {
    pub job_id: ::std::option::Option<::std::primitive::i32>,
    pub job_desc: ::std::option::Option<::std::vec::Vec<crate::types::JobDesc>>,
    pub task_desc: ::std::option::Option<::std::vec::Vec<crate::types::TaskDesc>>,
    pub recovered_job_num: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub result: crate::types::AdminJobResult,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSpacesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSpacesResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub spaces: ::std::vec::Vec<crate::types::IdName>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSpaceReq {
    pub space_name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSpaceResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::SpaceItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::string::String,
    pub schema: common::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::string::String,
    pub tag_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: common::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagsReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagsResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub tags: ::std::vec::Vec<crate::types::TagItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::string::String,
    pub version: common::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: common::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::string::String,
    pub schema: common::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::string::String,
    pub edge_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: common::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::string::String,
    pub version: common::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: common::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgesResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub edges: ::std::vec::Vec<crate::types::EdgeItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListHostsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListHostsResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub hosts: ::std::vec::Vec<crate::types::HostItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PartItem {
    pub part_id: common::types::PartitionID,
    pub leader: ::std::option::Option<common::types::HostAddr>,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    pub losts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListPartsReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_ids: ::std::vec::Vec<common::types::PartitionID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListPartsResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::vec::Vec<crate::types::PartItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetPartsAllocReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetPartsAllocResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::HostAddr>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MultiPutReq {
    pub segment: ::std::string::String,
    pub pairs: ::std::vec::Vec<common::types::Pair>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetReq {
    pub segment: ::std::string::String,
    pub key: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub value: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MultiGetReq {
    pub segment: ::std::string::String,
    pub keys: ::std::vec::Vec<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MultiGetResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub values: ::std::vec::Vec<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveReq {
    pub segment: ::std::string::String,
    pub key: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveRangeReq {
    pub segment: ::std::string::String,
    pub start: ::std::string::String,
    pub end: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScanReq {
    pub segment: ::std::string::String,
    pub start: ::std::string::String,
    pub end: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub values: ::std::vec::Vec<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub cluster_id: common::types::ClusterID,
    pub last_update_time_in_ms: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBReq {
    pub in_storaged: ::std::primitive::bool,
    pub host: common::types::HostAddr,
    pub cluster_id: common::types::ClusterID,
    pub leader_partIds: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    pub tag_name: ::std::string::String,
    pub fields: ::std::vec::Vec<::std::string::String>,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagIndexResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: common::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagIndexesResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<common::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    pub edge_name: ::std::string::String,
    pub fields: ::std::vec::Vec<::std::string::String>,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeIndexResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: common::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgeIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgeIndexesResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<common::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RebuildIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::string::String,
    pub is_offline: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateUserReq {
    pub account: ::std::string::String,
    pub encoded_pwd: ::std::string::String,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropUserReq {
    pub account: ::std::string::String,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AlterUserReq {
    pub account: ::std::string::String,
    pub encoded_pwd: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GrantRoleReq {
    pub role_item: common::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RevokeRoleReq {
    pub role_item: common::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListUsersReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListUsersResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub users: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListRolesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetUserRolesReq {
    pub account: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListRolesResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub roles: ::std::vec::Vec<common::types::RoleItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ChangePasswordReq {
    pub account: ::std::string::String,
    pub new_encoded_pwd: ::std::string::String,
    pub old_encoded_pwd: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BalanceReq {
    pub space_id: ::std::option::Option<common::types::GraphSpaceID>,
    pub id: ::std::option::Option<::std::primitive::i64>,
    pub host_del: ::std::option::Option<::std::vec::Vec<common::types::HostAddr>>,
    pub stop: ::std::option::Option<::std::primitive::bool>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BalanceTask {
    pub id: ::std::string::String,
    pub result: crate::types::TaskResult,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BalanceResp {
    pub code: crate::types::ErrorCode,
    pub id: ::std::primitive::i64,
    pub leader: common::types::HostAddr,
    pub tasks: ::std::vec::Vec<crate::types::BalanceTask>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LeaderBalanceReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ConfigItem {
    pub module: crate::types::ConfigModule,
    pub name: ::std::string::String,
    pub r#type: crate::types::ConfigType,
    pub mode: crate::types::ConfigMode,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RegConfigReq {
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigReq {
    pub item: crate::types::ConfigItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SetConfigReq {
    pub item: crate::types::ConfigItem,
    pub force: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListConfigsReq {
    pub space: ::std::string::String,
    pub module: crate::types::ConfigModule,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListConfigsResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateSnapshotReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSnapshotReq {
    pub name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSnapshotsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Snapshot {
    pub name: ::std::string::String,
    pub status: crate::types::SnapshotStatus,
    pub hosts: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSnapshotsResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub snapshots: ::std::vec::Vec<crate::types::Snapshot>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListIndexStatusReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexStatus {
    pub name: ::std::string::String,
    pub status: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListIndexStatusResp {
    pub code: crate::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub statuses: ::std::vec::Vec<crate::types::IndexStatus>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ErrorCode(pub ::std::primitive::i32);

impl ErrorCode {
    pub const SUCCEEDED: Self = ErrorCode(0i32);
    pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
    pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
    pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
    pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
    pub const E_NO_HOSTS: Self = ErrorCode(-21i32);
    pub const E_EXISTED: Self = ErrorCode(-22i32);
    pub const E_NOT_FOUND: Self = ErrorCode(-23i32);
    pub const E_INVALID_HOST: Self = ErrorCode(-24i32);
    pub const E_UNSUPPORTED: Self = ErrorCode(-25i32);
    pub const E_NOT_DROP: Self = ErrorCode(-26i32);
    pub const E_BALANCER_RUNNING: Self = ErrorCode(-27i32);
    pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-28i32);
    pub const E_CONFLICT: Self = ErrorCode(-29i32);
    pub const E_INVALID_PARM: Self = ErrorCode(-30i32);
    pub const E_WRONGCLUSTER: Self = ErrorCode(-31i32);
    pub const E_STORE_FAILURE: Self = ErrorCode(-32i32);
    pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-33i32);
    pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-34i32);
    pub const E_BALANCED: Self = ErrorCode(-35i32);
    pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-36i32);
    pub const E_NO_VALID_HOST: Self = ErrorCode(-37i32);
    pub const E_CORRUPTTED_BALANCE_PLAN: Self = ErrorCode(-38i32);
    pub const E_INVALID_PASSWORD: Self = ErrorCode(-41i32);
    pub const E_IMPROPER_ROLE: Self = ErrorCode(-42i32);
    pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-43i32);
    pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-44i32);
    pub const E_INVALID_CHARSET: Self = ErrorCode(-45i32);
    pub const E_INVALID_COLLATE: Self = ErrorCode(-46i32);
    pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-47i32);
    pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-51i32);
    pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-52i32);
    pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-53i32);
    pub const E_INDEX_WITH_TTL: Self = ErrorCode(-54i32);
    pub const E_UNKNOWN: Self = ErrorCode(-99i32);
}

impl ::fbthrift::ThriftEnum for ErrorCode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::E_DISCONNECTED, "E_DISCONNECTED"),
            (Self::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
            (Self::E_RPC_FAILURE, "E_RPC_FAILURE"),
            (Self::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
            (Self::E_NO_HOSTS, "E_NO_HOSTS"),
            (Self::E_EXISTED, "E_EXISTED"),
            (Self::E_NOT_FOUND, "E_NOT_FOUND"),
            (Self::E_INVALID_HOST, "E_INVALID_HOST"),
            (Self::E_UNSUPPORTED, "E_UNSUPPORTED"),
            (Self::E_NOT_DROP, "E_NOT_DROP"),
            (Self::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
            (Self::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
            (Self::E_CONFLICT, "E_CONFLICT"),
            (Self::E_INVALID_PARM, "E_INVALID_PARM"),
            (Self::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
            (Self::E_STORE_FAILURE, "E_STORE_FAILURE"),
            (Self::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
            (Self::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
            (Self::E_BALANCED, "E_BALANCED"),
            (Self::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
            (Self::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
            (Self::E_CORRUPTTED_BALANCE_PLAN, "E_CORRUPTTED_BALANCE_PLAN"),
            (Self::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
            (Self::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
            (Self::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
            (Self::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
            (Self::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
            (Self::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
            (Self::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
            (Self::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
            (Self::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
            (Self::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
            (Self::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
            (Self::E_UNKNOWN, "E_UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "E_DISCONNECTED",
            "E_FAIL_TO_CONNECT",
            "E_RPC_FAILURE",
            "E_LEADER_CHANGED",
            "E_NO_HOSTS",
            "E_EXISTED",
            "E_NOT_FOUND",
            "E_INVALID_HOST",
            "E_UNSUPPORTED",
            "E_NOT_DROP",
            "E_BALANCER_RUNNING",
            "E_CONFIG_IMMUTABLE",
            "E_CONFLICT",
            "E_INVALID_PARM",
            "E_WRONGCLUSTER",
            "E_STORE_FAILURE",
            "E_STORE_SEGMENT_ILLEGAL",
            "E_BAD_BALANCE_PLAN",
            "E_BALANCED",
            "E_NO_RUNNING_BALANCE_PLAN",
            "E_NO_VALID_HOST",
            "E_CORRUPTTED_BALANCE_PLAN",
            "E_INVALID_PASSWORD",
            "E_IMPROPER_ROLE",
            "E_INVALID_PARTITION_NUM",
            "E_INVALID_REPLICA_FACTOR",
            "E_INVALID_CHARSET",
            "E_INVALID_COLLATE",
            "E_CHARSET_COLLATE_NOT_MATCH",
            "E_SNAPSHOT_FAILURE",
            "E_BLOCK_WRITE_FAILURE",
            "E_REBUILD_INDEX_FAILURE",
            "E_INDEX_WITH_TTL",
            "E_UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::E_DISCONNECTED,
            Self::E_FAIL_TO_CONNECT,
            Self::E_RPC_FAILURE,
            Self::E_LEADER_CHANGED,
            Self::E_NO_HOSTS,
            Self::E_EXISTED,
            Self::E_NOT_FOUND,
            Self::E_INVALID_HOST,
            Self::E_UNSUPPORTED,
            Self::E_NOT_DROP,
            Self::E_BALANCER_RUNNING,
            Self::E_CONFIG_IMMUTABLE,
            Self::E_CONFLICT,
            Self::E_INVALID_PARM,
            Self::E_WRONGCLUSTER,
            Self::E_STORE_FAILURE,
            Self::E_STORE_SEGMENT_ILLEGAL,
            Self::E_BAD_BALANCE_PLAN,
            Self::E_BALANCED,
            Self::E_NO_RUNNING_BALANCE_PLAN,
            Self::E_NO_VALID_HOST,
            Self::E_CORRUPTTED_BALANCE_PLAN,
            Self::E_INVALID_PASSWORD,
            Self::E_IMPROPER_ROLE,
            Self::E_INVALID_PARTITION_NUM,
            Self::E_INVALID_REPLICA_FACTOR,
            Self::E_INVALID_CHARSET,
            Self::E_INVALID_COLLATE,
            Self::E_CHARSET_COLLATE_NOT_MATCH,
            Self::E_SNAPSHOT_FAILURE,
            Self::E_BLOCK_WRITE_FAILURE,
            Self::E_REBUILD_INDEX_FAILURE,
            Self::E_INDEX_WITH_TTL,
            Self::E_UNKNOWN,
        ]
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_UNKNOWN", -99),
            ("E_INDEX_WITH_TTL", -54),
            ("E_REBUILD_INDEX_FAILURE", -53),
            ("E_BLOCK_WRITE_FAILURE", -52),
            ("E_SNAPSHOT_FAILURE", -51),
            ("E_CHARSET_COLLATE_NOT_MATCH", -47),
            ("E_INVALID_COLLATE", -46),
            ("E_INVALID_CHARSET", -45),
            ("E_INVALID_REPLICA_FACTOR", -44),
            ("E_INVALID_PARTITION_NUM", -43),
            ("E_IMPROPER_ROLE", -42),
            ("E_INVALID_PASSWORD", -41),
            ("E_CORRUPTTED_BALANCE_PLAN", -38),
            ("E_NO_VALID_HOST", -37),
            ("E_NO_RUNNING_BALANCE_PLAN", -36),
            ("E_BALANCED", -35),
            ("E_BAD_BALANCE_PLAN", -34),
            ("E_STORE_SEGMENT_ILLEGAL", -33),
            ("E_STORE_FAILURE", -32),
            ("E_WRONGCLUSTER", -31),
            ("E_INVALID_PARM", -30),
            ("E_CONFLICT", -29),
            ("E_CONFIG_IMMUTABLE", -28),
            ("E_BALANCER_RUNNING", -27),
            ("E_NOT_DROP", -26),
            ("E_UNSUPPORTED", -25),
            ("E_INVALID_HOST", -24),
            ("E_NOT_FOUND", -23),
            ("E_EXISTED", -22),
            ("E_NO_HOSTS", -21),
            ("E_LEADER_CHANGED", -11),
            ("E_RPC_FAILURE", -3),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_DISCONNECTED", -1),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ErrorCode::{}", self)
    }
}

impl ::std::str::FromStr for ErrorCode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_BAD_BALANCE_PLAN", -34),
            ("E_BALANCED", -35),
            ("E_BALANCER_RUNNING", -27),
            ("E_BLOCK_WRITE_FAILURE", -52),
            ("E_CHARSET_COLLATE_NOT_MATCH", -47),
            ("E_CONFIG_IMMUTABLE", -28),
            ("E_CONFLICT", -29),
            ("E_CORRUPTTED_BALANCE_PLAN", -38),
            ("E_DISCONNECTED", -1),
            ("E_EXISTED", -22),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_IMPROPER_ROLE", -42),
            ("E_INDEX_WITH_TTL", -54),
            ("E_INVALID_CHARSET", -45),
            ("E_INVALID_COLLATE", -46),
            ("E_INVALID_HOST", -24),
            ("E_INVALID_PARM", -30),
            ("E_INVALID_PARTITION_NUM", -43),
            ("E_INVALID_PASSWORD", -41),
            ("E_INVALID_REPLICA_FACTOR", -44),
            ("E_LEADER_CHANGED", -11),
            ("E_NOT_DROP", -26),
            ("E_NOT_FOUND", -23),
            ("E_NO_HOSTS", -21),
            ("E_NO_RUNNING_BALANCE_PLAN", -36),
            ("E_NO_VALID_HOST", -37),
            ("E_REBUILD_INDEX_FAILURE", -53),
            ("E_RPC_FAILURE", -3),
            ("E_SNAPSHOT_FAILURE", -51),
            ("E_STORE_FAILURE", -32),
            ("E_STORE_SEGMENT_ILLEGAL", -33),
            ("E_UNKNOWN", -99),
            ("E_UNSUPPORTED", -25),
            ("E_WRONGCLUSTER", -31),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(Self)
    }
}

impl ::fbthrift::GetTType for ErrorCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AlterSchemaOp(pub ::std::primitive::i32);

impl AlterSchemaOp {
    pub const ADD: Self = AlterSchemaOp(1i32);
    pub const CHANGE: Self = AlterSchemaOp(2i32);
    pub const DROP: Self = AlterSchemaOp(3i32);
    pub const UNKNOWN: Self = AlterSchemaOp(4i32);
}

impl ::fbthrift::ThriftEnum for AlterSchemaOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::CHANGE, "CHANGE"),
            (Self::DROP, "DROP"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "CHANGE",
            "DROP",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::CHANGE,
            Self::DROP,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for AlterSchemaOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AlterSchemaOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AlterSchemaOp::{}", self)
    }
}

impl ::std::str::FromStr for AlterSchemaOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSchemaOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AlterSchemaOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct HostStatus(pub ::std::primitive::i32);

impl HostStatus {
    pub const ONLINE: Self = HostStatus(0i32);
    pub const OFFLINE: Self = HostStatus(1i32);
    pub const UNKNOWN: Self = HostStatus(2i32);
}

impl ::fbthrift::ThriftEnum for HostStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ONLINE, "ONLINE"),
            (Self::OFFLINE, "OFFLINE"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ONLINE",
            "OFFLINE",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ONLINE,
            Self::OFFLINE,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for HostStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for HostStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ONLINE", 0),
            ("OFFLINE", 1),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "HostStatus::{}", self)
    }
}

impl ::std::str::FromStr for HostStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("OFFLINE", 1),
            ("ONLINE", 0),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for HostStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SnapshotStatus(pub ::std::primitive::i32);

impl SnapshotStatus {
    pub const VALID: Self = SnapshotStatus(0i32);
    pub const INVALID: Self = SnapshotStatus(1i32);
}

impl ::fbthrift::ThriftEnum for SnapshotStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::VALID, "VALID"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "VALID",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::VALID,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for SnapshotStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for SnapshotStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("VALID", 0),
            ("INVALID", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "SnapshotStatus::{}", self)
    }
}

impl ::std::str::FromStr for SnapshotStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("INVALID", 1),
            ("VALID", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "SnapshotStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for SnapshotStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AdminJobOp(pub ::std::primitive::i32);

impl AdminJobOp {
    pub const ADD: Self = AdminJobOp(1i32);
    pub const SHOW_All: Self = AdminJobOp(2i32);
    pub const SHOW: Self = AdminJobOp(3i32);
    pub const STOP: Self = AdminJobOp(4i32);
    pub const RECOVER: Self = AdminJobOp(5i32);
    pub const INVALID: Self = AdminJobOp(255i32);
}

impl ::fbthrift::ThriftEnum for AdminJobOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::SHOW_All, "SHOW_All"),
            (Self::SHOW, "SHOW"),
            (Self::STOP, "STOP"),
            (Self::RECOVER, "RECOVER"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "SHOW_All",
            "SHOW",
            "STOP",
            "RECOVER",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::SHOW_All,
            Self::SHOW,
            Self::STOP,
            Self::RECOVER,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for AdminJobOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AdminJobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AdminJobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AdminJobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AdminJobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AdminJobOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AdminJobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("SHOW_All", 2),
            ("SHOW", 3),
            ("STOP", 4),
            ("RECOVER", 5),
            ("INVALID", 255),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AdminJobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AdminJobOp::{}", self)
    }
}

impl ::std::str::FromStr for AdminJobOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("INVALID", 255),
            ("RECOVER", 5),
            ("SHOW", 3),
            ("SHOW_All", 2),
            ("STOP", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminJobOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AdminJobOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AdminJobOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AdminJobOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct JobStatus(pub ::std::primitive::i32);

impl JobStatus {
    pub const QUEUE: Self = JobStatus(1i32);
    pub const RUNNING: Self = JobStatus(2i32);
    pub const FINISHED: Self = JobStatus(3i32);
    pub const FAILED: Self = JobStatus(4i32);
    pub const STOPPED: Self = JobStatus(5i32);
    pub const INVALID: Self = JobStatus(255i32);
}

impl ::fbthrift::ThriftEnum for JobStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::QUEUE, "QUEUE"),
            (Self::RUNNING, "RUNNING"),
            (Self::FINISHED, "FINISHED"),
            (Self::FAILED, "FAILED"),
            (Self::STOPPED, "STOPPED"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "QUEUE",
            "RUNNING",
            "FINISHED",
            "FAILED",
            "STOPPED",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::QUEUE,
            Self::RUNNING,
            Self::FINISHED,
            Self::FAILED,
            Self::STOPPED,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for JobStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for JobStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("FINISHED", 3),
            ("FAILED", 4),
            ("STOPPED", 5),
            ("INVALID", 255),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "JobStatus::{}", self)
    }
}

impl ::std::str::FromStr for JobStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 4),
            ("FINISHED", 3),
            ("INVALID", 255),
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("STOPPED", 5),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for JobStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct TaskResult(pub ::std::primitive::i32);

impl TaskResult {
    pub const SUCCEEDED: Self = TaskResult(0i32);
    pub const FAILED: Self = TaskResult(1i32);
    pub const IN_PROGRESS: Self = TaskResult(2i32);
    pub const INVALID: Self = TaskResult(3i32);
}

impl ::fbthrift::ThriftEnum for TaskResult {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::FAILED, "FAILED"),
            (Self::IN_PROGRESS, "IN_PROGRESS"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "FAILED",
            "IN_PROGRESS",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::FAILED,
            Self::IN_PROGRESS,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for TaskResult {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for TaskResult {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SUCCEEDED", 0),
            ("FAILED", 1),
            ("IN_PROGRESS", 2),
            ("INVALID", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "TaskResult::{}", self)
    }
}

impl ::std::str::FromStr for TaskResult {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 1),
            ("INVALID", 3),
            ("IN_PROGRESS", 2),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TaskResult").map(Self)
    }
}

impl ::fbthrift::GetTType for TaskResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigModule(pub ::std::primitive::i32);

impl ConfigModule {
    pub const UNKNOWN: Self = ConfigModule(0i32);
    pub const ALL: Self = ConfigModule(1i32);
    pub const GRAPH: Self = ConfigModule(2i32);
    pub const META: Self = ConfigModule(3i32);
    pub const STORAGE: Self = ConfigModule(4i32);
}

impl ::fbthrift::ThriftEnum for ConfigModule {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::ALL, "ALL"),
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "ALL",
            "GRAPH",
            "META",
            "STORAGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::ALL,
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
        ]
    }
}

impl ::std::default::Default for ConfigModule {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigModule {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigModule::{}", self)
    }
}

impl ::std::str::FromStr for ConfigModule {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
            ("UNKNOWN", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigModule").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigModule {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigType(pub ::std::primitive::i32);

impl ConfigType {
    pub const INT64: Self = ConfigType(0i32);
    pub const DOUBLE: Self = ConfigType(1i32);
    pub const BOOL: Self = ConfigType(2i32);
    pub const STRING: Self = ConfigType(3i32);
    pub const NESTED: Self = ConfigType(4i32);
}

impl ::fbthrift::ThriftEnum for ConfigType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::INT64, "INT64"),
            (Self::DOUBLE, "DOUBLE"),
            (Self::BOOL, "BOOL"),
            (Self::STRING, "STRING"),
            (Self::NESTED, "NESTED"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "INT64",
            "DOUBLE",
            "BOOL",
            "STRING",
            "NESTED",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::INT64,
            Self::DOUBLE,
            Self::BOOL,
            Self::STRING,
            Self::NESTED,
        ]
    }
}

impl ::std::default::Default for ConfigType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("INT64", 0),
            ("DOUBLE", 1),
            ("BOOL", 2),
            ("STRING", 3),
            ("NESTED", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigType::{}", self)
    }
}

impl ::std::str::FromStr for ConfigType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BOOL", 2),
            ("DOUBLE", 1),
            ("INT64", 0),
            ("NESTED", 4),
            ("STRING", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigType").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigMode(pub ::std::primitive::i32);

impl ConfigMode {
    pub const IMMUTABLE: Self = ConfigMode(0i32);
    pub const REBOOT: Self = ConfigMode(1i32);
    pub const MUTABLE: Self = ConfigMode(2i32);
    pub const IGNORED: Self = ConfigMode(3i32);
}

impl ::fbthrift::ThriftEnum for ConfigMode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::IMMUTABLE, "IMMUTABLE"),
            (Self::REBOOT, "REBOOT"),
            (Self::MUTABLE, "MUTABLE"),
            (Self::IGNORED, "IGNORED"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "IMMUTABLE",
            "REBOOT",
            "MUTABLE",
            "IGNORED",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::IMMUTABLE,
            Self::REBOOT,
            Self::MUTABLE,
            Self::IGNORED,
        ]
    }
}

impl ::std::default::Default for ConfigMode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigMode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IMMUTABLE", 0),
            ("REBOOT", 1),
            ("MUTABLE", 2),
            ("IGNORED", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigMode::{}", self)
    }
}

impl ::std::str::FromStr for ConfigMode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IGNORED", 3),
            ("IMMUTABLE", 0),
            ("MUTABLE", 2),
            ("REBOOT", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigMode").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigMode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}


impl ::std::default::Default for ID {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for ID {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for ID
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ID");
        match self {
            Self::space_id(inner) => {
                p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::index_id(inner) => {
                p.write_field_begin("index_id", ::fbthrift::TType::I32, 4);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::cluster_id(inner) => {
                p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 5);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for ID
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 2),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::space_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 4, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::index_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I64, 5, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::cluster_id(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "ID",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IdName {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IdName {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IdName")
            .field("id", &self.id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IdName {}
unsafe impl ::std::marker::Sync for self::IdName {}

impl ::fbthrift::GetTType for self::IdName {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IdName");
        p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceProperties {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            partition_num: ::std::default::Default::default(),
            replica_factor: ::std::default::Default::default(),
            charset_name: ::std::default::Default::default(),
            collate_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceProperties {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceProperties")
            .field("space_name", &self.space_name)
            .field("partition_num", &self.partition_num)
            .field("replica_factor", &self.replica_factor)
            .field("charset_name", &self.charset_name)
            .field("collate_name", &self.collate_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceProperties {}
unsafe impl ::std::marker::Sync for self::SpaceProperties {}

impl ::fbthrift::GetTType for self::SpaceProperties {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceProperties
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceProperties");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("partition_num", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.partition_num, p);
        p.write_field_end();
        p.write_field_begin("replica_factor", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.replica_factor, p);
        p.write_field_end();
        p.write_field_begin("charset_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.charset_name, p);
        p.write_field_end();
        p.write_field_begin("collate_name", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.collate_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceProperties
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("charset_name", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("collate_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("partition_num", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("replica_factor", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_partition_num = ::std::option::Option::None;
        let mut field_replica_factor = ::std::option::Option::None;
        let mut field_charset_name = ::std::option::Option::None;
        let mut field_collate_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_partition_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_replica_factor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_charset_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_collate_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            partition_num: field_partition_num.unwrap_or_default(),
            replica_factor: field_replica_factor.unwrap_or_default(),
            charset_name: field_charset_name.unwrap_or_default(),
            collate_name: field_collate_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceItem {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            properties: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceItem")
            .field("space_id", &self.space_id)
            .field("properties", &self.properties)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceItem {}
unsafe impl ::std::marker::Sync for self::SpaceItem {}

impl ::fbthrift::GetTType for self::SpaceItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceItem");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_properties = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            properties: field_properties.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TagItem {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TagItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TagItem")
            .field("tag_id", &self.tag_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TagItem {}
unsafe impl ::std::marker::Sync for self::TagItem {}

impl ::fbthrift::GetTType for self::TagItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TagItem");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterSchemaItem {
    fn default() -> Self {
        Self {
            op: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterSchemaItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterSchemaItem")
            .field("op", &self.op)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterSchemaItem {}
unsafe impl ::std::marker::Sync for self::AlterSchemaItem {}

impl ::fbthrift::GetTType for self::AlterSchemaItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterSchemaItem");
        p.write_field_begin("op", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_op = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            op: field_op.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeItem {
    fn default() -> Self {
        Self {
            edge_type: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeItem")
            .field("edge_type", &self.edge_type)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeItem {}
unsafe impl ::std::marker::Sync for self::EdgeItem {}

impl ::fbthrift::GetTType for self::EdgeItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeItem");
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            edge_type: field_edge_type.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostItem {
    fn default() -> Self {
        Self {
            hostAddr: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            leader_parts: ::std::default::Default::default(),
            all_parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostItem")
            .field("hostAddr", &self.hostAddr)
            .field("status", &self.status)
            .field("leader_parts", &self.leader_parts)
            .field("all_parts", &self.all_parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostItem {}
unsafe impl ::std::marker::Sync for self::HostItem {}

impl ::fbthrift::GetTType for self::HostItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostItem");
        p.write_field_begin("hostAddr", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.hostAddr, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.leader_parts, p);
        p.write_field_end();
        p.write_field_begin("all_parts", ::fbthrift::TType::Map, 4);
        ::fbthrift::Serialize::write(&self.all_parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_parts", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("hostAddr", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_hostAddr = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_leader_parts = ::std::option::Option::None;
        let mut field_all_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_hostAddr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_all_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hostAddr: field_hostAddr.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            leader_parts: field_leader_parts.unwrap_or_default(),
            all_parts: field_all_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecResp")
            .field("code", &self.code)
            .field("id", &self.id)
            .field("leader", &self.leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecResp {}
unsafe impl ::std::marker::Sync for self::ExecResp {}

impl ::fbthrift::GetTType for self::ExecResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSpaceReq {
    fn default() -> Self {
        Self {
            properties: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSpaceReq")
            .field("properties", &self.properties)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSpaceReq {}
unsafe impl ::std::marker::Sync for self::CreateSpaceReq {}

impl ::fbthrift::GetTType for self::CreateSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSpaceReq");
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_properties = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            properties: field_properties.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSpaceReq")
            .field("space_name", &self.space_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSpaceReq {}
unsafe impl ::std::marker::Sync for self::DropSpaceReq {}

impl ::fbthrift::GetTType for self::DropSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobReq {
    fn default() -> Self {
        Self {
            op: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobReq")
            .field("op", &self.op)
            .field("paras", &self.paras)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobReq {}
unsafe impl ::std::marker::Sync for self::AdminJobReq {}

impl ::fbthrift::GetTType for self::AdminJobReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobReq");
        p.write_field_begin("op", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 2),
        ];
        let mut field_op = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            op: field_op.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::JobDesc {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            cmd: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::JobDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("JobDesc")
            .field("id", &self.id)
            .field("cmd", &self.cmd)
            .field("paras", &self.paras)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::JobDesc {}
unsafe impl ::std::marker::Sync for self::JobDesc {}

impl ::fbthrift::GetTType for self::JobDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("JobDesc");
        p.write_field_begin("id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("cmd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.cmd, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cmd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 6),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_cmd = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            cmd: field_cmd.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TaskDesc {
    fn default() -> Self {
        Self {
            task_id: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TaskDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TaskDesc")
            .field("task_id", &self.task_id)
            .field("host", &self.host)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .field("job_id", &self.job_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TaskDesc {}
unsafe impl ::std::marker::Sync for self::TaskDesc {}

impl ::fbthrift::GetTType for self::TaskDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TaskDesc");
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 6),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_task_id = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            task_id: field_task_id.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResult {
    fn default() -> Self {
        Self {
            job_id: ::std::option::Option::None,
            job_desc: ::std::option::Option::None,
            task_desc: ::std::option::Option::None,
            recovered_job_num: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResult {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResult")
            .field("job_id", &self.job_id)
            .field("job_desc", &self.job_desc)
            .field("task_desc", &self.task_desc)
            .field("recovered_job_num", &self.recovered_job_num)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResult {}
unsafe impl ::std::marker::Sync for self::AdminJobResult {}

impl ::fbthrift::GetTType for self::AdminJobResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResult");
        if let ::std::option::Option::Some(some) = &self.job_id {
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.job_desc {
            p.write_field_begin("job_desc", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.task_desc {
            p.write_field_begin("task_desc", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.recovered_job_num {
            p.write_field_begin("recovered_job_num", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("job_desc", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("recovered_job_num", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("task_desc", ::fbthrift::TType::List, 3),
        ];
        let mut field_job_id = ::std::option::Option::None;
        let mut field_job_desc = ::std::option::Option::None;
        let mut field_task_desc = ::std::option::Option::None;
        let mut field_recovered_job_num = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_job_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_task_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_recovered_job_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            job_id: field_job_id,
            job_desc: field_job_desc,
            task_desc: field_task_desc,
            recovered_job_num: field_recovered_job_num,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResp {}
unsafe impl ::std::marker::Sync for self::AdminJobResp {}

impl ::fbthrift::GetTType for self::AdminJobResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesReq {}
unsafe impl ::std::marker::Sync for self::ListSpacesReq {}

impl ::fbthrift::GetTType for self::ListSpacesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            spaces: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("spaces", &self.spaces)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesResp {}
unsafe impl ::std::marker::Sync for self::ListSpacesResp {}

impl ::fbthrift::GetTType for self::ListSpacesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("spaces", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.spaces, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_spaces = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            spaces: field_spaces.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceReq")
            .field("space_name", &self.space_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceReq {}
unsafe impl ::std::marker::Sync for self::GetSpaceReq {}

impl ::fbthrift::GetTType for self::GetSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceResp {}
unsafe impl ::std::marker::Sync for self::GetSpaceResp {}

impl ::fbthrift::GetTType for self::GetSpaceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagReq {}
unsafe impl ::std::marker::Sync for self::CreateTagReq {}

impl ::fbthrift::GetTType for self::CreateTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            tag_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("tag_items", &self.tag_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterTagReq {}
unsafe impl ::std::marker::Sync for self::AlterTagReq {}

impl ::fbthrift::GetTType for self::AlterTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("tag_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tag_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_tag_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tag_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            tag_items: field_tag_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagReq {}
unsafe impl ::std::marker::Sync for self::DropTagReq {}

impl ::fbthrift::GetTType for self::DropTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsReq {}
unsafe impl ::std::marker::Sync for self::ListTagsReq {}

impl ::fbthrift::GetTType for self::ListTagsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsResp {}
unsafe impl ::std::marker::Sync for self::ListTagsResp {}

impl ::fbthrift::GetTType for self::ListTagsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagReq {}
unsafe impl ::std::marker::Sync for self::GetTagReq {}

impl ::fbthrift::GetTType for self::GetTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagResp {}
unsafe impl ::std::marker::Sync for self::GetTagResp {}

impl ::fbthrift::GetTType for self::GetTagResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeReq {}

impl ::fbthrift::GetTType for self::CreateEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            edge_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("edge_items", &self.edge_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterEdgeReq {}
unsafe impl ::std::marker::Sync for self::AlterEdgeReq {}

impl ::fbthrift::GetTType for self::AlterEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("edge_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_edge_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            edge_items: field_edge_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeReq {}

impl ::fbthrift::GetTType for self::GetEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeResp {}

impl ::fbthrift::GetTType for self::GetEdgeResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeReq {}

impl ::fbthrift::GetTType for self::DropEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgesReq {}

impl ::fbthrift::GetTType for self::ListEdgesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("edges", &self.edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgesResp {}

impl ::fbthrift::GetTType for self::ListEdgesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsReq {}
unsafe impl ::std::marker::Sync for self::ListHostsReq {}

impl ::fbthrift::GetTType for self::ListHostsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsResp {}
unsafe impl ::std::marker::Sync for self::ListHostsResp {}

impl ::fbthrift::GetTType for self::ListHostsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartItem {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            leader: ::std::option::Option::None,
            peers: ::std::default::Default::default(),
            losts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartItem")
            .field("part_id", &self.part_id)
            .field("leader", &self.leader)
            .field("peers", &self.peers)
            .field("losts", &self.losts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartItem {}
unsafe impl ::std::marker::Sync for self::PartItem {}

impl ::fbthrift::GetTType for self::PartItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartItem");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader {
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("peers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_begin("losts", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.losts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("losts", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let mut field_losts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_losts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            leader: field_leader,
            peers: field_peers.unwrap_or_default(),
            losts: field_losts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_ids: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsReq")
            .field("space_id", &self.space_id)
            .field("part_ids", &self.part_ids)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsReq {}
unsafe impl ::std::marker::Sync for self::ListPartsReq {}

impl ::fbthrift::GetTType for self::ListPartsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_ids", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.part_ids, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_ids", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_ids = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_part_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_ids: field_part_ids.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsResp {}
unsafe impl ::std::marker::Sync for self::ListPartsResp {}

impl ::fbthrift::GetTType for self::ListPartsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocReq {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocReq {}

impl ::fbthrift::GetTType for self::GetPartsAllocReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocResp {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocResp {}

impl ::fbthrift::GetTType for self::GetPartsAllocResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiPutReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            pairs: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiPutReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiPutReq")
            .field("segment", &self.segment)
            .field("pairs", &self.pairs)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiPutReq {}
unsafe impl ::std::marker::Sync for self::MultiPutReq {}

impl ::fbthrift::GetTType for self::MultiPutReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiPutReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiPutReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("pairs", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.pairs, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiPutReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("pairs", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_pairs = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_pairs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            pairs: field_pairs.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            key: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetReq")
            .field("segment", &self.segment)
            .field("key", &self.key)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetReq {}
unsafe impl ::std::marker::Sync for self::GetReq {}

impl ::fbthrift::GetTType for self::GetReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("key", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_key = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            key: field_key.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetResp {}
unsafe impl ::std::marker::Sync for self::GetResp {}

impl ::fbthrift::GetTType for self::GetResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiGetReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            keys: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiGetReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiGetReq")
            .field("segment", &self.segment)
            .field("keys", &self.keys)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiGetReq {}
unsafe impl ::std::marker::Sync for self::MultiGetReq {}

impl ::fbthrift::GetTType for self::MultiGetReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiGetReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiGetReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("keys", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.keys, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiGetReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("keys", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_keys = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            keys: field_keys.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiGetResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiGetResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiGetResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiGetResp {}
unsafe impl ::std::marker::Sync for self::MultiGetResp {}

impl ::fbthrift::GetTType for self::MultiGetResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiGetResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiGetResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("values", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiGetResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            key: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveReq")
            .field("segment", &self.segment)
            .field("key", &self.key)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveReq {}
unsafe impl ::std::marker::Sync for self::RemoveReq {}

impl ::fbthrift::GetTType for self::RemoveReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("key", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_key = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            key: field_key.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveRangeReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            start: ::std::default::Default::default(),
            end: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveRangeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveRangeReq")
            .field("segment", &self.segment)
            .field("start", &self.start)
            .field("end", &self.end)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveRangeReq {}
unsafe impl ::std::marker::Sync for self::RemoveRangeReq {}

impl ::fbthrift::GetTType for self::RemoveRangeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveRangeReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("start", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.start, p);
        p.write_field_end();
        p.write_field_begin("end", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.end, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_start = ::std::option::Option::None;
        let mut field_end = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            start: field_start.unwrap_or_default(),
            end: field_end.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            start: ::std::default::Default::default(),
            end: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanReq")
            .field("segment", &self.segment)
            .field("start", &self.start)
            .field("end", &self.end)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanReq {}
unsafe impl ::std::marker::Sync for self::ScanReq {}

impl ::fbthrift::GetTType for self::ScanReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("start", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.start, p);
        p.write_field_end();
        p.write_field_begin("end", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.end, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_start = ::std::option::Option::None;
        let mut field_end = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            start: field_start.unwrap_or_default(),
            end: field_end.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanResp {}
unsafe impl ::std::marker::Sync for self::ScanResp {}

impl ::fbthrift::GetTType for self::ScanResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("values", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            last_update_time_in_ms: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("cluster_id", &self.cluster_id)
            .field("last_update_time_in_ms", &self.last_update_time_in_ms)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBResp {}
unsafe impl ::std::marker::Sync for self::HBResp {}

impl ::fbthrift::GetTType for self::HBResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        p.write_field_begin("last_update_time_in_ms", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.last_update_time_in_ms, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_update_time_in_ms", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_last_update_time_in_ms = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_last_update_time_in_ms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            last_update_time_in_ms: field_last_update_time_in_ms.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBReq {
    fn default() -> Self {
        Self {
            in_storaged: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            leader_partIds: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBReq")
            .field("in_storaged", &self.in_storaged)
            .field("host", &self.host)
            .field("cluster_id", &self.cluster_id)
            .field("leader_partIds", &self.leader_partIds)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBReq {}
unsafe impl ::std::marker::Sync for self::HBReq {}

impl ::fbthrift::GetTType for self::HBReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBReq");
        p.write_field_begin("in_storaged", ::fbthrift::TType::Bool, 1);
        ::fbthrift::Serialize::write(&self.in_storaged, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader_partIds {
            p.write_field_begin("leader_partIds", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("in_storaged", ::fbthrift::TType::Bool, 1),
            ::fbthrift::Field::new("leader_partIds", ::fbthrift::TType::Map, 4),
        ];
        let mut field_in_storaged = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_leader_partIds = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 1) => field_in_storaged = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_leader_partIds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            in_storaged: field_in_storaged.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            leader_partIds: field_leader_partIds,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("tag_name", &self.tag_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateTagIndexReq {}

impl ::fbthrift::GetTType for self::CreateTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagIndexReq {}
unsafe impl ::std::marker::Sync for self::DropTagIndexReq {}

impl ::fbthrift::GetTType for self::DropTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexReq {}
unsafe impl ::std::marker::Sync for self::GetTagIndexReq {}

impl ::fbthrift::GetTType for self::GetTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexResp {}
unsafe impl ::std::marker::Sync for self::GetTagIndexResp {}

impl ::fbthrift::GetTType for self::GetTagIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesReq {}

impl ::fbthrift::GetTType for self::ListTagIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesResp {}

impl ::fbthrift::GetTType for self::ListTagIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("edge_name", &self.edge_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeIndexReq {}

impl ::fbthrift::GetTType for self::CreateEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeIndexReq {}

impl ::fbthrift::GetTType for self::DropEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexReq {}

impl ::fbthrift::GetTType for self::GetEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexResp {}

impl ::fbthrift::GetTType for self::GetEdgeIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesReq {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesResp {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RebuildIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            is_offline: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RebuildIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RebuildIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("is_offline", &self.is_offline)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RebuildIndexReq {}
unsafe impl ::std::marker::Sync for self::RebuildIndexReq {}

impl ::fbthrift::GetTType for self::RebuildIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RebuildIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("is_offline", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.is_offline, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("is_offline", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_is_offline = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_is_offline = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            is_offline: field_is_offline.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateUserReq {}
unsafe impl ::std::marker::Sync for self::CreateUserReq {}

impl ::fbthrift::GetTType for self::CreateUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropUserReq")
            .field("account", &self.account)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropUserReq {}
unsafe impl ::std::marker::Sync for self::DropUserReq {}

impl ::fbthrift::GetTType for self::DropUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterUserReq {}
unsafe impl ::std::marker::Sync for self::AlterUserReq {}

impl ::fbthrift::GetTType for self::AlterUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GrantRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GrantRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GrantRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GrantRoleReq {}
unsafe impl ::std::marker::Sync for self::GrantRoleReq {}

impl ::fbthrift::GetTType for self::GrantRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GrantRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RevokeRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RevokeRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RevokeRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RevokeRoleReq {}
unsafe impl ::std::marker::Sync for self::RevokeRoleReq {}

impl ::fbthrift::GetTType for self::RevokeRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RevokeRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersReq {}
unsafe impl ::std::marker::Sync for self::ListUsersReq {}

impl ::fbthrift::GetTType for self::ListUsersReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            users: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("users", &self.users)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersResp {}
unsafe impl ::std::marker::Sync for self::ListUsersResp {}

impl ::fbthrift::GetTType for self::ListUsersResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("users", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.users, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("users", ::fbthrift::TType::Map, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_users = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_users = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            users: field_users.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesReq {}
unsafe impl ::std::marker::Sync for self::ListRolesReq {}

impl ::fbthrift::GetTType for self::ListRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUserRolesReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUserRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUserRolesReq")
            .field("account", &self.account)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUserRolesReq {}
unsafe impl ::std::marker::Sync for self::GetUserRolesReq {}

impl ::fbthrift::GetTType for self::GetUserRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUserRolesReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
        ];
        let mut field_account = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            roles: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("roles", &self.roles)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesResp {}
unsafe impl ::std::marker::Sync for self::ListRolesResp {}

impl ::fbthrift::GetTType for self::ListRolesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("roles", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.roles, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("roles", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_roles = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_roles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            roles: field_roles.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChangePasswordReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            new_encoded_pwd: ::std::default::Default::default(),
            old_encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChangePasswordReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChangePasswordReq")
            .field("account", &self.account)
            .field("new_encoded_pwd", &self.new_encoded_pwd)
            .field("old_encoded_pwd", &self.old_encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChangePasswordReq {}
unsafe impl ::std::marker::Sync for self::ChangePasswordReq {}

impl ::fbthrift::GetTType for self::ChangePasswordReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChangePasswordReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("new_encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.new_encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("old_encoded_pwd", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.old_encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("new_encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("old_encoded_pwd", ::fbthrift::TType::String, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_new_encoded_pwd = ::std::option::Option::None;
        let mut field_old_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_new_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_old_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            new_encoded_pwd: field_new_encoded_pwd.unwrap_or_default(),
            old_encoded_pwd: field_old_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceReq {
    fn default() -> Self {
        Self {
            space_id: ::std::option::Option::None,
            id: ::std::option::Option::None,
            host_del: ::std::option::Option::None,
            stop: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceReq")
            .field("space_id", &self.space_id)
            .field("id", &self.id)
            .field("host_del", &self.host_del)
            .field("stop", &self.stop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceReq {}
unsafe impl ::std::marker::Sync for self::BalanceReq {}

impl ::fbthrift::GetTType for self::BalanceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceReq");
        if let ::std::option::Option::Some(some) = &self.space_id {
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.id {
            p.write_field_begin("id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.host_del {
            p.write_field_begin("host_del", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.stop {
            p.write_field_begin("stop", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host_del", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("stop", ::fbthrift::TType::Bool, 4),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_host_del = ::std::option::Option::None;
        let mut field_stop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_host_del = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_stop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id,
            id: field_id,
            host_del: field_host_del,
            stop: field_stop,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceTask {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceTask {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceTask")
            .field("id", &self.id)
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceTask {}
unsafe impl ::std::marker::Sync for self::BalanceTask {}

impl ::fbthrift::GetTType for self::BalanceTask {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceTask");
        p.write_field_begin("id", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("result", ::fbthrift::TType::I32, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            tasks: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceResp")
            .field("code", &self.code)
            .field("id", &self.id)
            .field("leader", &self.leader)
            .field("tasks", &self.tasks)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceResp {}
unsafe impl ::std::marker::Sync for self::BalanceResp {}

impl ::fbthrift::GetTType for self::BalanceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("tasks", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.tasks, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("tasks", ::fbthrift::TType::List, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_tasks = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_tasks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            tasks: field_tasks.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LeaderBalanceReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LeaderBalanceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LeaderBalanceReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LeaderBalanceReq {}
unsafe impl ::std::marker::Sync for self::LeaderBalanceReq {}

impl ::fbthrift::GetTType for self::LeaderBalanceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LeaderBalanceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LeaderBalanceReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LeaderBalanceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ConfigItem {
    fn default() -> Self {
        Self {
            module: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            mode: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ConfigItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ConfigItem")
            .field("module", &self.module)
            .field("name", &self.name)
            .field("r#type", &self.r#type)
            .field("mode", &self.mode)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ConfigItem {}
unsafe impl ::std::marker::Sync for self::ConfigItem {}

impl ::fbthrift::GetTType for self::ConfigItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ConfigItem");
        p.write_field_begin("module", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("mode", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.mode, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 5),
        ];
        let mut field_module = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_mode = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            module: field_module.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            mode: field_mode.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RegConfigReq {
    fn default() -> Self {
        Self {
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RegConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RegConfigReq")
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RegConfigReq {}
unsafe impl ::std::marker::Sync for self::RegConfigReq {}

impl ::fbthrift::GetTType for self::RegConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RegConfigReq");
        p.write_field_begin("items", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 1),
        ];
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigReq")
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigReq {}
unsafe impl ::std::marker::Sync for self::GetConfigReq {}

impl ::fbthrift::GetTType for self::GetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigResp {}
unsafe impl ::std::marker::Sync for self::GetConfigResp {}

impl ::fbthrift::GetTType for self::GetConfigResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            force: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SetConfigReq")
            .field("item", &self.item)
            .field("force", &self.force)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SetConfigReq {}
unsafe impl ::std::marker::Sync for self::SetConfigReq {}

impl ::fbthrift::GetTType for self::SetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_begin("force", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.force, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("force", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let mut field_force = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_force = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            force: field_force.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsReq {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            module: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsReq")
            .field("space", &self.space)
            .field("module", &self.module)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsReq {}
unsafe impl ::std::marker::Sync for self::ListConfigsReq {}

impl ::fbthrift::GetTType for self::ListConfigsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsReq");
        p.write_field_begin("space", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("module", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::String, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_module = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            module: field_module.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsResp {}
unsafe impl ::std::marker::Sync for self::ListConfigsResp {}

impl ::fbthrift::GetTType for self::ListConfigsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSnapshotReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSnapshotReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSnapshotReq {}
unsafe impl ::std::marker::Sync for self::CreateSnapshotReq {}

impl ::fbthrift::GetTType for self::CreateSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSnapshotReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSnapshotReq {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSnapshotReq")
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSnapshotReq {}
unsafe impl ::std::marker::Sync for self::DropSnapshotReq {}

impl ::fbthrift::GetTType for self::DropSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSnapshotReq");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
        ];
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsReq {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsReq {}

impl ::fbthrift::GetTType for self::ListSnapshotsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Snapshot {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Snapshot {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Snapshot")
            .field("name", &self.name)
            .field("status", &self.status)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Snapshot {}
unsafe impl ::std::marker::Sync for self::Snapshot {}

impl ::fbthrift::GetTType for self::Snapshot {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Snapshot");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            snapshots: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("snapshots", &self.snapshots)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsResp {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsResp {}

impl ::fbthrift::GetTType for self::ListSnapshotsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("snapshots", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.snapshots, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("snapshots", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_snapshots = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_snapshots = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            snapshots: field_snapshots.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusReq {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusReq {}

impl ::fbthrift::GetTType for self::ListIndexStatusReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexStatus {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexStatus {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexStatus")
            .field("name", &self.name)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexStatus {}
unsafe impl ::std::marker::Sync for self::IndexStatus {}

impl ::fbthrift::GetTType for self::IndexStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexStatus");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::String, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            statuses: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("statuses", &self.statuses)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusResp {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusResp {}

impl ::fbthrift::GetTType for self::ListIndexStatusResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("statuses", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.statuses, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("statuses", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_statuses = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_statuses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            statuses: field_statuses.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
