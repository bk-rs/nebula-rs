// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(bare_trait_objects)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types;

#[doc(hidden)]
pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod meta_service {
        #[derive(Clone, Debug)]
        pub enum CreateSpaceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSpaceError> for CreateSpaceExn {
            fn from(err: crate::errors::meta_service::CreateSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSpaceError::ApplicationException(aexn) => CreateSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSpaceError::ThriftError(err) => CreateSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSpaceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropSpaceError> for DropSpaceExn {
            fn from(err: crate::errors::meta_service::DropSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::DropSpaceError::ApplicationException(aexn) => DropSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropSpaceError::ThriftError(err) => DropSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSpaceExn {
            #[doc(hidden)]
            Success(crate::types::GetSpaceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetSpaceError> for GetSpaceExn {
            fn from(err: crate::errors::meta_service::GetSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::GetSpaceError::ApplicationException(aexn) => GetSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetSpaceError::ThriftError(err) => GetSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSpacesExn {
            #[doc(hidden)]
            Success(crate::types::ListSpacesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListSpacesError> for ListSpacesExn {
            fn from(err: crate::errors::meta_service::ListSpacesError) -> Self {
                match err {
                    crate::errors::meta_service::ListSpacesError::ApplicationException(aexn) => ListSpacesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListSpacesError::ThriftError(err) => ListSpacesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSpacesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListSpacesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListSpacesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListSpacesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSpaces");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSpacesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSpacesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateTagError> for CreateTagExn {
            fn from(err: crate::errors::meta_service::CreateTagError) -> Self {
                match err {
                    crate::errors::meta_service::CreateTagError::ApplicationException(aexn) => CreateTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateTagError::ThriftError(err) => CreateTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterTagError> for AlterTagExn {
            fn from(err: crate::errors::meta_service::AlterTagError) -> Self {
                match err {
                    crate::errors::meta_service::AlterTagError::ApplicationException(aexn) => AlterTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterTagError::ThriftError(err) => AlterTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropTagError> for DropTagExn {
            fn from(err: crate::errors::meta_service::DropTagError) -> Self {
                match err {
                    crate::errors::meta_service::DropTagError::ApplicationException(aexn) => DropTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropTagError::ThriftError(err) => DropTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagExn {
            #[doc(hidden)]
            Success(crate::types::GetTagResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetTagError> for GetTagExn {
            fn from(err: crate::errors::meta_service::GetTagError) -> Self {
                match err {
                    crate::errors::meta_service::GetTagError::ApplicationException(aexn) => GetTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetTagError::ThriftError(err) => GetTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagsExn {
            #[doc(hidden)]
            Success(crate::types::ListTagsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagsError> for ListTagsExn {
            fn from(err: crate::errors::meta_service::ListTagsError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagsError::ApplicationException(aexn) => ListTagsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagsError::ThriftError(err) => ListTagsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTags");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateEdgeError> for CreateEdgeExn {
            fn from(err: crate::errors::meta_service::CreateEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::CreateEdgeError::ApplicationException(aexn) => CreateEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateEdgeError::ThriftError(err) => CreateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterEdgeError> for AlterEdgeExn {
            fn from(err: crate::errors::meta_service::AlterEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::AlterEdgeError::ApplicationException(aexn) => AlterEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterEdgeError::ThriftError(err) => AlterEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropEdgeError> for DropEdgeExn {
            fn from(err: crate::errors::meta_service::DropEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::DropEdgeError::ApplicationException(aexn) => DropEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropEdgeError::ThriftError(err) => DropEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeExn {
            #[doc(hidden)]
            Success(crate::types::GetEdgeResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetEdgeError> for GetEdgeExn {
            fn from(err: crate::errors::meta_service::GetEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::GetEdgeError::ApplicationException(aexn) => GetEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetEdgeError::ThriftError(err) => GetEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ListEdgesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgesError> for ListEdgesExn {
            fn from(err: crate::errors::meta_service::ListEdgesError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgesError::ApplicationException(aexn) => ListEdgesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgesError::ThriftError(err) => ListEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListHostsExn {
            #[doc(hidden)]
            Success(crate::types::ListHostsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListHostsError> for ListHostsExn {
            fn from(err: crate::errors::meta_service::ListHostsError) -> Self {
                match err {
                    crate::errors::meta_service::ListHostsError::ApplicationException(aexn) => ListHostsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListHostsError::ThriftError(err) => ListHostsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListHostsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListHostsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListHostsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListHostsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListHosts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPartsAllocExn {
            #[doc(hidden)]
            Success(crate::types::GetPartsAllocResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetPartsAllocError> for GetPartsAllocExn {
            fn from(err: crate::errors::meta_service::GetPartsAllocError) -> Self {
                match err {
                    crate::errors::meta_service::GetPartsAllocError::ApplicationException(aexn) => GetPartsAllocExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetPartsAllocError::ThriftError(err) => GetPartsAllocExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPartsAllocExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetPartsAllocExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetPartsAllocExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetPartsAllocExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetPartsAlloc");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPartsAllocExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPartsAllocExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListPartsExn {
            #[doc(hidden)]
            Success(crate::types::ListPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListPartsError> for ListPartsExn {
            fn from(err: crate::errors::meta_service::ListPartsError) -> Self {
                match err {
                    crate::errors::meta_service::ListPartsError::ApplicationException(aexn) => ListPartsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListPartsError::ThriftError(err) => ListPartsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListPartsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListPartsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListParts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiPutExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::MultiPutError> for MultiPutExn {
            fn from(err: crate::errors::meta_service::MultiPutError) -> Self {
                match err {
                    crate::errors::meta_service::MultiPutError::ApplicationException(aexn) => MultiPutExn::ApplicationException(aexn),
                    crate::errors::meta_service::MultiPutError::ThriftError(err) => MultiPutExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiPutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MultiPutExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MultiPutExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MultiPutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MultiPut");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiPutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiPutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            #[doc(hidden)]
            Success(crate::types::GetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetError> for GetExn {
            fn from(err: crate::errors::meta_service::GetError) -> Self {
                match err {
                    crate::errors::meta_service::GetError::ApplicationException(aexn) => GetExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetError::ThriftError(err) => GetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Get");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiGetExn {
            #[doc(hidden)]
            Success(crate::types::MultiGetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::MultiGetError> for MultiGetExn {
            fn from(err: crate::errors::meta_service::MultiGetError) -> Self {
                match err {
                    crate::errors::meta_service::MultiGetError::ApplicationException(aexn) => MultiGetExn::ApplicationException(aexn),
                    crate::errors::meta_service::MultiGetError::ThriftError(err) => MultiGetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiGetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MultiGetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MultiGetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MultiGetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MultiGet");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiGetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiGetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveError> for RemoveExn {
            fn from(err: crate::errors::meta_service::RemoveError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveError::ApplicationException(aexn) => RemoveExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveError::ThriftError(err) => RemoveExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Remove");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveRangeError> for RemoveRangeExn {
            fn from(err: crate::errors::meta_service::RemoveRangeError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveRangeError::ApplicationException(aexn) => RemoveRangeExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveRangeError::ThriftError(err) => RemoveRangeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveRangeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveRangeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveRange");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanExn {
            #[doc(hidden)]
            Success(crate::types::ScanResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ScanError> for ScanExn {
            fn from(err: crate::errors::meta_service::ScanError) -> Self {
                match err {
                    crate::errors::meta_service::ScanError::ApplicationException(aexn) => ScanExn::ApplicationException(aexn),
                    crate::errors::meta_service::ScanError::ThriftError(err) => ScanExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Scan");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateTagIndexError> for CreateTagIndexExn {
            fn from(err: crate::errors::meta_service::CreateTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::CreateTagIndexError::ApplicationException(aexn) => CreateTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateTagIndexError::ThriftError(err) => CreateTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropTagIndexError> for DropTagIndexExn {
            fn from(err: crate::errors::meta_service::DropTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::DropTagIndexError::ApplicationException(aexn) => DropTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropTagIndexError::ThriftError(err) => DropTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::GetTagIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetTagIndexError> for GetTagIndexExn {
            fn from(err: crate::errors::meta_service::GetTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::GetTagIndexError::ApplicationException(aexn) => GetTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetTagIndexError::ThriftError(err) => GetTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexesExn {
            #[doc(hidden)]
            Success(crate::types::ListTagIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagIndexesError> for ListTagIndexesExn {
            fn from(err: crate::errors::meta_service::ListTagIndexesError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagIndexesError::ApplicationException(aexn) => ListTagIndexesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagIndexesError::ThriftError(err) => ListTagIndexesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagIndexesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RebuildTagIndexError> for RebuildTagIndexExn {
            fn from(err: crate::errors::meta_service::RebuildTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn) => RebuildTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::RebuildTagIndexError::ThriftError(err) => RebuildTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexStatusExn {
            #[doc(hidden)]
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagIndexStatusError> for ListTagIndexStatusExn {
            fn from(err: crate::errors::meta_service::ListTagIndexStatusError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn) => ListTagIndexStatusExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagIndexStatusError::ThriftError(err) => ListTagIndexStatusExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagIndexStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateEdgeIndexError> for CreateEdgeIndexExn {
            fn from(err: crate::errors::meta_service::CreateEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn) => CreateEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateEdgeIndexError::ThriftError(err) => CreateEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropEdgeIndexError> for DropEdgeIndexExn {
            fn from(err: crate::errors::meta_service::DropEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn) => DropEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropEdgeIndexError::ThriftError(err) => DropEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::GetEdgeIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetEdgeIndexError> for GetEdgeIndexExn {
            fn from(err: crate::errors::meta_service::GetEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn) => GetEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetEdgeIndexError::ThriftError(err) => GetEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexesExn {
            #[doc(hidden)]
            Success(crate::types::ListEdgeIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgeIndexesError> for ListEdgeIndexesExn {
            fn from(err: crate::errors::meta_service::ListEdgeIndexesError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn) => ListEdgeIndexesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgeIndexesError::ThriftError(err) => ListEdgeIndexesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgeIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgeIndexesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RebuildEdgeIndexError> for RebuildEdgeIndexExn {
            fn from(err: crate::errors::meta_service::RebuildEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn) => RebuildEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::RebuildEdgeIndexError::ThriftError(err) => RebuildEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexStatusExn {
            #[doc(hidden)]
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgeIndexStatusError> for ListEdgeIndexStatusExn {
            fn from(err: crate::errors::meta_service::ListEdgeIndexStatusError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn) => ListEdgeIndexStatusExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgeIndexStatusError::ThriftError(err) => ListEdgeIndexStatusExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgeIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgeIndexStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateUserError> for CreateUserExn {
            fn from(err: crate::errors::meta_service::CreateUserError) -> Self {
                match err {
                    crate::errors::meta_service::CreateUserError::ApplicationException(aexn) => CreateUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateUserError::ThriftError(err) => CreateUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropUserError> for DropUserExn {
            fn from(err: crate::errors::meta_service::DropUserError) -> Self {
                match err {
                    crate::errors::meta_service::DropUserError::ApplicationException(aexn) => DropUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropUserError::ThriftError(err) => DropUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterUserError> for AlterUserExn {
            fn from(err: crate::errors::meta_service::AlterUserError) -> Self {
                match err {
                    crate::errors::meta_service::AlterUserError::ApplicationException(aexn) => AlterUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterUserError::ThriftError(err) => AlterUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GrantRoleExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GrantRoleError> for GrantRoleExn {
            fn from(err: crate::errors::meta_service::GrantRoleError) -> Self {
                match err {
                    crate::errors::meta_service::GrantRoleError::ApplicationException(aexn) => GrantRoleExn::ApplicationException(aexn),
                    crate::errors::meta_service::GrantRoleError::ThriftError(err) => GrantRoleExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GrantRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GrantRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GrantRoleExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GrantRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GrantRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GrantRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GrantRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RevokeRoleExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RevokeRoleError> for RevokeRoleExn {
            fn from(err: crate::errors::meta_service::RevokeRoleError) -> Self {
                match err {
                    crate::errors::meta_service::RevokeRoleError::ApplicationException(aexn) => RevokeRoleExn::ApplicationException(aexn),
                    crate::errors::meta_service::RevokeRoleError::ThriftError(err) => RevokeRoleExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RevokeRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RevokeRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RevokeRoleExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RevokeRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RevokeRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RevokeRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RevokeRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListUsersExn {
            #[doc(hidden)]
            Success(crate::types::ListUsersResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListUsersError> for ListUsersExn {
            fn from(err: crate::errors::meta_service::ListUsersError) -> Self {
                match err {
                    crate::errors::meta_service::ListUsersError::ApplicationException(aexn) => ListUsersExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListUsersError::ThriftError(err) => ListUsersExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListUsersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListUsersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListUsersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListUsersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListUsers");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListUsersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListUsersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListRolesExn {
            #[doc(hidden)]
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListRolesError> for ListRolesExn {
            fn from(err: crate::errors::meta_service::ListRolesError) -> Self {
                match err {
                    crate::errors::meta_service::ListRolesError::ApplicationException(aexn) => ListRolesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListRolesError::ThriftError(err) => ListRolesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListRolesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUserRolesExn {
            #[doc(hidden)]
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetUserRolesError> for GetUserRolesExn {
            fn from(err: crate::errors::meta_service::GetUserRolesError) -> Self {
                match err {
                    crate::errors::meta_service::GetUserRolesError::ApplicationException(aexn) => GetUserRolesExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetUserRolesError::ThriftError(err) => GetUserRolesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUserRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetUserRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetUserRolesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetUserRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetUserRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUserRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUserRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChangePasswordExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ChangePasswordError> for ChangePasswordExn {
            fn from(err: crate::errors::meta_service::ChangePasswordError) -> Self {
                match err {
                    crate::errors::meta_service::ChangePasswordError::ApplicationException(aexn) => ChangePasswordExn::ApplicationException(aexn),
                    crate::errors::meta_service::ChangePasswordError::ThriftError(err) => ChangePasswordExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChangePasswordExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChangePasswordExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChangePasswordExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChangePasswordExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChangePassword");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChangePasswordExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChangePasswordExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum HeartBeatExn {
            #[doc(hidden)]
            Success(crate::types::HBResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::HeartBeatError> for HeartBeatExn {
            fn from(err: crate::errors::meta_service::HeartBeatError) -> Self {
                match err {
                    crate::errors::meta_service::HeartBeatError::ApplicationException(aexn) => HeartBeatExn::ApplicationException(aexn),
                    crate::errors::meta_service::HeartBeatError::ThriftError(err) => HeartBeatExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for HeartBeatExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for HeartBeatExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for HeartBeatExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for HeartBeatExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("HeartBeat");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "HeartBeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "HeartBeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BalanceExn {
            #[doc(hidden)]
            Success(crate::types::BalanceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::BalanceError> for BalanceExn {
            fn from(err: crate::errors::meta_service::BalanceError) -> Self {
                match err {
                    crate::errors::meta_service::BalanceError::ApplicationException(aexn) => BalanceExn::ApplicationException(aexn),
                    crate::errors::meta_service::BalanceError::ThriftError(err) => BalanceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for BalanceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for BalanceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for BalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Balance");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LeaderBalanceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::LeaderBalanceError> for LeaderBalanceExn {
            fn from(err: crate::errors::meta_service::LeaderBalanceError) -> Self {
                match err {
                    crate::errors::meta_service::LeaderBalanceError::ApplicationException(aexn) => LeaderBalanceExn::ApplicationException(aexn),
                    crate::errors::meta_service::LeaderBalanceError::ThriftError(err) => LeaderBalanceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LeaderBalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for LeaderBalanceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for LeaderBalanceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for LeaderBalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("LeaderBalance");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LeaderBalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LeaderBalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RegConfigExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RegConfigError> for RegConfigExn {
            fn from(err: crate::errors::meta_service::RegConfigError) -> Self {
                match err {
                    crate::errors::meta_service::RegConfigError::ApplicationException(aexn) => RegConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::RegConfigError::ThriftError(err) => RegConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RegConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RegConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RegConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RegConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RegConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RegConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RegConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            #[doc(hidden)]
            Success(crate::types::GetConfigResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetConfigError> for GetConfigExn {
            fn from(err: crate::errors::meta_service::GetConfigError) -> Self {
                match err {
                    crate::errors::meta_service::GetConfigError::ApplicationException(aexn) => GetConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetConfigError::ThriftError(err) => GetConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetConfigExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::SetConfigError> for SetConfigExn {
            fn from(err: crate::errors::meta_service::SetConfigError) -> Self {
                match err {
                    crate::errors::meta_service::SetConfigError::ApplicationException(aexn) => SetConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::SetConfigError::ThriftError(err) => SetConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SetConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for SetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListConfigsExn {
            #[doc(hidden)]
            Success(crate::types::ListConfigsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListConfigsError> for ListConfigsExn {
            fn from(err: crate::errors::meta_service::ListConfigsError) -> Self {
                match err {
                    crate::errors::meta_service::ListConfigsError::ApplicationException(aexn) => ListConfigsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListConfigsError::ThriftError(err) => ListConfigsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListConfigsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListConfigsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListConfigsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListConfigsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListConfigs");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListConfigsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListConfigsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSnapshotExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSnapshotError> for CreateSnapshotExn {
            fn from(err: crate::errors::meta_service::CreateSnapshotError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSnapshotError::ApplicationException(aexn) => CreateSnapshotExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSnapshotError::ThriftError(err) => CreateSnapshotExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSnapshotExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSnapshotExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropSnapshotError> for DropSnapshotExn {
            fn from(err: crate::errors::meta_service::DropSnapshotError) -> Self {
                match err {
                    crate::errors::meta_service::DropSnapshotError::ApplicationException(aexn) => DropSnapshotExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropSnapshotError::ThriftError(err) => DropSnapshotExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropSnapshotExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSnapshotsExn {
            #[doc(hidden)]
            Success(crate::types::ListSnapshotsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListSnapshotsError> for ListSnapshotsExn {
            fn from(err: crate::errors::meta_service::ListSnapshotsError) -> Self {
                match err {
                    crate::errors::meta_service::ListSnapshotsError::ApplicationException(aexn) => ListSnapshotsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListSnapshotsError::ThriftError(err) => ListSnapshotsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSnapshotsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListSnapshotsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListSnapshotsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListSnapshotsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSnapshots");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSnapshotsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSnapshotsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RunAdminJobExn {
            #[doc(hidden)]
            Success(crate::types::AdminJobResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RunAdminJobError> for RunAdminJobExn {
            fn from(err: crate::errors::meta_service::RunAdminJobError) -> Self {
                match err {
                    crate::errors::meta_service::RunAdminJobError::ApplicationException(aexn) => RunAdminJobExn::ApplicationException(aexn),
                    crate::errors::meta_service::RunAdminJobError::ThriftError(err) => RunAdminJobExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RunAdminJobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RunAdminJobExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RunAdminJobExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RunAdminJobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RunAdminJob");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RunAdminJobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RunAdminJobExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `meta`.
pub mod client {

    pub struct MetaServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _createSpace_impl(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let args = self::Args_MetaService_createSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSpace"))
            .boxed()
        }

        fn _dropSpace_impl(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let args = self::Args_MetaService_dropSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSpace"))
            .boxed()
        }

        fn _getSpace_impl(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let args = self::Args_MetaService_getSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSpace"))
            .boxed()
        }

        fn _listSpaces_impl(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let args = self::Args_MetaService_listSpaces {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listSpaces", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSpaces"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListSpacesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSpaces"))
            .boxed()
        }

        fn _createTag_impl(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let args = self::Args_MetaService_createTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTag"))
            .boxed()
        }

        fn _alterTag_impl(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let args = self::Args_MetaService_alterTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterTag"))
            .boxed()
        }

        fn _dropTag_impl(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let args = self::Args_MetaService_dropTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTag"))
            .boxed()
        }

        fn _getTag_impl(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let args = self::Args_MetaService_getTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTag"))
            .boxed()
        }

        fn _listTags_impl(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let args = self::Args_MetaService_listTags {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTags", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTags"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTags"))
            .boxed()
        }

        fn _createEdge_impl(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let args = self::Args_MetaService_createEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdge"))
            .boxed()
        }

        fn _alterEdge_impl(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let args = self::Args_MetaService_alterEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterEdge"))
            .boxed()
        }

        fn _dropEdge_impl(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let args = self::Args_MetaService_dropEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdge"))
            .boxed()
        }

        fn _getEdge_impl(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let args = self::Args_MetaService_getEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdge"))
            .boxed()
        }

        fn _listEdges_impl(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let args = self::Args_MetaService_listEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdges"))
            .boxed()
        }

        fn _listHosts_impl(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let args = self::Args_MetaService_listHosts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listHosts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listHosts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListHostsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listHosts"))
            .boxed()
        }

        fn _getPartsAlloc_impl(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let args = self::Args_MetaService_getPartsAlloc {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getPartsAlloc", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getPartsAlloc"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetPartsAllocExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getPartsAlloc"))
            .boxed()
        }

        fn _listParts_impl(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let args = self::Args_MetaService_listParts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listParts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listParts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListPartsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listParts"))
            .boxed()
        }

        fn _multiPut_impl(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let args = self::Args_MetaService_multiPut {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("multiPut", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.multiPut"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::MultiPutExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.multiPut"))
            .boxed()
        }

        fn _get_impl(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let args = self::Args_MetaService_get {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("get", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.get"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.get"))
            .boxed()
        }

        fn _multiGet_impl(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let args = self::Args_MetaService_multiGet {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("multiGet", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.multiGet"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::MultiGetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.multiGet"))
            .boxed()
        }

        fn _remove_impl(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let args = self::Args_MetaService_remove {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("remove", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.remove"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.remove"))
            .boxed()
        }

        fn _removeRange_impl(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let args = self::Args_MetaService_removeRange {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeRange", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeRange"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveRangeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeRange"))
            .boxed()
        }

        fn _scan_impl(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let args = self::Args_MetaService_scan {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scan", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.scan"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ScanExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.scan"))
            .boxed()
        }

        fn _createTagIndex_impl(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let args = self::Args_MetaService_createTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTagIndex"))
            .boxed()
        }

        fn _dropTagIndex_impl(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let args = self::Args_MetaService_dropTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTagIndex"))
            .boxed()
        }

        fn _getTagIndex_impl(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let args = self::Args_MetaService_getTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTagIndex"))
            .boxed()
        }

        fn _listTagIndexes_impl(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let args = self::Args_MetaService_listTagIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagIndexesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexes"))
            .boxed()
        }

        fn _rebuildTagIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let args = self::Args_MetaService_rebuildTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RebuildTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildTagIndex"))
            .boxed()
        }

        fn _listTagIndexStatus_impl(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let args = self::Args_MetaService_listTagIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagIndexStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexStatus"))
            .boxed()
        }

        fn _createEdgeIndex_impl(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let args = self::Args_MetaService_createEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdgeIndex"))
            .boxed()
        }

        fn _dropEdgeIndex_impl(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let args = self::Args_MetaService_dropEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdgeIndex"))
            .boxed()
        }

        fn _getEdgeIndex_impl(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let args = self::Args_MetaService_getEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexes_impl(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let args = self::Args_MetaService_listEdgeIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgeIndexesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexes"))
            .boxed()
        }

        fn _rebuildEdgeIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let args = self::Args_MetaService_rebuildEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RebuildEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexStatus_impl(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let args = self::Args_MetaService_listEdgeIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgeIndexStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexStatus"))
            .boxed()
        }

        fn _createUser_impl(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let args = self::Args_MetaService_createUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createUser"))
            .boxed()
        }

        fn _dropUser_impl(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let args = self::Args_MetaService_dropUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropUser"))
            .boxed()
        }

        fn _alterUser_impl(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let args = self::Args_MetaService_alterUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterUser"))
            .boxed()
        }

        fn _grantRole_impl(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let args = self::Args_MetaService_grantRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("grantRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.grantRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GrantRoleExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.grantRole"))
            .boxed()
        }

        fn _revokeRole_impl(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let args = self::Args_MetaService_revokeRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("revokeRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.revokeRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RevokeRoleExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.revokeRole"))
            .boxed()
        }

        fn _listUsers_impl(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let args = self::Args_MetaService_listUsers {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listUsers", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listUsers"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListUsersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listUsers"))
            .boxed()
        }

        fn _listRoles_impl(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let args = self::Args_MetaService_listRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListRolesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listRoles"))
            .boxed()
        }

        fn _getUserRoles_impl(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let args = self::Args_MetaService_getUserRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getUserRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getUserRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetUserRolesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getUserRoles"))
            .boxed()
        }

        fn _changePassword_impl(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let args = self::Args_MetaService_changePassword {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("changePassword", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.changePassword"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ChangePasswordExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.changePassword"))
            .boxed()
        }

        fn _heartBeat_impl(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let args = self::Args_MetaService_heartBeat {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("heartBeat", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.heartBeat"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::HeartBeatExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.heartBeat"))
            .boxed()
        }

        fn _balance_impl(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let args = self::Args_MetaService_balance {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("balance", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.balance"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::BalanceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.balance"))
            .boxed()
        }

        fn _leaderBalance_impl(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let args = self::Args_MetaService_leaderBalance {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("leaderBalance", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.leaderBalance"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::LeaderBalanceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.leaderBalance"))
            .boxed()
        }

        fn _regConfig_impl(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let args = self::Args_MetaService_regConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("regConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.regConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RegConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.regConfig"))
            .boxed()
        }

        fn _getConfig_impl(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let args = self::Args_MetaService_getConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getConfig"))
            .boxed()
        }

        fn _setConfig_impl(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let args = self::Args_MetaService_setConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("setConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.setConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::SetConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.setConfig"))
            .boxed()
        }

        fn _listConfigs_impl(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let args = self::Args_MetaService_listConfigs {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listConfigs", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listConfigs"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListConfigsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listConfigs"))
            .boxed()
        }

        fn _createSnapshot_impl(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let args = self::Args_MetaService_createSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSnapshotExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSnapshot"))
            .boxed()
        }

        fn _dropSnapshot_impl(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let args = self::Args_MetaService_dropSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropSnapshotExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSnapshot"))
            .boxed()
        }

        fn _listSnapshots_impl(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let args = self::Args_MetaService_listSnapshots {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listSnapshots", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSnapshots"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListSnapshotsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSnapshots"))
            .boxed()
        }

        fn _runAdminJob_impl(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let args = self::Args_MetaService_runAdminJob {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("runAdminJob", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.runAdminJob"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RunAdminJobExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.runAdminJob"))
            .boxed()
        }
    }

    pub trait MetaService: ::std::marker::Send {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>>;

        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>>;

        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>>;

        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>>;

        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>>;

        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>>;

        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>>;

        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>>;

        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>>;

        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>>;

        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>>;

        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>>;

        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>>;

        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>>;

        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>>;

        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>>;

        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>>;

        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>>;

        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>>;

        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>>;

        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>>;

        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>>;

        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>>;

        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>>;

        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>>;

        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>>;

        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>>;

        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>>;

        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>>;

        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>>;

        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>>;

        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>>;

        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>>;

        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>>;

        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>>;

        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>>;

        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>>;

        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>>;

        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>>;

        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>>;

        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>>;

        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>>;

        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>>;

        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>>;

        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>>;

        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>>;

        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>>;

        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>>;

        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>>;

        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>>;

        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>>;

        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>>;

        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>>;

        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>>;

        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>>;
    }

    pub trait MetaServiceExt<T>: MetaService
    where
        T: ::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>>;
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>>;
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>>;
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>>;
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>>;
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>>;
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>>;
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>>;
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>>;
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>>;
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>>;
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>>;
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>>;
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>>;
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>>;
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>>;
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>>;
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>>;
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>>;
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>>;
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>>;
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>>;
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>>;
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>>;
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>>;
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>>;
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>>;
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>>;
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>>;
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>>;
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>>;
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>>;
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>>;
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>>;
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>>;
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>>;
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>>;
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>>;
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>>;
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>>;
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>>;
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>>;
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>>;
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>>;
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>>;
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>>;
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>>;
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>>;
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>>;
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>>;
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>>;
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>>;
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>>;
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>>;
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>>;
    }

    struct Args_MetaService_createSpace<'a> {
        req: &'a crate::types::CreateSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSpace<'a> {
        req: &'a crate::types::DropSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSpace<'a> {
        req: &'a crate::types::GetSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSpaces<'a> {
        req: &'a crate::types::ListSpacesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listSpaces<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSpaces"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTag<'a> {
        req: &'a crate::types::CreateTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterTag<'a> {
        req: &'a crate::types::AlterTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTag<'a> {
        req: &'a crate::types::DropTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTag<'a> {
        req: &'a crate::types::GetTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTags<'a> {
        req: &'a crate::types::ListTagsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTags<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTags"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdge<'a> {
        req: &'a crate::types::CreateEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterEdge<'a> {
        req: &'a crate::types::AlterEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdge<'a> {
        req: &'a crate::types::DropEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdge<'a> {
        req: &'a crate::types::GetEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdges<'a> {
        req: &'a crate::types::ListEdgesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listHosts<'a> {
        req: &'a crate::types::ListHostsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listHosts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listHosts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getPartsAlloc<'a> {
        req: &'a crate::types::GetPartsAllocReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getPartsAlloc<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listParts<'a> {
        req: &'a crate::types::ListPartsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listParts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listParts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_multiPut<'a> {
        req: &'a crate::types::MultiPutReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_multiPut<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.multiPut"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_get<'a> {
        req: &'a crate::types::GetReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_get<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.get"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_multiGet<'a> {
        req: &'a crate::types::MultiGetReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_multiGet<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.multiGet"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_remove<'a> {
        req: &'a crate::types::RemoveReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_remove<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.remove"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeRange<'a> {
        req: &'a crate::types::RemoveRangeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_removeRange<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeRange"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_scan<'a> {
        req: &'a crate::types::ScanReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_scan<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.scan"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTagIndex<'a> {
        req: &'a crate::types::CreateTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTagIndex<'a> {
        req: &'a crate::types::DropTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTagIndex<'a> {
        req: &'a crate::types::GetTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexes<'a> {
        req: &'a crate::types::ListTagIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildTagIndex<'a> {
        req: &'a crate::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_rebuildTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexStatus<'a> {
        req: &'a crate::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdgeIndex<'a> {
        req: &'a crate::types::CreateEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdgeIndex<'a> {
        req: &'a crate::types::DropEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdgeIndex<'a> {
        req: &'a crate::types::GetEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexes<'a> {
        req: &'a crate::types::ListEdgeIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildEdgeIndex<'a> {
        req: &'a crate::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_rebuildEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexStatus<'a> {
        req: &'a crate::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createUser<'a> {
        req: &'a crate::types::CreateUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropUser<'a> {
        req: &'a crate::types::DropUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterUser<'a> {
        req: &'a crate::types::AlterUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_grantRole<'a> {
        req: &'a crate::types::GrantRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_grantRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.grantRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_revokeRole<'a> {
        req: &'a crate::types::RevokeRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_revokeRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.revokeRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listUsers<'a> {
        req: &'a crate::types::ListUsersReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listUsers<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listUsers"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listRoles<'a> {
        req: &'a crate::types::ListRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getUserRoles<'a> {
        req: &'a crate::types::GetUserRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getUserRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getUserRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_changePassword<'a> {
        req: &'a crate::types::ChangePasswordReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_changePassword<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.changePassword"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_heartBeat<'a> {
        req: &'a crate::types::HBReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_heartBeat<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.heartBeat"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_balance<'a> {
        req: &'a crate::types::BalanceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_balance<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.balance"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_leaderBalance<'a> {
        req: &'a crate::types::LeaderBalanceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_leaderBalance<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.leaderBalance"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_regConfig<'a> {
        req: &'a crate::types::RegConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_regConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.regConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getConfig<'a> {
        req: &'a crate::types::GetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_setConfig<'a> {
        req: &'a crate::types::SetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_setConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.setConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listConfigs<'a> {
        req: &'a crate::types::ListConfigsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listConfigs<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listConfigs"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSnapshot<'a> {
        req: &'a crate::types::CreateSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSnapshot<'a> {
        req: &'a crate::types::DropSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSnapshots<'a> {
        req: &'a crate::types::ListSnapshotsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listSnapshots<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSnapshots"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_runAdminJob<'a> {
        req: &'a crate::types::AdminJobReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_runAdminJob<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.runAdminJob"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> MetaService for MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            let rpc_options = T::RpcOptions::default();
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            let rpc_options = T::RpcOptions::default();
            self._multiPut_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            let rpc_options = T::RpcOptions::default();
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            let rpc_options = T::RpcOptions::default();
            self._multiGet_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            let rpc_options = T::RpcOptions::default();
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            let rpc_options = T::RpcOptions::default();
            self._scan_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            let rpc_options = T::RpcOptions::default();
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            let rpc_options = T::RpcOptions::default();
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            let rpc_options = T::RpcOptions::default();
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            let rpc_options = T::RpcOptions::default();
            self._balance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            let rpc_options = T::RpcOptions::default();
            self._leaderBalance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            let rpc_options = T::RpcOptions::default();
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> MetaServiceExt<T> for MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            self._multiPut_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            self._multiGet_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            self._scan_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            self._balance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            self._leaderBalance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> MetaService for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::marker::Send,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            self.as_ref().createSpace(
                arg_req,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            self.as_ref().dropSpace(
                arg_req,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            self.as_ref().getSpace(
                arg_req,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            self.as_ref().listSpaces(
                arg_req,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            self.as_ref().createTag(
                arg_req,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            self.as_ref().alterTag(
                arg_req,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            self.as_ref().dropTag(
                arg_req,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            self.as_ref().getTag(
                arg_req,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            self.as_ref().listTags(
                arg_req,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            self.as_ref().createEdge(
                arg_req,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            self.as_ref().alterEdge(
                arg_req,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            self.as_ref().dropEdge(
                arg_req,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            self.as_ref().getEdge(
                arg_req,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            self.as_ref().listEdges(
                arg_req,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            self.as_ref().listHosts(
                arg_req,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            self.as_ref().getPartsAlloc(
                arg_req,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            self.as_ref().listParts(
                arg_req,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            self.as_ref().multiPut(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            self.as_ref().multiGet(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            self.as_ref().scan(
                arg_req,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            self.as_ref().createTagIndex(
                arg_req,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            self.as_ref().dropTagIndex(
                arg_req,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            self.as_ref().getTagIndex(
                arg_req,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            self.as_ref().listTagIndexes(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            self.as_ref().listTagIndexStatus(
                arg_req,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            self.as_ref().createEdgeIndex(
                arg_req,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            self.as_ref().dropEdgeIndex(
                arg_req,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            self.as_ref().getEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            self.as_ref().listEdgeIndexes(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            self.as_ref().listEdgeIndexStatus(
                arg_req,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            self.as_ref().createUser(
                arg_req,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            self.as_ref().dropUser(
                arg_req,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            self.as_ref().alterUser(
                arg_req,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            self.as_ref().grantRole(
                arg_req,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            self.as_ref().revokeRole(
                arg_req,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            self.as_ref().listUsers(
                arg_req,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            self.as_ref().listRoles(
                arg_req,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            self.as_ref().getUserRoles(
                arg_req,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            self.as_ref().changePassword(
                arg_req,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            self.as_ref().heartBeat(
                arg_req,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            self.as_ref().balance(
                arg_req,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            self.as_ref().leaderBalance(
                arg_req,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            self.as_ref().regConfig(
                arg_req,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            self.as_ref().getConfig(
                arg_req,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            self.as_ref().setConfig(
                arg_req,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            self.as_ref().listConfigs(
                arg_req,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            self.as_ref().createSnapshot(
                arg_req,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            self.as_ref().dropSnapshot(
                arg_req,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            self.as_ref().listSnapshots(
                arg_req,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            self.as_ref().runAdminJob(
                arg_req,
            )
        }
    }

    impl<'a, S, T> MetaServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::convert::AsRef<dyn MetaServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSpaces_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTags_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listHosts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getPartsAlloc_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listParts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).multiPut_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).get_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).multiGet_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).remove_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeRange_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).scan_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).grantRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).revokeRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listUsers_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getUserRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).changePassword_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).heartBeat_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).balance_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).leaderBalance_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).regConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).setConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listConfigs_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSnapshots_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).runAdminJob_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_MetaService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn MetaService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn MetaServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type MetaServiceDynClient = <make_MetaService as ::fbthrift::ClientFactory>::Api;
    pub type MetaServiceClient = ::std::sync::Arc<MetaServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_MetaService {
        type Api = dyn MetaService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn MetaService>::with_spawner(protocol, transport, spawner)
        }
    }

}

/// Server definitions for `meta`.
pub mod server {
    #[::async_trait::async_trait]
    pub trait MetaService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn createSpace(
            &self,
            _req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpace",
                ),
            ))
        }
        async fn dropSpace(
            &self,
            _req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSpace",
                ),
            ))
        }
        async fn getSpace(
            &self,
            _req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSpace",
                ),
            ))
        }
        async fn listSpaces(
            &self,
            _req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSpaces",
                ),
            ))
        }
        async fn createTag(
            &self,
            _req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTag",
                ),
            ))
        }
        async fn alterTag(
            &self,
            _req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterTag",
                ),
            ))
        }
        async fn dropTag(
            &self,
            _req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTag",
                ),
            ))
        }
        async fn getTag(
            &self,
            _req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTag",
                ),
            ))
        }
        async fn listTags(
            &self,
            _req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTags",
                ),
            ))
        }
        async fn createEdge(
            &self,
            _req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdge",
                ),
            ))
        }
        async fn alterEdge(
            &self,
            _req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterEdge",
                ),
            ))
        }
        async fn dropEdge(
            &self,
            _req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdge",
                ),
            ))
        }
        async fn getEdge(
            &self,
            _req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdge",
                ),
            ))
        }
        async fn listEdges(
            &self,
            _req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdges",
                ),
            ))
        }
        async fn listHosts(
            &self,
            _req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listHosts",
                ),
            ))
        }
        async fn getPartsAlloc(
            &self,
            _req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getPartsAlloc",
                ),
            ))
        }
        async fn listParts(
            &self,
            _req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listParts",
                ),
            ))
        }
        async fn multiPut(
            &self,
            _req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiPut",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "get",
                ),
            ))
        }
        async fn multiGet(
            &self,
            _req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiGet",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeRange",
                ),
            ))
        }
        async fn scan(
            &self,
            _req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "scan",
                ),
            ))
        }
        async fn createTagIndex(
            &self,
            _req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTagIndex",
                ),
            ))
        }
        async fn dropTagIndex(
            &self,
            _req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTagIndex",
                ),
            ))
        }
        async fn getTagIndex(
            &self,
            _req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTagIndex",
                ),
            ))
        }
        async fn listTagIndexes(
            &self,
            _req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexes",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn listTagIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexStatus",
                ),
            ))
        }
        async fn createEdgeIndex(
            &self,
            _req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdgeIndex",
                ),
            ))
        }
        async fn dropEdgeIndex(
            &self,
            _req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdgeIndex",
                ),
            ))
        }
        async fn getEdgeIndex(
            &self,
            _req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexes(
            &self,
            _req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexes",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexStatus",
                ),
            ))
        }
        async fn createUser(
            &self,
            _req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createUser",
                ),
            ))
        }
        async fn dropUser(
            &self,
            _req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropUser",
                ),
            ))
        }
        async fn alterUser(
            &self,
            _req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterUser",
                ),
            ))
        }
        async fn grantRole(
            &self,
            _req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "grantRole",
                ),
            ))
        }
        async fn revokeRole(
            &self,
            _req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "revokeRole",
                ),
            ))
        }
        async fn listUsers(
            &self,
            _req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listUsers",
                ),
            ))
        }
        async fn listRoles(
            &self,
            _req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listRoles",
                ),
            ))
        }
        async fn getUserRoles(
            &self,
            _req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getUserRoles",
                ),
            ))
        }
        async fn changePassword(
            &self,
            _req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "changePassword",
                ),
            ))
        }
        async fn heartBeat(
            &self,
            _req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "heartBeat",
                ),
            ))
        }
        async fn balance(
            &self,
            _req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "balance",
                ),
            ))
        }
        async fn leaderBalance(
            &self,
            _req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "leaderBalance",
                ),
            ))
        }
        async fn regConfig(
            &self,
            _req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "regConfig",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getConfig",
                ),
            ))
        }
        async fn setConfig(
            &self,
            _req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "setConfig",
                ),
            ))
        }
        async fn listConfigs(
            &self,
            _req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listConfigs",
                ),
            ))
        }
        async fn createSnapshot(
            &self,
            _req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSnapshot",
                ),
            ))
        }
        async fn dropSnapshot(
            &self,
            _req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSnapshot",
                ),
            ))
        }
        async fn listSnapshots(
            &self,
            _req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSnapshots",
                ),
            ))
        }
        async fn runAdminJob(
            &self,
            _req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "runAdminJob",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> MetaService for ::std::boxed::Box<T>
    where
        T: MetaService + Send + Sync + ?Sized,
    {
        async fn createSpace(
            &self,
            req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            (**self).createSpace(
                req,
            ).await
        }
        async fn dropSpace(
            &self,
            req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            (**self).dropSpace(
                req,
            ).await
        }
        async fn getSpace(
            &self,
            req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            (**self).getSpace(
                req,
            ).await
        }
        async fn listSpaces(
            &self,
            req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            (**self).listSpaces(
                req,
            ).await
        }
        async fn createTag(
            &self,
            req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            (**self).createTag(
                req,
            ).await
        }
        async fn alterTag(
            &self,
            req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            (**self).alterTag(
                req,
            ).await
        }
        async fn dropTag(
            &self,
            req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            (**self).dropTag(
                req,
            ).await
        }
        async fn getTag(
            &self,
            req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            (**self).getTag(
                req,
            ).await
        }
        async fn listTags(
            &self,
            req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            (**self).listTags(
                req,
            ).await
        }
        async fn createEdge(
            &self,
            req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            (**self).createEdge(
                req,
            ).await
        }
        async fn alterEdge(
            &self,
            req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            (**self).alterEdge(
                req,
            ).await
        }
        async fn dropEdge(
            &self,
            req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            (**self).dropEdge(
                req,
            ).await
        }
        async fn getEdge(
            &self,
            req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            (**self).getEdge(
                req,
            ).await
        }
        async fn listEdges(
            &self,
            req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            (**self).listEdges(
                req,
            ).await
        }
        async fn listHosts(
            &self,
            req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            (**self).listHosts(
                req,
            ).await
        }
        async fn getPartsAlloc(
            &self,
            req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            (**self).getPartsAlloc(
                req,
            ).await
        }
        async fn listParts(
            &self,
            req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            (**self).listParts(
                req,
            ).await
        }
        async fn multiPut(
            &self,
            req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            (**self).multiPut(
                req,
            ).await
        }
        async fn get(
            &self,
            req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            (**self).get(
                req,
            ).await
        }
        async fn multiGet(
            &self,
            req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            (**self).multiGet(
                req,
            ).await
        }
        async fn remove(
            &self,
            req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            (**self).remove(
                req,
            ).await
        }
        async fn removeRange(
            &self,
            req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            (**self).removeRange(
                req,
            ).await
        }
        async fn scan(
            &self,
            req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            (**self).scan(
                req,
            ).await
        }
        async fn createTagIndex(
            &self,
            req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            (**self).createTagIndex(
                req,
            ).await
        }
        async fn dropTagIndex(
            &self,
            req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            (**self).dropTagIndex(
                req,
            ).await
        }
        async fn getTagIndex(
            &self,
            req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            (**self).getTagIndex(
                req,
            ).await
        }
        async fn listTagIndexes(
            &self,
            req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            (**self).listTagIndexes(
                req,
            ).await
        }
        async fn rebuildTagIndex(
            &self,
            req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            (**self).rebuildTagIndex(
                req,
            ).await
        }
        async fn listTagIndexStatus(
            &self,
            req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            (**self).listTagIndexStatus(
                req,
            ).await
        }
        async fn createEdgeIndex(
            &self,
            req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            (**self).createEdgeIndex(
                req,
            ).await
        }
        async fn dropEdgeIndex(
            &self,
            req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            (**self).dropEdgeIndex(
                req,
            ).await
        }
        async fn getEdgeIndex(
            &self,
            req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            (**self).getEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexes(
            &self,
            req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            (**self).listEdgeIndexes(
                req,
            ).await
        }
        async fn rebuildEdgeIndex(
            &self,
            req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            (**self).rebuildEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexStatus(
            &self,
            req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            (**self).listEdgeIndexStatus(
                req,
            ).await
        }
        async fn createUser(
            &self,
            req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            (**self).createUser(
                req,
            ).await
        }
        async fn dropUser(
            &self,
            req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            (**self).dropUser(
                req,
            ).await
        }
        async fn alterUser(
            &self,
            req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            (**self).alterUser(
                req,
            ).await
        }
        async fn grantRole(
            &self,
            req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            (**self).grantRole(
                req,
            ).await
        }
        async fn revokeRole(
            &self,
            req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            (**self).revokeRole(
                req,
            ).await
        }
        async fn listUsers(
            &self,
            req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            (**self).listUsers(
                req,
            ).await
        }
        async fn listRoles(
            &self,
            req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            (**self).listRoles(
                req,
            ).await
        }
        async fn getUserRoles(
            &self,
            req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            (**self).getUserRoles(
                req,
            ).await
        }
        async fn changePassword(
            &self,
            req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            (**self).changePassword(
                req,
            ).await
        }
        async fn heartBeat(
            &self,
            req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            (**self).heartBeat(
                req,
            ).await
        }
        async fn balance(
            &self,
            req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            (**self).balance(
                req,
            ).await
        }
        async fn leaderBalance(
            &self,
            req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            (**self).leaderBalance(
                req,
            ).await
        }
        async fn regConfig(
            &self,
            req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            (**self).regConfig(
                req,
            ).await
        }
        async fn getConfig(
            &self,
            req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            (**self).getConfig(
                req,
            ).await
        }
        async fn setConfig(
            &self,
            req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            (**self).setConfig(
                req,
            ).await
        }
        async fn listConfigs(
            &self,
            req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            (**self).listConfigs(
                req,
            ).await
        }
        async fn createSnapshot(
            &self,
            req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            (**self).createSnapshot(
                req,
            ).await
        }
        async fn dropSnapshot(
            &self,
            req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            (**self).dropSnapshot(
                req,
            ).await
        }
        async fn listSnapshots(
            &self,
            req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            (**self).listSnapshots(
                req,
            ).await
        }
        async fn runAdminJob(
            &self,
            req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            (**self).runAdminJob(
                req,
            ).await
        }
    }

    /// Processor for MetaService's methods.
    #[derive(Clone, Debug)]
    pub struct MetaServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_MetaService_createSpace {
        req: crate::types::CreateSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSpace {
        req: crate::types::DropSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSpace {
        req: crate::types::GetSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSpaces {
        req: crate::types::ListSpacesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listSpaces {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSpaces"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSpaces", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTag {
        req: crate::types::CreateTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterTag {
        req: crate::types::AlterTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTag {
        req: crate::types::DropTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTag {
        req: crate::types::GetTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTags {
        req: crate::types::ListTagsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTags {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTags"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTags", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdge {
        req: crate::types::CreateEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterEdge {
        req: crate::types::AlterEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdge {
        req: crate::types::DropEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdge {
        req: crate::types::GetEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdges {
        req: crate::types::ListEdgesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdges", "req"))?,
            })
        }
    }

    struct Args_MetaService_listHosts {
        req: crate::types::ListHostsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listHosts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listHosts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listHosts", "req"))?,
            })
        }
    }

    struct Args_MetaService_getPartsAlloc {
        req: crate::types::GetPartsAllocReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getPartsAlloc {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getPartsAlloc", "req"))?,
            })
        }
    }

    struct Args_MetaService_listParts {
        req: crate::types::ListPartsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listParts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listParts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listParts", "req"))?,
            })
        }
    }

    struct Args_MetaService_multiPut {
        req: crate::types::MultiPutReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_multiPut {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.multiPut"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.multiPut", "req"))?,
            })
        }
    }

    struct Args_MetaService_get {
        req: crate::types::GetReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_get {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.get"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.get", "req"))?,
            })
        }
    }

    struct Args_MetaService_multiGet {
        req: crate::types::MultiGetReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_multiGet {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.multiGet"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.multiGet", "req"))?,
            })
        }
    }

    struct Args_MetaService_remove {
        req: crate::types::RemoveReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_remove {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.remove"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.remove", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeRange {
        req: crate::types::RemoveRangeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_removeRange {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeRange"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeRange", "req"))?,
            })
        }
    }

    struct Args_MetaService_scan {
        req: crate::types::ScanReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_scan {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.scan"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.scan", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTagIndex {
        req: crate::types::CreateTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTagIndex {
        req: crate::types::DropTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTagIndex {
        req: crate::types::GetTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexes {
        req: crate::types::ListTagIndexesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildTagIndex {
        req: crate::types::RebuildIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexStatus {
        req: crate::types::ListIndexStatusReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdgeIndex {
        req: crate::types::CreateEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdgeIndex {
        req: crate::types::DropEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdgeIndex {
        req: crate::types::GetEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexes {
        req: crate::types::ListEdgeIndexesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildEdgeIndex {
        req: crate::types::RebuildIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexStatus {
        req: crate::types::ListIndexStatusReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createUser {
        req: crate::types::CreateUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropUser {
        req: crate::types::DropUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterUser {
        req: crate::types::AlterUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_grantRole {
        req: crate::types::GrantRoleReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_grantRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.grantRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.grantRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_revokeRole {
        req: crate::types::RevokeRoleReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_revokeRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.revokeRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.revokeRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_listUsers {
        req: crate::types::ListUsersReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listUsers {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listUsers"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listUsers", "req"))?,
            })
        }
    }

    struct Args_MetaService_listRoles {
        req: crate::types::ListRolesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_getUserRoles {
        req: crate::types::GetUserRolesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getUserRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getUserRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getUserRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_changePassword {
        req: crate::types::ChangePasswordReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_changePassword {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.changePassword"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.changePassword", "req"))?,
            })
        }
    }

    struct Args_MetaService_heartBeat {
        req: crate::types::HBReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_heartBeat {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.heartBeat"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.heartBeat", "req"))?,
            })
        }
    }

    struct Args_MetaService_balance {
        req: crate::types::BalanceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_balance {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.balance"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.balance", "req"))?,
            })
        }
    }

    struct Args_MetaService_leaderBalance {
        req: crate::types::LeaderBalanceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_leaderBalance {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.leaderBalance"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.leaderBalance", "req"))?,
            })
        }
    }

    struct Args_MetaService_regConfig {
        req: crate::types::RegConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_regConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.regConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.regConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_getConfig {
        req: crate::types::GetConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_setConfig {
        req: crate::types::SetConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_setConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.setConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.setConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_listConfigs {
        req: crate::types::ListConfigsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listConfigs {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listConfigs"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listConfigs", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSnapshot {
        req: crate::types::CreateSnapshotReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSnapshot {
        req: crate::types::DropSnapshotReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSnapshots {
        req: crate::types::ListSnapshotsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listSnapshots {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSnapshots"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSnapshots", "req"))?,
            })
        }
    }

    struct Args_MetaService_runAdminJob {
        req: crate::types::AdminJobReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_runAdminJob {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.runAdminJob"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.runAdminJob", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSpace"))]
        async fn handle_createSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSpace", exn);
                    crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSpace"))]
        async fn handle_dropSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropSpace", exn);
                    crate::services::meta_service::DropSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSpace"))]
        async fn handle_getSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getSpace", exn);
                    crate::services::meta_service::GetSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSpaces"))]
        async fn handle_listSpaces<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSpaces = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSpaces(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListSpacesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSpaces",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listSpaces", exn);
                    crate::services::meta_service::ListSpacesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSpaces",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTag"))]
        async fn handle_createTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createTag", exn);
                    crate::services::meta_service::CreateTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterTag"))]
        async fn handle_alterTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterTag", exn);
                    crate::services::meta_service::AlterTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTag"))]
        async fn handle_dropTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropTag", exn);
                    crate::services::meta_service::DropTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTag"))]
        async fn handle_getTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getTag", exn);
                    crate::services::meta_service::GetTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTags"))]
        async fn handle_listTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTags = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTags(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTags",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTags", exn);
                    crate::services::meta_service::ListTagsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTags",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdge"))]
        async fn handle_createEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createEdge", exn);
                    crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterEdge"))]
        async fn handle_alterEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterEdge", exn);
                    crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdge"))]
        async fn handle_dropEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropEdge", exn);
                    crate::services::meta_service::DropEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdge"))]
        async fn handle_getEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getEdge", exn);
                    crate::services::meta_service::GetEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdges"))]
        async fn handle_listEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdges", exn);
                    crate::services::meta_service::ListEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listHosts"))]
        async fn handle_listHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listHosts = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listHosts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListHostsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListHostsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listHosts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listHosts", exn);
                    crate::services::meta_service::ListHostsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listHosts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getPartsAlloc"))]
        async fn handle_getPartsAlloc<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getPartsAlloc = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getPartsAlloc(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetPartsAllocExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPartsAlloc",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getPartsAlloc", exn);
                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getPartsAlloc",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listParts"))]
        async fn handle_listParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listParts = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listParts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListPartsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListPartsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listParts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listParts", exn);
                    crate::services::meta_service::ListPartsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listParts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.multiPut"))]
        async fn handle_multiPut<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_multiPut = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.multiPut(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::MultiPutExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::MultiPutExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiPut",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.multiPut", exn);
                    crate::services::meta_service::MultiPutExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "multiPut",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.get"))]
        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_get = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.get(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.get", exn);
                    crate::services::meta_service::GetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "get",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.multiGet"))]
        async fn handle_multiGet<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_multiGet = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.multiGet(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::MultiGetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::MultiGetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiGet",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.multiGet", exn);
                    crate::services::meta_service::MultiGetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "multiGet",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.remove"))]
        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_remove = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.remove(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.remove", exn);
                    crate::services::meta_service::RemoveExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "remove",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeRange"))]
        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeRange = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeRange(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.removeRange", exn);
                    crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeRange",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.scan"))]
        async fn handle_scan<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_scan = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scan(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ScanExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ScanExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scan",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.scan", exn);
                    crate::services::meta_service::ScanExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scan",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTagIndex"))]
        async fn handle_createTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createTagIndex", exn);
                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTagIndex"))]
        async fn handle_dropTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropTagIndex", exn);
                    crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTagIndex"))]
        async fn handle_getTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getTagIndex", exn);
                    crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexes"))]
        async fn handle_listTagIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexes = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexes", exn);
                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildTagIndex"))]
        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.rebuildTagIndex", exn);
                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexStatus"))]
        async fn handle_listTagIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexStatus = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexStatus", exn);
                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdgeIndex"))]
        async fn handle_createEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createEdgeIndex", exn);
                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdgeIndex"))]
        async fn handle_dropEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropEdgeIndex", exn);
                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdgeIndex"))]
        async fn handle_getEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getEdgeIndex", exn);
                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexes"))]
        async fn handle_listEdgeIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexes = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexes", exn);
                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildEdgeIndex"))]
        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.rebuildEdgeIndex", exn);
                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexStatus"))]
        async fn handle_listEdgeIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexStatus = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexStatus", exn);
                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createUser"))]
        async fn handle_createUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createUser", exn);
                    crate::services::meta_service::CreateUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropUser"))]
        async fn handle_dropUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropUser", exn);
                    crate::services::meta_service::DropUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterUser"))]
        async fn handle_alterUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterUser", exn);
                    crate::services::meta_service::AlterUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.grantRole"))]
        async fn handle_grantRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_grantRole = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.grantRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GrantRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "grantRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.grantRole", exn);
                    crate::services::meta_service::GrantRoleExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "grantRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.revokeRole"))]
        async fn handle_revokeRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_revokeRole = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.revokeRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RevokeRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "revokeRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.revokeRole", exn);
                    crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "revokeRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listUsers"))]
        async fn handle_listUsers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listUsers = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listUsers(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListUsersExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListUsersExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listUsers",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listUsers", exn);
                    crate::services::meta_service::ListUsersExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listUsers",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listRoles"))]
        async fn handle_listRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listRoles = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listRoles", exn);
                    crate::services::meta_service::ListRolesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getUserRoles"))]
        async fn handle_getUserRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getUserRoles = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getUserRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetUserRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUserRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getUserRoles", exn);
                    crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getUserRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.changePassword"))]
        async fn handle_changePassword<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_changePassword = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.changePassword(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ChangePasswordExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "changePassword",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.changePassword", exn);
                    crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "changePassword",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.heartBeat"))]
        async fn handle_heartBeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_heartBeat = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.heartBeat(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::HeartBeatExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "heartBeat",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.heartBeat", exn);
                    crate::services::meta_service::HeartBeatExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "heartBeat",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.balance"))]
        async fn handle_balance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_balance = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.balance(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::BalanceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::BalanceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "balance",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.balance", exn);
                    crate::services::meta_service::BalanceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "balance",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.leaderBalance"))]
        async fn handle_leaderBalance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_leaderBalance = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.leaderBalance(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::LeaderBalanceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "leaderBalance",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.leaderBalance", exn);
                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "leaderBalance",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.regConfig"))]
        async fn handle_regConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_regConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.regConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RegConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RegConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "regConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.regConfig", exn);
                    crate::services::meta_service::RegConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "regConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getConfig"))]
        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getConfig", exn);
                    crate::services::meta_service::GetConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.setConfig"))]
        async fn handle_setConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_setConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.setConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::SetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::SetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.setConfig", exn);
                    crate::services::meta_service::SetConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "setConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listConfigs"))]
        async fn handle_listConfigs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listConfigs = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listConfigs(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListConfigsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listConfigs",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listConfigs", exn);
                    crate::services::meta_service::ListConfigsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listConfigs",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSnapshot"))]
        async fn handle_createSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSnapshot = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSnapshot", exn);
                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSnapshot"))]
        async fn handle_dropSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSnapshot = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropSnapshot", exn);
                    crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSnapshots"))]
        async fn handle_listSnapshots<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSnapshots = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSnapshots(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListSnapshotsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSnapshots",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listSnapshots", exn);
                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSnapshots",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.runAdminJob"))]
        async fn handle_runAdminJob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_runAdminJob = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.runAdminJob(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RunAdminJobExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "runAdminJob",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.runAdminJob", exn);
                    crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "runAdminJob",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"createSpace" => ::std::result::Result::Ok(0usize),
                b"dropSpace" => ::std::result::Result::Ok(1usize),
                b"getSpace" => ::std::result::Result::Ok(2usize),
                b"listSpaces" => ::std::result::Result::Ok(3usize),
                b"createTag" => ::std::result::Result::Ok(4usize),
                b"alterTag" => ::std::result::Result::Ok(5usize),
                b"dropTag" => ::std::result::Result::Ok(6usize),
                b"getTag" => ::std::result::Result::Ok(7usize),
                b"listTags" => ::std::result::Result::Ok(8usize),
                b"createEdge" => ::std::result::Result::Ok(9usize),
                b"alterEdge" => ::std::result::Result::Ok(10usize),
                b"dropEdge" => ::std::result::Result::Ok(11usize),
                b"getEdge" => ::std::result::Result::Ok(12usize),
                b"listEdges" => ::std::result::Result::Ok(13usize),
                b"listHosts" => ::std::result::Result::Ok(14usize),
                b"getPartsAlloc" => ::std::result::Result::Ok(15usize),
                b"listParts" => ::std::result::Result::Ok(16usize),
                b"multiPut" => ::std::result::Result::Ok(17usize),
                b"get" => ::std::result::Result::Ok(18usize),
                b"multiGet" => ::std::result::Result::Ok(19usize),
                b"remove" => ::std::result::Result::Ok(20usize),
                b"removeRange" => ::std::result::Result::Ok(21usize),
                b"scan" => ::std::result::Result::Ok(22usize),
                b"createTagIndex" => ::std::result::Result::Ok(23usize),
                b"dropTagIndex" => ::std::result::Result::Ok(24usize),
                b"getTagIndex" => ::std::result::Result::Ok(25usize),
                b"listTagIndexes" => ::std::result::Result::Ok(26usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(27usize),
                b"listTagIndexStatus" => ::std::result::Result::Ok(28usize),
                b"createEdgeIndex" => ::std::result::Result::Ok(29usize),
                b"dropEdgeIndex" => ::std::result::Result::Ok(30usize),
                b"getEdgeIndex" => ::std::result::Result::Ok(31usize),
                b"listEdgeIndexes" => ::std::result::Result::Ok(32usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(33usize),
                b"listEdgeIndexStatus" => ::std::result::Result::Ok(34usize),
                b"createUser" => ::std::result::Result::Ok(35usize),
                b"dropUser" => ::std::result::Result::Ok(36usize),
                b"alterUser" => ::std::result::Result::Ok(37usize),
                b"grantRole" => ::std::result::Result::Ok(38usize),
                b"revokeRole" => ::std::result::Result::Ok(39usize),
                b"listUsers" => ::std::result::Result::Ok(40usize),
                b"listRoles" => ::std::result::Result::Ok(41usize),
                b"getUserRoles" => ::std::result::Result::Ok(42usize),
                b"changePassword" => ::std::result::Result::Ok(43usize),
                b"heartBeat" => ::std::result::Result::Ok(44usize),
                b"balance" => ::std::result::Result::Ok(45usize),
                b"leaderBalance" => ::std::result::Result::Ok(46usize),
                b"regConfig" => ::std::result::Result::Ok(47usize),
                b"getConfig" => ::std::result::Result::Ok(48usize),
                b"setConfig" => ::std::result::Result::Ok(49usize),
                b"listConfigs" => ::std::result::Result::Ok(50usize),
                b"createSnapshot" => ::std::result::Result::Ok(51usize),
                b"dropSnapshot" => ::std::result::Result::Ok(52usize),
                b"listSnapshots" => ::std::result::Result::Ok(53usize),
                b"runAdminJob" => ::std::result::Result::Ok(54usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_createSpace(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_dropSpace(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_getSpace(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_listSpaces(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_createTag(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_alterTag(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_dropTag(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_getTag(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_listTags(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_createEdge(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_alterEdge(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_dropEdge(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_getEdge(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_listEdges(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_listHosts(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_getPartsAlloc(_p, _r, _reply_state, _seqid).await
                }
                16usize => {
                    self.handle_listParts(_p, _r, _reply_state, _seqid).await
                }
                17usize => {
                    self.handle_multiPut(_p, _r, _reply_state, _seqid).await
                }
                18usize => {
                    self.handle_get(_p, _r, _reply_state, _seqid).await
                }
                19usize => {
                    self.handle_multiGet(_p, _r, _reply_state, _seqid).await
                }
                20usize => {
                    self.handle_remove(_p, _r, _reply_state, _seqid).await
                }
                21usize => {
                    self.handle_removeRange(_p, _r, _reply_state, _seqid).await
                }
                22usize => {
                    self.handle_scan(_p, _r, _reply_state, _seqid).await
                }
                23usize => {
                    self.handle_createTagIndex(_p, _r, _reply_state, _seqid).await
                }
                24usize => {
                    self.handle_dropTagIndex(_p, _r, _reply_state, _seqid).await
                }
                25usize => {
                    self.handle_getTagIndex(_p, _r, _reply_state, _seqid).await
                }
                26usize => {
                    self.handle_listTagIndexes(_p, _r, _reply_state, _seqid).await
                }
                27usize => {
                    self.handle_rebuildTagIndex(_p, _r, _reply_state, _seqid).await
                }
                28usize => {
                    self.handle_listTagIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                29usize => {
                    self.handle_createEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                30usize => {
                    self.handle_dropEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                31usize => {
                    self.handle_getEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                32usize => {
                    self.handle_listEdgeIndexes(_p, _r, _reply_state, _seqid).await
                }
                33usize => {
                    self.handle_rebuildEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                34usize => {
                    self.handle_listEdgeIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                35usize => {
                    self.handle_createUser(_p, _r, _reply_state, _seqid).await
                }
                36usize => {
                    self.handle_dropUser(_p, _r, _reply_state, _seqid).await
                }
                37usize => {
                    self.handle_alterUser(_p, _r, _reply_state, _seqid).await
                }
                38usize => {
                    self.handle_grantRole(_p, _r, _reply_state, _seqid).await
                }
                39usize => {
                    self.handle_revokeRole(_p, _r, _reply_state, _seqid).await
                }
                40usize => {
                    self.handle_listUsers(_p, _r, _reply_state, _seqid).await
                }
                41usize => {
                    self.handle_listRoles(_p, _r, _reply_state, _seqid).await
                }
                42usize => {
                    self.handle_getUserRoles(_p, _r, _reply_state, _seqid).await
                }
                43usize => {
                    self.handle_changePassword(_p, _r, _reply_state, _seqid).await
                }
                44usize => {
                    self.handle_heartBeat(_p, _r, _reply_state, _seqid).await
                }
                45usize => {
                    self.handle_balance(_p, _r, _reply_state, _seqid).await
                }
                46usize => {
                    self.handle_leaderBalance(_p, _r, _reply_state, _seqid).await
                }
                47usize => {
                    self.handle_regConfig(_p, _r, _reply_state, _seqid).await
                }
                48usize => {
                    self.handle_getConfig(_p, _r, _reply_state, _seqid).await
                }
                49usize => {
                    self.handle_setConfig(_p, _r, _reply_state, _seqid).await
                }
                50usize => {
                    self.handle_listConfigs(_p, _r, _reply_state, _seqid).await
                }
                51usize => {
                    self.handle_createSnapshot(_p, _r, _reply_state, _seqid).await
                }
                52usize => {
                    self.handle_dropSnapshot(_p, _r, _reply_state, _seqid).await
                }
                53usize => {
                    self.handle_listSnapshots(_p, _r, _reply_state, _seqid).await
                }
                54usize => {
                    self.handle_runAdminJob(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "MetaService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from MetaService
                "createSpace",
                "dropSpace",
                "getSpace",
                "listSpaces",
                "createTag",
                "alterTag",
                "dropTag",
                "getTag",
                "listTags",
                "createEdge",
                "alterEdge",
                "dropEdge",
                "getEdge",
                "listEdges",
                "listHosts",
                "getPartsAlloc",
                "listParts",
                "multiPut",
                "get",
                "multiGet",
                "remove",
                "removeRange",
                "scan",
                "createTagIndex",
                "dropTagIndex",
                "getTagIndex",
                "listTagIndexes",
                "rebuildTagIndex",
                "listTagIndexStatus",
                "createEdgeIndex",
                "dropEdgeIndex",
                "getEdgeIndex",
                "listEdgeIndexes",
                "rebuildEdgeIndex",
                "listEdgeIndexStatus",
                "createUser",
                "dropUser",
                "alterUser",
                "grantRole",
                "revokeRole",
                "listUsers",
                "listRoles",
                "getUserRoles",
                "changePassword",
                "heartBeat",
                "balance",
                "leaderBalance",
                "regConfig",
                "getConfig",
                "setConfig",
                "listConfigs",
                "createSnapshot",
                "dropSnapshot",
                "listSnapshots",
                "runAdminJob",
            ]
        }
    }

    /// Construct a new instance of a MetaService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_MetaService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "MetaService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct MetaService<'mock> {
        pub createSpace: r#impl::meta_service::createSpace<'mock>,
        pub dropSpace: r#impl::meta_service::dropSpace<'mock>,
        pub getSpace: r#impl::meta_service::getSpace<'mock>,
        pub listSpaces: r#impl::meta_service::listSpaces<'mock>,
        pub createTag: r#impl::meta_service::createTag<'mock>,
        pub alterTag: r#impl::meta_service::alterTag<'mock>,
        pub dropTag: r#impl::meta_service::dropTag<'mock>,
        pub getTag: r#impl::meta_service::getTag<'mock>,
        pub listTags: r#impl::meta_service::listTags<'mock>,
        pub createEdge: r#impl::meta_service::createEdge<'mock>,
        pub alterEdge: r#impl::meta_service::alterEdge<'mock>,
        pub dropEdge: r#impl::meta_service::dropEdge<'mock>,
        pub getEdge: r#impl::meta_service::getEdge<'mock>,
        pub listEdges: r#impl::meta_service::listEdges<'mock>,
        pub listHosts: r#impl::meta_service::listHosts<'mock>,
        pub getPartsAlloc: r#impl::meta_service::getPartsAlloc<'mock>,
        pub listParts: r#impl::meta_service::listParts<'mock>,
        pub multiPut: r#impl::meta_service::multiPut<'mock>,
        pub get: r#impl::meta_service::get<'mock>,
        pub multiGet: r#impl::meta_service::multiGet<'mock>,
        pub remove: r#impl::meta_service::remove<'mock>,
        pub removeRange: r#impl::meta_service::removeRange<'mock>,
        pub scan: r#impl::meta_service::scan<'mock>,
        pub createTagIndex: r#impl::meta_service::createTagIndex<'mock>,
        pub dropTagIndex: r#impl::meta_service::dropTagIndex<'mock>,
        pub getTagIndex: r#impl::meta_service::getTagIndex<'mock>,
        pub listTagIndexes: r#impl::meta_service::listTagIndexes<'mock>,
        pub rebuildTagIndex: r#impl::meta_service::rebuildTagIndex<'mock>,
        pub listTagIndexStatus: r#impl::meta_service::listTagIndexStatus<'mock>,
        pub createEdgeIndex: r#impl::meta_service::createEdgeIndex<'mock>,
        pub dropEdgeIndex: r#impl::meta_service::dropEdgeIndex<'mock>,
        pub getEdgeIndex: r#impl::meta_service::getEdgeIndex<'mock>,
        pub listEdgeIndexes: r#impl::meta_service::listEdgeIndexes<'mock>,
        pub rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex<'mock>,
        pub listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus<'mock>,
        pub createUser: r#impl::meta_service::createUser<'mock>,
        pub dropUser: r#impl::meta_service::dropUser<'mock>,
        pub alterUser: r#impl::meta_service::alterUser<'mock>,
        pub grantRole: r#impl::meta_service::grantRole<'mock>,
        pub revokeRole: r#impl::meta_service::revokeRole<'mock>,
        pub listUsers: r#impl::meta_service::listUsers<'mock>,
        pub listRoles: r#impl::meta_service::listRoles<'mock>,
        pub getUserRoles: r#impl::meta_service::getUserRoles<'mock>,
        pub changePassword: r#impl::meta_service::changePassword<'mock>,
        pub heartBeat: r#impl::meta_service::heartBeat<'mock>,
        pub balance: r#impl::meta_service::balance<'mock>,
        pub leaderBalance: r#impl::meta_service::leaderBalance<'mock>,
        pub regConfig: r#impl::meta_service::regConfig<'mock>,
        pub getConfig: r#impl::meta_service::getConfig<'mock>,
        pub setConfig: r#impl::meta_service::setConfig<'mock>,
        pub listConfigs: r#impl::meta_service::listConfigs<'mock>,
        pub createSnapshot: r#impl::meta_service::createSnapshot<'mock>,
        pub dropSnapshot: r#impl::meta_service::dropSnapshot<'mock>,
        pub listSnapshots: r#impl::meta_service::listSnapshots<'mock>,
        pub runAdminJob: r#impl::meta_service::runAdminJob<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::MetaService {
        pub fn mock<'mock>() -> MetaService<'mock> {
            MetaService {
                createSpace: r#impl::meta_service::createSpace::unimplemented(),
                dropSpace: r#impl::meta_service::dropSpace::unimplemented(),
                getSpace: r#impl::meta_service::getSpace::unimplemented(),
                listSpaces: r#impl::meta_service::listSpaces::unimplemented(),
                createTag: r#impl::meta_service::createTag::unimplemented(),
                alterTag: r#impl::meta_service::alterTag::unimplemented(),
                dropTag: r#impl::meta_service::dropTag::unimplemented(),
                getTag: r#impl::meta_service::getTag::unimplemented(),
                listTags: r#impl::meta_service::listTags::unimplemented(),
                createEdge: r#impl::meta_service::createEdge::unimplemented(),
                alterEdge: r#impl::meta_service::alterEdge::unimplemented(),
                dropEdge: r#impl::meta_service::dropEdge::unimplemented(),
                getEdge: r#impl::meta_service::getEdge::unimplemented(),
                listEdges: r#impl::meta_service::listEdges::unimplemented(),
                listHosts: r#impl::meta_service::listHosts::unimplemented(),
                getPartsAlloc: r#impl::meta_service::getPartsAlloc::unimplemented(),
                listParts: r#impl::meta_service::listParts::unimplemented(),
                multiPut: r#impl::meta_service::multiPut::unimplemented(),
                get: r#impl::meta_service::get::unimplemented(),
                multiGet: r#impl::meta_service::multiGet::unimplemented(),
                remove: r#impl::meta_service::remove::unimplemented(),
                removeRange: r#impl::meta_service::removeRange::unimplemented(),
                scan: r#impl::meta_service::scan::unimplemented(),
                createTagIndex: r#impl::meta_service::createTagIndex::unimplemented(),
                dropTagIndex: r#impl::meta_service::dropTagIndex::unimplemented(),
                getTagIndex: r#impl::meta_service::getTagIndex::unimplemented(),
                listTagIndexes: r#impl::meta_service::listTagIndexes::unimplemented(),
                rebuildTagIndex: r#impl::meta_service::rebuildTagIndex::unimplemented(),
                listTagIndexStatus: r#impl::meta_service::listTagIndexStatus::unimplemented(),
                createEdgeIndex: r#impl::meta_service::createEdgeIndex::unimplemented(),
                dropEdgeIndex: r#impl::meta_service::dropEdgeIndex::unimplemented(),
                getEdgeIndex: r#impl::meta_service::getEdgeIndex::unimplemented(),
                listEdgeIndexes: r#impl::meta_service::listEdgeIndexes::unimplemented(),
                rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex::unimplemented(),
                listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus::unimplemented(),
                createUser: r#impl::meta_service::createUser::unimplemented(),
                dropUser: r#impl::meta_service::dropUser::unimplemented(),
                alterUser: r#impl::meta_service::alterUser::unimplemented(),
                grantRole: r#impl::meta_service::grantRole::unimplemented(),
                revokeRole: r#impl::meta_service::revokeRole::unimplemented(),
                listUsers: r#impl::meta_service::listUsers::unimplemented(),
                listRoles: r#impl::meta_service::listRoles::unimplemented(),
                getUserRoles: r#impl::meta_service::getUserRoles::unimplemented(),
                changePassword: r#impl::meta_service::changePassword::unimplemented(),
                heartBeat: r#impl::meta_service::heartBeat::unimplemented(),
                balance: r#impl::meta_service::balance::unimplemented(),
                leaderBalance: r#impl::meta_service::leaderBalance::unimplemented(),
                regConfig: r#impl::meta_service::regConfig::unimplemented(),
                getConfig: r#impl::meta_service::getConfig::unimplemented(),
                setConfig: r#impl::meta_service::setConfig::unimplemented(),
                listConfigs: r#impl::meta_service::listConfigs::unimplemented(),
                createSnapshot: r#impl::meta_service::createSnapshot::unimplemented(),
                dropSnapshot: r#impl::meta_service::dropSnapshot::unimplemented(),
                listSnapshots: r#impl::meta_service::listSnapshots::unimplemented(),
                runAdminJob: r#impl::meta_service::runAdminJob::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::MetaService for MetaService<'mock> {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            let mut closure = self.createSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            let mut closure = self.dropSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            let mut closure = self.getSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            let mut closure = self.listSpaces.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            let mut closure = self.createTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            let mut closure = self.alterTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            let mut closure = self.dropTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            let mut closure = self.getTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            let mut closure = self.listTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            let mut closure = self.createEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            let mut closure = self.alterEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            let mut closure = self.dropEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            let mut closure = self.getEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            let mut closure = self.listEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            let mut closure = self.listHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            let mut closure = self.getPartsAlloc.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            let mut closure = self.listParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            let mut closure = self.multiPut.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            let mut closure = self.multiGet.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            let mut closure = self.scan.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            let mut closure = self.createTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            let mut closure = self.dropTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            let mut closure = self.getTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            let mut closure = self.listTagIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            let mut closure = self.listTagIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            let mut closure = self.createEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            let mut closure = self.dropEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            let mut closure = self.getEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            let mut closure = self.listEdgeIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            let mut closure = self.listEdgeIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            let mut closure = self.createUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            let mut closure = self.dropUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            let mut closure = self.alterUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            let mut closure = self.grantRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            let mut closure = self.revokeRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            let mut closure = self.listUsers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            let mut closure = self.listRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            let mut closure = self.getUserRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            let mut closure = self.changePassword.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            let mut closure = self.heartBeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::HBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            let mut closure = self.balance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            let mut closure = self.leaderBalance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            let mut closure = self.regConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            let mut closure = self.setConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            let mut closure = self.listConfigs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            let mut closure = self.createSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            let mut closure = self.dropSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            let mut closure = self.listSnapshots.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            let mut closure = self.runAdminJob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod meta_service {

            pub struct createSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<
                        crate::types::GetSpaceResp,
                        crate::errors::meta_service::GetSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSpaceResp) {
                    self.mock(move |_: crate::types::GetSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> crate::types::GetSpaceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSpaces<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<
                        crate::types::ListSpacesResp,
                        crate::errors::meta_service::ListSpacesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSpaces<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSpacesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSpaces",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSpacesResp) {
                    self.mock(move |_: crate::types::ListSpacesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> crate::types::ListSpacesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSpacesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSpacesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<
                        crate::types::GetTagResp,
                        crate::errors::meta_service::GetTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagResp) {
                    self.mock(move |_: crate::types::GetTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> crate::types::GetTagResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<
                        crate::types::ListTagsResp,
                        crate::errors::meta_service::ListTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTags<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagsResp) {
                    self.mock(move |_: crate::types::ListTagsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> crate::types::ListTagsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<
                        crate::types::GetEdgeResp,
                        crate::errors::meta_service::GetEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeResp) {
                    self.mock(move |_: crate::types::GetEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> crate::types::GetEdgeResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<
                        crate::types::ListEdgesResp,
                        crate::errors::meta_service::ListEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgesResp) {
                    self.mock(move |_: crate::types::ListEdgesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> crate::types::ListEdgesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<
                        crate::types::ListHostsResp,
                        crate::errors::meta_service::ListHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listHosts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListHostsResp) {
                    self.mock(move |_: crate::types::ListHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> crate::types::ListHostsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPartsAlloc<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<
                        crate::types::GetPartsAllocResp,
                        crate::errors::meta_service::GetPartsAllocError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getPartsAlloc<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPartsAllocReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getPartsAlloc",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPartsAllocResp) {
                    self.mock(move |_: crate::types::GetPartsAllocReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> crate::types::GetPartsAllocResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetPartsAllocError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPartsAllocReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<
                        crate::types::ListPartsResp,
                        crate::errors::meta_service::ListPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listParts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListPartsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListPartsResp) {
                    self.mock(move |_: crate::types::ListPartsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> crate::types::ListPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListPartsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiPut<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::MultiPutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> multiPut<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiPutReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiPut",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::MultiPutReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiPutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiPutReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<
                        crate::types::GetResp,
                        crate::errors::meta_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetResp) {
                    self.mock(move |_: crate::types::GetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> crate::types::GetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiGet<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<
                        crate::types::MultiGetResp,
                        crate::errors::meta_service::MultiGetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> multiGet<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiGetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiGet",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::MultiGetResp) {
                    self.mock(move |_: crate::types::MultiGetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> crate::types::MultiGetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiGetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiGetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveRangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scan<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<
                        crate::types::ScanResp,
                        crate::errors::meta_service::ScanError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scan<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "scan",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanResp) {
                    self.mock(move |_: crate::types::ScanReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> crate::types::ScanResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ScanError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<
                        crate::types::GetTagIndexResp,
                        crate::errors::meta_service::GetTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagIndexResp) {
                    self.mock(move |_: crate::types::GetTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> crate::types::GetTagIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<
                        crate::types::ListTagIndexesResp,
                        crate::errors::meta_service::ListTagIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagIndexesResp) {
                    self.mock(move |_: crate::types::ListTagIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> crate::types::ListTagIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListTagIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<
                        crate::types::GetEdgeIndexResp,
                        crate::errors::meta_service::GetEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeIndexResp) {
                    self.mock(move |_: crate::types::GetEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> crate::types::GetEdgeIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<
                        crate::types::ListEdgeIndexesResp,
                        crate::errors::meta_service::ListEdgeIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgeIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgeIndexesResp) {
                    self.mock(move |_: crate::types::ListEdgeIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> crate::types::ListEdgeIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgeIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListEdgeIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct grantRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::GrantRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> grantRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GrantRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "grantRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::GrantRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GrantRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GrantRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct revokeRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RevokeRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> revokeRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RevokeRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "revokeRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RevokeRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RevokeRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RevokeRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listUsers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<
                        crate::types::ListUsersResp,
                        crate::errors::meta_service::ListUsersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listUsers<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListUsersReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listUsers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListUsersResp) {
                    self.mock(move |_: crate::types::ListUsersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> crate::types::ListUsersResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListUsersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListUsersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::ListRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::ListRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUserRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::GetUserRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getUserRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUserRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getUserRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::GetUserRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetUserRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUserRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct changePassword<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ChangePasswordError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> changePassword<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChangePasswordReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "changePassword",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ChangePasswordReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ChangePasswordError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChangePasswordReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct heartBeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<
                        crate::types::HBResp,
                        crate::errors::meta_service::HeartBeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> heartBeat<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::HBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "heartBeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::HBResp) {
                    self.mock(move |_: crate::types::HBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> crate::types::HBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::HeartBeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::HBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct balance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<
                        crate::types::BalanceResp,
                        crate::errors::meta_service::BalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> balance<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "balance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::BalanceResp) {
                    self.mock(move |_: crate::types::BalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> crate::types::BalanceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::BalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct leaderBalance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::LeaderBalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> leaderBalance<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LeaderBalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "leaderBalance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::LeaderBalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::LeaderBalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LeaderBalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct regConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RegConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> regConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RegConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "regConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RegConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RegConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RegConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<
                        crate::types::GetConfigResp,
                        crate::errors::meta_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetConfigResp) {
                    self.mock(move |_: crate::types::GetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> crate::types::GetConfigResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> setConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "setConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listConfigs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<
                        crate::types::ListConfigsResp,
                        crate::errors::meta_service::ListConfigsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listConfigs<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListConfigsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listConfigs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListConfigsResp) {
                    self.mock(move |_: crate::types::ListConfigsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> crate::types::ListConfigsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListConfigsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListConfigsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSnapshots<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<
                        crate::types::ListSnapshotsResp,
                        crate::errors::meta_service::ListSnapshotsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSnapshots<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSnapshotsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSnapshots",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSnapshotsResp) {
                    self.mock(move |_: crate::types::ListSnapshotsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> crate::types::ListSnapshotsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSnapshotsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSnapshotsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct runAdminJob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<
                        crate::types::AdminJobResp,
                        crate::errors::meta_service::RunAdminJobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> runAdminJob<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AdminJobReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "runAdminJob",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminJobResp) {
                    self.mock(move |_: crate::types::AdminJobReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> crate::types::AdminJobResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RunAdminJobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AdminJobReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for MetaService functions.
    pub mod meta_service {

        pub type CreateSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSpaceExn> for
            ::std::result::Result<crate::types::ExecResp, CreateSpaceError>
        {
            fn from(e: crate::services::meta_service::CreateSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropSpaceExn> for
            ::std::result::Result<crate::types::ExecResp, DropSpaceError>
        {
            fn from(e: crate::services::meta_service::DropSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::DropSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetSpaceExn> for
            ::std::result::Result<crate::types::GetSpaceResp, GetSpaceError>
        {
            fn from(e: crate::services::meta_service::GetSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::GetSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSpacesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListSpacesExn> for
            ::std::result::Result<crate::types::ListSpacesResp, ListSpacesError>
        {
            fn from(e: crate::services::meta_service::ListSpacesExn) -> Self {
                match e {
                    crate::services::meta_service::ListSpacesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListSpacesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSpacesError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateTagExn> for
            ::std::result::Result<crate::types::ExecResp, CreateTagError>
        {
            fn from(e: crate::services::meta_service::CreateTagExn) -> Self {
                match e {
                    crate::services::meta_service::CreateTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterTagExn> for
            ::std::result::Result<crate::types::ExecResp, AlterTagError>
        {
            fn from(e: crate::services::meta_service::AlterTagExn) -> Self {
                match e {
                    crate::services::meta_service::AlterTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropTagExn> for
            ::std::result::Result<crate::types::ExecResp, DropTagError>
        {
            fn from(e: crate::services::meta_service::DropTagExn) -> Self {
                match e {
                    crate::services::meta_service::DropTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetTagExn> for
            ::std::result::Result<crate::types::GetTagResp, GetTagError>
        {
            fn from(e: crate::services::meta_service::GetTagExn) -> Self {
                match e {
                    crate::services::meta_service::GetTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagsExn> for
            ::std::result::Result<crate::types::ListTagsResp, ListTagsError>
        {
            fn from(e: crate::services::meta_service::ListTagsExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, CreateEdgeError>
        {
            fn from(e: crate::services::meta_service::CreateEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::CreateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, AlterEdgeError>
        {
            fn from(e: crate::services::meta_service::AlterEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::AlterEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, DropEdgeError>
        {
            fn from(e: crate::services::meta_service::DropEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::DropEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetEdgeExn> for
            ::std::result::Result<crate::types::GetEdgeResp, GetEdgeError>
        {
            fn from(e: crate::services::meta_service::GetEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::GetEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgesExn> for
            ::std::result::Result<crate::types::ListEdgesResp, ListEdgesError>
        {
            fn from(e: crate::services::meta_service::ListEdgesExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListHostsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListHostsExn> for
            ::std::result::Result<crate::types::ListHostsResp, ListHostsError>
        {
            fn from(e: crate::services::meta_service::ListHostsExn) -> Self {
                match e {
                    crate::services::meta_service::ListHostsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListHostsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListHostsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetPartsAllocError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetPartsAllocExn> for
            ::std::result::Result<crate::types::GetPartsAllocResp, GetPartsAllocError>
        {
            fn from(e: crate::services::meta_service::GetPartsAllocExn) -> Self {
                match e {
                    crate::services::meta_service::GetPartsAllocExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPartsAllocError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListPartsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListPartsExn> for
            ::std::result::Result<crate::types::ListPartsResp, ListPartsError>
        {
            fn from(e: crate::services::meta_service::ListPartsExn) -> Self {
                match e {
                    crate::services::meta_service::ListPartsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListPartsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListPartsError::ApplicationException(aexn)),
                }
            }
        }

        pub type MultiPutError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::MultiPutExn> for
            ::std::result::Result<crate::types::ExecResp, MultiPutError>
        {
            fn from(e: crate::services::meta_service::MultiPutExn) -> Self {
                match e {
                    crate::services::meta_service::MultiPutExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::MultiPutExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MultiPutError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetExn> for
            ::std::result::Result<crate::types::GetResp, GetError>
        {
            fn from(e: crate::services::meta_service::GetExn) -> Self {
                match e {
                    crate::services::meta_service::GetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetError::ApplicationException(aexn)),
                }
            }
        }

        pub type MultiGetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::MultiGetExn> for
            ::std::result::Result<crate::types::MultiGetResp, MultiGetError>
        {
            fn from(e: crate::services::meta_service::MultiGetExn) -> Self {
                match e {
                    crate::services::meta_service::MultiGetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::MultiGetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MultiGetError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveError>
        {
            fn from(e: crate::services::meta_service::RemoveExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveRangeExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveRangeError>
        {
            fn from(e: crate::services::meta_service::RemoveRangeExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveRangeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveRangeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ScanExn> for
            ::std::result::Result<crate::types::ScanResp, ScanError>
        {
            fn from(e: crate::services::meta_service::ScanExn) -> Self {
                match e {
                    crate::services::meta_service::ScanExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ScanExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, CreateTagIndexError>
        {
            fn from(e: crate::services::meta_service::CreateTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::CreateTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, DropTagIndexError>
        {
            fn from(e: crate::services::meta_service::DropTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::DropTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetTagIndexExn> for
            ::std::result::Result<crate::types::GetTagIndexResp, GetTagIndexError>
        {
            fn from(e: crate::services::meta_service::GetTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::GetTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagIndexesExn> for
            ::std::result::Result<crate::types::ListTagIndexesResp, ListTagIndexesError>
        {
            fn from(e: crate::services::meta_service::ListTagIndexesExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RebuildTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, RebuildTagIndexError>
        {
            fn from(e: crate::services::meta_service::RebuildTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::RebuildTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagIndexStatusExn> for
            ::std::result::Result<crate::types::ListIndexStatusResp, ListTagIndexStatusError>
        {
            fn from(e: crate::services::meta_service::ListTagIndexStatusExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, CreateEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::CreateEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, DropEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::DropEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::DropEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetEdgeIndexExn> for
            ::std::result::Result<crate::types::GetEdgeIndexResp, GetEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::GetEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::GetEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgeIndexesExn> for
            ::std::result::Result<crate::types::ListEdgeIndexesResp, ListEdgeIndexesError>
        {
            fn from(e: crate::services::meta_service::ListEdgeIndexesExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RebuildEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, RebuildEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::RebuildEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgeIndexStatusExn> for
            ::std::result::Result<crate::types::ListIndexStatusResp, ListEdgeIndexStatusError>
        {
            fn from(e: crate::services::meta_service::ListEdgeIndexStatusExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateUserExn> for
            ::std::result::Result<crate::types::ExecResp, CreateUserError>
        {
            fn from(e: crate::services::meta_service::CreateUserExn) -> Self {
                match e {
                    crate::services::meta_service::CreateUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropUserExn> for
            ::std::result::Result<crate::types::ExecResp, DropUserError>
        {
            fn from(e: crate::services::meta_service::DropUserExn) -> Self {
                match e {
                    crate::services::meta_service::DropUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterUserExn> for
            ::std::result::Result<crate::types::ExecResp, AlterUserError>
        {
            fn from(e: crate::services::meta_service::AlterUserExn) -> Self {
                match e {
                    crate::services::meta_service::AlterUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type GrantRoleError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GrantRoleExn> for
            ::std::result::Result<crate::types::ExecResp, GrantRoleError>
        {
            fn from(e: crate::services::meta_service::GrantRoleExn) -> Self {
                match e {
                    crate::services::meta_service::GrantRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GrantRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GrantRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type RevokeRoleError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RevokeRoleExn> for
            ::std::result::Result<crate::types::ExecResp, RevokeRoleError>
        {
            fn from(e: crate::services::meta_service::RevokeRoleExn) -> Self {
                match e {
                    crate::services::meta_service::RevokeRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RevokeRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListUsersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListUsersExn> for
            ::std::result::Result<crate::types::ListUsersResp, ListUsersError>
        {
            fn from(e: crate::services::meta_service::ListUsersExn) -> Self {
                match e {
                    crate::services::meta_service::ListUsersExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListUsersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListUsersError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListRolesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListRolesExn> for
            ::std::result::Result<crate::types::ListRolesResp, ListRolesError>
        {
            fn from(e: crate::services::meta_service::ListRolesExn) -> Self {
                match e {
                    crate::services::meta_service::ListRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetUserRolesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetUserRolesExn> for
            ::std::result::Result<crate::types::ListRolesResp, GetUserRolesError>
        {
            fn from(e: crate::services::meta_service::GetUserRolesExn) -> Self {
                match e {
                    crate::services::meta_service::GetUserRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetUserRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChangePasswordError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ChangePasswordExn> for
            ::std::result::Result<crate::types::ExecResp, ChangePasswordError>
        {
            fn from(e: crate::services::meta_service::ChangePasswordExn) -> Self {
                match e {
                    crate::services::meta_service::ChangePasswordExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChangePasswordError::ApplicationException(aexn)),
                }
            }
        }

        pub type HeartBeatError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::HeartBeatExn> for
            ::std::result::Result<crate::types::HBResp, HeartBeatError>
        {
            fn from(e: crate::services::meta_service::HeartBeatExn) -> Self {
                match e {
                    crate::services::meta_service::HeartBeatExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::HeartBeatExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(HeartBeatError::ApplicationException(aexn)),
                }
            }
        }

        pub type BalanceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::BalanceExn> for
            ::std::result::Result<crate::types::BalanceResp, BalanceError>
        {
            fn from(e: crate::services::meta_service::BalanceExn) -> Self {
                match e {
                    crate::services::meta_service::BalanceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::BalanceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(BalanceError::ApplicationException(aexn)),
                }
            }
        }

        pub type LeaderBalanceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::LeaderBalanceExn> for
            ::std::result::Result<crate::types::ExecResp, LeaderBalanceError>
        {
            fn from(e: crate::services::meta_service::LeaderBalanceExn) -> Self {
                match e {
                    crate::services::meta_service::LeaderBalanceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(LeaderBalanceError::ApplicationException(aexn)),
                }
            }
        }

        pub type RegConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RegConfigExn> for
            ::std::result::Result<crate::types::ExecResp, RegConfigError>
        {
            fn from(e: crate::services::meta_service::RegConfigExn) -> Self {
                match e {
                    crate::services::meta_service::RegConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RegConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RegConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetConfigExn> for
            ::std::result::Result<crate::types::GetConfigResp, GetConfigError>
        {
            fn from(e: crate::services::meta_service::GetConfigExn) -> Self {
                match e {
                    crate::services::meta_service::GetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type SetConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::SetConfigExn> for
            ::std::result::Result<crate::types::ExecResp, SetConfigError>
        {
            fn from(e: crate::services::meta_service::SetConfigExn) -> Self {
                match e {
                    crate::services::meta_service::SetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::SetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListConfigsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListConfigsExn> for
            ::std::result::Result<crate::types::ListConfigsResp, ListConfigsError>
        {
            fn from(e: crate::services::meta_service::ListConfigsExn) -> Self {
                match e {
                    crate::services::meta_service::ListConfigsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListConfigsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListConfigsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSnapshotError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSnapshotExn> for
            ::std::result::Result<crate::types::ExecResp, CreateSnapshotError>
        {
            fn from(e: crate::services::meta_service::CreateSnapshotExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSnapshotError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropSnapshotExn> for
            ::std::result::Result<crate::types::ExecResp, DropSnapshotError>
        {
            fn from(e: crate::services::meta_service::DropSnapshotExn) -> Self {
                match e {
                    crate::services::meta_service::DropSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSnapshotsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListSnapshotsExn> for
            ::std::result::Result<crate::types::ListSnapshotsResp, ListSnapshotsError>
        {
            fn from(e: crate::services::meta_service::ListSnapshotsExn) -> Self {
                match e {
                    crate::services::meta_service::ListSnapshotsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSnapshotsError::ApplicationException(aexn)),
                }
            }
        }

        pub type RunAdminJobError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RunAdminJobExn> for
            ::std::result::Result<crate::types::AdminJobResp, RunAdminJobError>
        {
            fn from(e: crate::services::meta_service::RunAdminJobExn) -> Self {
                match e {
                    crate::services::meta_service::RunAdminJobExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RunAdminJobError::ApplicationException(aexn)),
                }
            }
        }

    }

}
