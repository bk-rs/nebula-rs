// @generated by Thrift. This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]
#![allow(bare_trait_objects)]
#![allow(clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ID {
        space_id(common::types::GraphSpaceID),
        tag_id(common::types::TagID),
        edge_type(common::types::EdgeType),
        index_id(common::types::IndexID),
        cluster_id(common::types::ClusterID),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IdName {
        pub id: crate::types::ID,
        pub name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SpaceProperties {
        pub space_name: ::std::string::String,
        pub partition_num: ::std::primitive::i32,
        pub replica_factor: ::std::primitive::i32,
        pub charset_name: ::std::string::String,
        pub collate_name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SpaceItem {
        pub space_id: common::types::GraphSpaceID,
        pub properties: crate::types::SpaceProperties,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TagItem {
        pub tag_id: common::types::TagID,
        pub tag_name: ::std::string::String,
        pub version: common::types::SchemaVer,
        pub schema: common::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterSchemaItem {
        pub op: crate::types::AlterSchemaOp,
        pub schema: common::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdgeItem {
        pub edge_type: common::types::EdgeType,
        pub edge_name: ::std::string::String,
        pub version: common::types::SchemaVer,
        pub schema: common::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HostItem {
        pub hostAddr: common::types::HostAddr,
        pub status: crate::types::HostStatus,
        pub leader_parts: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<common::types::PartitionID>>,
        pub all_parts: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<common::types::PartitionID>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ExecResp {
        pub code: crate::types::ErrorCode,
        pub id: crate::types::ID,
        pub leader: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateSpaceReq {
        pub properties: crate::types::SpaceProperties,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropSpaceReq {
        pub space_name: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AdminJobReq {
        pub op: crate::types::AdminJobOp,
        pub paras: ::std::vec::Vec<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct JobDesc {
        pub id: ::std::primitive::i32,
        pub cmd: ::std::string::String,
        pub paras: ::std::vec::Vec<::std::string::String>,
        pub status: crate::types::JobStatus,
        pub start_time: ::std::primitive::i64,
        pub stop_time: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TaskDesc {
        pub task_id: ::std::primitive::i32,
        pub host: common::types::HostAddr,
        pub status: crate::types::JobStatus,
        pub start_time: ::std::primitive::i64,
        pub stop_time: ::std::primitive::i64,
        pub job_id: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminJobResult {
        pub job_id: ::std::option::Option<::std::primitive::i32>,
        pub job_desc: ::std::option::Option<::std::vec::Vec<crate::types::JobDesc>>,
        pub task_desc: ::std::option::Option<::std::vec::Vec<crate::types::TaskDesc>>,
        pub recovered_job_num: ::std::option::Option<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminJobResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub result: crate::types::AdminJobResult,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListSpacesReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListSpacesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub spaces: ::std::vec::Vec<crate::types::IdName>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetSpaceReq {
        pub space_name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetSpaceResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: crate::types::SpaceItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::string::String,
        pub schema: common::types::Schema,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::string::String,
        pub tag_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
        pub schema_prop: common::types::SchemaProp,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListTagsReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListTagsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub tags: ::std::vec::Vec<crate::types::TagItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::string::String,
        pub version: common::types::SchemaVer,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetTagResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub schema: common::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::string::String,
        pub schema: common::types::Schema,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::string::String,
        pub edge_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
        pub schema_prop: common::types::SchemaProp,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::string::String,
        pub version: common::types::SchemaVer,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetEdgeResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub schema: common::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListEdgesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListEdgesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub edges: ::std::vec::Vec<crate::types::EdgeItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListHostsReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListHostsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub hosts: ::std::vec::Vec<crate::types::HostItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PartItem {
        pub part_id: common::types::PartitionID,
        pub leader: ::std::option::Option<common::types::HostAddr>,
        pub peers: ::std::vec::Vec<common::types::HostAddr>,
        pub losts: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListPartsReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_ids: ::std::vec::Vec<common::types::PartitionID>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListPartsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub parts: ::std::vec::Vec<crate::types::PartItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetPartsAllocReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetPartsAllocResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::HostAddr>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MultiPutReq {
        pub segment: ::std::string::String,
        pub pairs: ::std::vec::Vec<common::types::Pair>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetReq {
        pub segment: ::std::string::String,
        pub key: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub value: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MultiGetReq {
        pub segment: ::std::string::String,
        pub keys: ::std::vec::Vec<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MultiGetResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub values: ::std::vec::Vec<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveReq {
        pub segment: ::std::string::String,
        pub key: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveRangeReq {
        pub segment: ::std::string::String,
        pub start: ::std::string::String,
        pub end: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScanReq {
        pub segment: ::std::string::String,
        pub start: ::std::string::String,
        pub end: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub values: ::std::vec::Vec<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HBResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub cluster_id: common::types::ClusterID,
        pub last_update_time_in_ms: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HBReq {
        pub in_storaged: ::std::primitive::bool,
        pub host: common::types::HostAddr,
        pub cluster_id: common::types::ClusterID,
        pub leader_partIds: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
        pub tag_name: ::std::string::String,
        pub fields: ::std::vec::Vec<::std::string::String>,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetTagIndexResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: common::types::IndexItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListTagIndexesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListTagIndexesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<common::types::IndexItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
        pub edge_name: ::std::string::String,
        pub fields: ::std::vec::Vec<::std::string::String>,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetEdgeIndexResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: common::types::IndexItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListEdgeIndexesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListEdgeIndexesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<common::types::IndexItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RebuildIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::string::String,
        pub is_offline: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateUserReq {
        pub account: ::std::string::String,
        pub encoded_pwd: ::std::string::String,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropUserReq {
        pub account: ::std::string::String,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AlterUserReq {
        pub account: ::std::string::String,
        pub encoded_pwd: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GrantRoleReq {
        pub role_item: common::types::RoleItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RevokeRoleReq {
        pub role_item: common::types::RoleItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListUsersReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListUsersResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub users: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListRolesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetUserRolesReq {
        pub account: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListRolesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub roles: ::std::vec::Vec<common::types::RoleItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ChangePasswordReq {
        pub account: ::std::string::String,
        pub new_encoded_pwd: ::std::string::String,
        pub old_encoded_pwd: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct BalanceReq {
        pub space_id: ::std::option::Option<common::types::GraphSpaceID>,
        pub id: ::std::option::Option<::std::primitive::i64>,
        pub host_del: ::std::option::Option<::std::vec::Vec<common::types::HostAddr>>,
        pub stop: ::std::option::Option<::std::primitive::bool>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct BalanceTask {
        pub id: ::std::string::String,
        pub result: crate::types::TaskResult,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct BalanceResp {
        pub code: crate::types::ErrorCode,
        pub id: ::std::primitive::i64,
        pub leader: common::types::HostAddr,
        pub tasks: ::std::vec::Vec<crate::types::BalanceTask>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LeaderBalanceReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ConfigItem {
        pub module: crate::types::ConfigModule,
        pub name: ::std::string::String,
        pub type_: crate::types::ConfigType,
        pub mode: crate::types::ConfigMode,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RegConfigReq {
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetConfigReq {
        pub item: crate::types::ConfigItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetConfigResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SetConfigReq {
        pub item: crate::types::ConfigItem,
        pub force: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListConfigsReq {
        pub space: ::std::string::String,
        pub module: crate::types::ConfigModule,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListConfigsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateSnapshotReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropSnapshotReq {
        pub name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListSnapshotsReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Snapshot {
        pub name: ::std::string::String,
        pub status: crate::types::SnapshotStatus,
        pub hosts: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListSnapshotsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub snapshots: ::std::vec::Vec<crate::types::Snapshot>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListIndexStatusReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct IndexStatus {
        pub name: ::std::string::String,
        pub status: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListIndexStatusResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub statuses: ::std::vec::Vec<crate::types::IndexStatus>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ErrorCode(pub ::std::primitive::i32);

    impl ErrorCode {
        pub const SUCCEEDED: Self = ErrorCode(0i32);
        pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
        pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
        pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
        pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
        pub const E_NO_HOSTS: Self = ErrorCode(-21i32);
        pub const E_EXISTED: Self = ErrorCode(-22i32);
        pub const E_NOT_FOUND: Self = ErrorCode(-23i32);
        pub const E_INVALID_HOST: Self = ErrorCode(-24i32);
        pub const E_UNSUPPORTED: Self = ErrorCode(-25i32);
        pub const E_NOT_DROP: Self = ErrorCode(-26i32);
        pub const E_BALANCER_RUNNING: Self = ErrorCode(-27i32);
        pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-28i32);
        pub const E_CONFLICT: Self = ErrorCode(-29i32);
        pub const E_INVALID_PARM: Self = ErrorCode(-30i32);
        pub const E_WRONGCLUSTER: Self = ErrorCode(-31i32);
        pub const E_STORE_FAILURE: Self = ErrorCode(-32i32);
        pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-33i32);
        pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-34i32);
        pub const E_BALANCED: Self = ErrorCode(-35i32);
        pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-36i32);
        pub const E_NO_VALID_HOST: Self = ErrorCode(-37i32);
        pub const E_CORRUPTTED_BALANCE_PLAN: Self = ErrorCode(-38i32);
        pub const E_INVALID_PASSWORD: Self = ErrorCode(-41i32);
        pub const E_IMPROPER_ROLE: Self = ErrorCode(-42i32);
        pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-43i32);
        pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-44i32);
        pub const E_INVALID_CHARSET: Self = ErrorCode(-45i32);
        pub const E_INVALID_COLLATE: Self = ErrorCode(-46i32);
        pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-47i32);
        pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-51i32);
        pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-52i32);
        pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-53i32);
        pub const E_INDEX_WITH_TTL: Self = ErrorCode(-54i32);
        pub const E_UNKNOWN: Self = ErrorCode(-99i32);
    }

    impl ::fbthrift::ThriftEnum for ErrorCode {
        fn enumerate() -> &'static [(ErrorCode, &'static str)] {
            &[
                (ErrorCode::SUCCEEDED, "SUCCEEDED"),
                (ErrorCode::E_DISCONNECTED, "E_DISCONNECTED"),
                (ErrorCode::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
                (ErrorCode::E_RPC_FAILURE, "E_RPC_FAILURE"),
                (ErrorCode::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
                (ErrorCode::E_NO_HOSTS, "E_NO_HOSTS"),
                (ErrorCode::E_EXISTED, "E_EXISTED"),
                (ErrorCode::E_NOT_FOUND, "E_NOT_FOUND"),
                (ErrorCode::E_INVALID_HOST, "E_INVALID_HOST"),
                (ErrorCode::E_UNSUPPORTED, "E_UNSUPPORTED"),
                (ErrorCode::E_NOT_DROP, "E_NOT_DROP"),
                (ErrorCode::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
                (ErrorCode::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
                (ErrorCode::E_CONFLICT, "E_CONFLICT"),
                (ErrorCode::E_INVALID_PARM, "E_INVALID_PARM"),
                (ErrorCode::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
                (ErrorCode::E_STORE_FAILURE, "E_STORE_FAILURE"),
                (ErrorCode::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
                (ErrorCode::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
                (ErrorCode::E_BALANCED, "E_BALANCED"),
                (ErrorCode::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
                (ErrorCode::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
                (ErrorCode::E_CORRUPTTED_BALANCE_PLAN, "E_CORRUPTTED_BALANCE_PLAN"),
                (ErrorCode::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
                (ErrorCode::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
                (ErrorCode::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
                (ErrorCode::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
                (ErrorCode::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
                (ErrorCode::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
                (ErrorCode::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
                (ErrorCode::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
                (ErrorCode::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
                (ErrorCode::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
                (ErrorCode::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
                (ErrorCode::E_UNKNOWN, "E_UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "E_DISCONNECTED",
                "E_FAIL_TO_CONNECT",
                "E_RPC_FAILURE",
                "E_LEADER_CHANGED",
                "E_NO_HOSTS",
                "E_EXISTED",
                "E_NOT_FOUND",
                "E_INVALID_HOST",
                "E_UNSUPPORTED",
                "E_NOT_DROP",
                "E_BALANCER_RUNNING",
                "E_CONFIG_IMMUTABLE",
                "E_CONFLICT",
                "E_INVALID_PARM",
                "E_WRONGCLUSTER",
                "E_STORE_FAILURE",
                "E_STORE_SEGMENT_ILLEGAL",
                "E_BAD_BALANCE_PLAN",
                "E_BALANCED",
                "E_NO_RUNNING_BALANCE_PLAN",
                "E_NO_VALID_HOST",
                "E_CORRUPTTED_BALANCE_PLAN",
                "E_INVALID_PASSWORD",
                "E_IMPROPER_ROLE",
                "E_INVALID_PARTITION_NUM",
                "E_INVALID_REPLICA_FACTOR",
                "E_INVALID_CHARSET",
                "E_INVALID_COLLATE",
                "E_CHARSET_COLLATE_NOT_MATCH",
                "E_SNAPSHOT_FAILURE",
                "E_BLOCK_WRITE_FAILURE",
                "E_REBUILD_INDEX_FAILURE",
                "E_INDEX_WITH_TTL",
                "E_UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [ErrorCode] {
            &[
                ErrorCode::SUCCEEDED,
                ErrorCode::E_DISCONNECTED,
                ErrorCode::E_FAIL_TO_CONNECT,
                ErrorCode::E_RPC_FAILURE,
                ErrorCode::E_LEADER_CHANGED,
                ErrorCode::E_NO_HOSTS,
                ErrorCode::E_EXISTED,
                ErrorCode::E_NOT_FOUND,
                ErrorCode::E_INVALID_HOST,
                ErrorCode::E_UNSUPPORTED,
                ErrorCode::E_NOT_DROP,
                ErrorCode::E_BALANCER_RUNNING,
                ErrorCode::E_CONFIG_IMMUTABLE,
                ErrorCode::E_CONFLICT,
                ErrorCode::E_INVALID_PARM,
                ErrorCode::E_WRONGCLUSTER,
                ErrorCode::E_STORE_FAILURE,
                ErrorCode::E_STORE_SEGMENT_ILLEGAL,
                ErrorCode::E_BAD_BALANCE_PLAN,
                ErrorCode::E_BALANCED,
                ErrorCode::E_NO_RUNNING_BALANCE_PLAN,
                ErrorCode::E_NO_VALID_HOST,
                ErrorCode::E_CORRUPTTED_BALANCE_PLAN,
                ErrorCode::E_INVALID_PASSWORD,
                ErrorCode::E_IMPROPER_ROLE,
                ErrorCode::E_INVALID_PARTITION_NUM,
                ErrorCode::E_INVALID_REPLICA_FACTOR,
                ErrorCode::E_INVALID_CHARSET,
                ErrorCode::E_INVALID_COLLATE,
                ErrorCode::E_CHARSET_COLLATE_NOT_MATCH,
                ErrorCode::E_SNAPSHOT_FAILURE,
                ErrorCode::E_BLOCK_WRITE_FAILURE,
                ErrorCode::E_REBUILD_INDEX_FAILURE,
                ErrorCode::E_INDEX_WITH_TTL,
                ErrorCode::E_UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_UNKNOWN", -99),
                ("E_INDEX_WITH_TTL", -54),
                ("E_REBUILD_INDEX_FAILURE", -53),
                ("E_BLOCK_WRITE_FAILURE", -52),
                ("E_SNAPSHOT_FAILURE", -51),
                ("E_CHARSET_COLLATE_NOT_MATCH", -47),
                ("E_INVALID_COLLATE", -46),
                ("E_INVALID_CHARSET", -45),
                ("E_INVALID_REPLICA_FACTOR", -44),
                ("E_INVALID_PARTITION_NUM", -43),
                ("E_IMPROPER_ROLE", -42),
                ("E_INVALID_PASSWORD", -41),
                ("E_CORRUPTTED_BALANCE_PLAN", -38),
                ("E_NO_VALID_HOST", -37),
                ("E_NO_RUNNING_BALANCE_PLAN", -36),
                ("E_BALANCED", -35),
                ("E_BAD_BALANCE_PLAN", -34),
                ("E_STORE_SEGMENT_ILLEGAL", -33),
                ("E_STORE_FAILURE", -32),
                ("E_WRONGCLUSTER", -31),
                ("E_INVALID_PARM", -30),
                ("E_CONFLICT", -29),
                ("E_CONFIG_IMMUTABLE", -28),
                ("E_BALANCER_RUNNING", -27),
                ("E_NOT_DROP", -26),
                ("E_UNSUPPORTED", -25),
                ("E_INVALID_HOST", -24),
                ("E_NOT_FOUND", -23),
                ("E_EXISTED", -22),
                ("E_NO_HOSTS", -21),
                ("E_LEADER_CHANGED", -11),
                ("E_RPC_FAILURE", -3),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_DISCONNECTED", -1),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ErrorCode::{}", self)
        }
    }

    impl ::std::str::FromStr for ErrorCode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_BAD_BALANCE_PLAN", -34),
                ("E_BALANCED", -35),
                ("E_BALANCER_RUNNING", -27),
                ("E_BLOCK_WRITE_FAILURE", -52),
                ("E_CHARSET_COLLATE_NOT_MATCH", -47),
                ("E_CONFIG_IMMUTABLE", -28),
                ("E_CONFLICT", -29),
                ("E_CORRUPTTED_BALANCE_PLAN", -38),
                ("E_DISCONNECTED", -1),
                ("E_EXISTED", -22),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_IMPROPER_ROLE", -42),
                ("E_INDEX_WITH_TTL", -54),
                ("E_INVALID_CHARSET", -45),
                ("E_INVALID_COLLATE", -46),
                ("E_INVALID_HOST", -24),
                ("E_INVALID_PARM", -30),
                ("E_INVALID_PARTITION_NUM", -43),
                ("E_INVALID_PASSWORD", -41),
                ("E_INVALID_REPLICA_FACTOR", -44),
                ("E_LEADER_CHANGED", -11),
                ("E_NOT_DROP", -26),
                ("E_NOT_FOUND", -23),
                ("E_NO_HOSTS", -21),
                ("E_NO_RUNNING_BALANCE_PLAN", -36),
                ("E_NO_VALID_HOST", -37),
                ("E_REBUILD_INDEX_FAILURE", -53),
                ("E_RPC_FAILURE", -3),
                ("E_SNAPSHOT_FAILURE", -51),
                ("E_STORE_FAILURE", -32),
                ("E_STORE_SEGMENT_ILLEGAL", -33),
                ("E_UNKNOWN", -99),
                ("E_UNSUPPORTED", -25),
                ("E_WRONGCLUSTER", -31),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(ErrorCode)
        }
    }

    impl ::fbthrift::GetTType for ErrorCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ErrorCode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct AlterSchemaOp(pub ::std::primitive::i32);

    impl AlterSchemaOp {
        pub const ADD: Self = AlterSchemaOp(1i32);
        pub const CHANGE: Self = AlterSchemaOp(2i32);
        pub const DROP: Self = AlterSchemaOp(3i32);
        pub const UNKNOWN: Self = AlterSchemaOp(4i32);
    }

    impl ::fbthrift::ThriftEnum for AlterSchemaOp {
        fn enumerate() -> &'static [(AlterSchemaOp, &'static str)] {
            &[
                (AlterSchemaOp::ADD, "ADD"),
                (AlterSchemaOp::CHANGE, "CHANGE"),
                (AlterSchemaOp::DROP, "DROP"),
                (AlterSchemaOp::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ADD",
                "CHANGE",
                "DROP",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [AlterSchemaOp] {
            &[
                AlterSchemaOp::ADD,
                AlterSchemaOp::CHANGE,
                AlterSchemaOp::DROP,
                AlterSchemaOp::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for AlterSchemaOp {
        fn default() -> Self {
            AlterSchemaOp(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a AlterSchemaOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a AlterSchemaOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<AlterSchemaOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: AlterSchemaOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for AlterSchemaOp {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for AlterSchemaOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("CHANGE", 2),
                ("DROP", 3),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for AlterSchemaOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "AlterSchemaOp::{}", self)
        }
    }

    impl ::std::str::FromStr for AlterSchemaOp {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("CHANGE", 2),
                ("DROP", 3),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSchemaOp").map(AlterSchemaOp)
        }
    }

    impl ::fbthrift::GetTType for AlterSchemaOp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for AlterSchemaOp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for AlterSchemaOp
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(AlterSchemaOp::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct HostStatus(pub ::std::primitive::i32);

    impl HostStatus {
        pub const ONLINE: Self = HostStatus(0i32);
        pub const OFFLINE: Self = HostStatus(1i32);
        pub const UNKNOWN: Self = HostStatus(2i32);
    }

    impl ::fbthrift::ThriftEnum for HostStatus {
        fn enumerate() -> &'static [(HostStatus, &'static str)] {
            &[
                (HostStatus::ONLINE, "ONLINE"),
                (HostStatus::OFFLINE, "OFFLINE"),
                (HostStatus::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ONLINE",
                "OFFLINE",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [HostStatus] {
            &[
                HostStatus::ONLINE,
                HostStatus::OFFLINE,
                HostStatus::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for HostStatus {
        fn default() -> Self {
            HostStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a HostStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a HostStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<HostStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: HostStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for HostStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for HostStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ONLINE", 0),
                ("OFFLINE", 1),
                ("UNKNOWN", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for HostStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "HostStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for HostStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("OFFLINE", 1),
                ("ONLINE", 0),
                ("UNKNOWN", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostStatus").map(HostStatus)
        }
    }

    impl ::fbthrift::GetTType for HostStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for HostStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for HostStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(HostStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct SnapshotStatus(pub ::std::primitive::i32);

    impl SnapshotStatus {
        pub const VALID: Self = SnapshotStatus(0i32);
        pub const INVALID: Self = SnapshotStatus(1i32);
    }

    impl ::fbthrift::ThriftEnum for SnapshotStatus {
        fn enumerate() -> &'static [(SnapshotStatus, &'static str)] {
            &[
                (SnapshotStatus::VALID, "VALID"),
                (SnapshotStatus::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "VALID",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [SnapshotStatus] {
            &[
                SnapshotStatus::VALID,
                SnapshotStatus::INVALID,
            ]
        }
    }

    impl ::std::default::Default for SnapshotStatus {
        fn default() -> Self {
            SnapshotStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a SnapshotStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a SnapshotStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<SnapshotStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: SnapshotStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for SnapshotStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for SnapshotStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("VALID", 0),
                ("INVALID", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for SnapshotStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "SnapshotStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for SnapshotStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("INVALID", 1),
                ("VALID", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "SnapshotStatus").map(SnapshotStatus)
        }
    }

    impl ::fbthrift::GetTType for SnapshotStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for SnapshotStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for SnapshotStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(SnapshotStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct AdminJobOp(pub ::std::primitive::i32);

    impl AdminJobOp {
        pub const ADD: Self = AdminJobOp(1i32);
        pub const SHOW_All: Self = AdminJobOp(2i32);
        pub const SHOW: Self = AdminJobOp(3i32);
        pub const STOP: Self = AdminJobOp(4i32);
        pub const RECOVER: Self = AdminJobOp(5i32);
        pub const INVALID: Self = AdminJobOp(255i32);
    }

    impl ::fbthrift::ThriftEnum for AdminJobOp {
        fn enumerate() -> &'static [(AdminJobOp, &'static str)] {
            &[
                (AdminJobOp::ADD, "ADD"),
                (AdminJobOp::SHOW_All, "SHOW_All"),
                (AdminJobOp::SHOW, "SHOW"),
                (AdminJobOp::STOP, "STOP"),
                (AdminJobOp::RECOVER, "RECOVER"),
                (AdminJobOp::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ADD",
                "SHOW_All",
                "SHOW",
                "STOP",
                "RECOVER",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [AdminJobOp] {
            &[
                AdminJobOp::ADD,
                AdminJobOp::SHOW_All,
                AdminJobOp::SHOW,
                AdminJobOp::STOP,
                AdminJobOp::RECOVER,
                AdminJobOp::INVALID,
            ]
        }
    }

    impl ::std::default::Default for AdminJobOp {
        fn default() -> Self {
            AdminJobOp(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a AdminJobOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a AdminJobOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<AdminJobOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: AdminJobOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for AdminJobOp {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for AdminJobOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("SHOW_All", 2),
                ("SHOW", 3),
                ("STOP", 4),
                ("RECOVER", 5),
                ("INVALID", 255),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for AdminJobOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "AdminJobOp::{}", self)
        }
    }

    impl ::std::str::FromStr for AdminJobOp {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("INVALID", 255),
                ("RECOVER", 5),
                ("SHOW", 3),
                ("SHOW_All", 2),
                ("STOP", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminJobOp").map(AdminJobOp)
        }
    }

    impl ::fbthrift::GetTType for AdminJobOp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for AdminJobOp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for AdminJobOp
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(AdminJobOp::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct JobStatus(pub ::std::primitive::i32);

    impl JobStatus {
        pub const QUEUE: Self = JobStatus(1i32);
        pub const RUNNING: Self = JobStatus(2i32);
        pub const FINISHED: Self = JobStatus(3i32);
        pub const FAILED: Self = JobStatus(4i32);
        pub const STOPPED: Self = JobStatus(5i32);
        pub const INVALID: Self = JobStatus(255i32);
    }

    impl ::fbthrift::ThriftEnum for JobStatus {
        fn enumerate() -> &'static [(JobStatus, &'static str)] {
            &[
                (JobStatus::QUEUE, "QUEUE"),
                (JobStatus::RUNNING, "RUNNING"),
                (JobStatus::FINISHED, "FINISHED"),
                (JobStatus::FAILED, "FAILED"),
                (JobStatus::STOPPED, "STOPPED"),
                (JobStatus::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "QUEUE",
                "RUNNING",
                "FINISHED",
                "FAILED",
                "STOPPED",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [JobStatus] {
            &[
                JobStatus::QUEUE,
                JobStatus::RUNNING,
                JobStatus::FINISHED,
                JobStatus::FAILED,
                JobStatus::STOPPED,
                JobStatus::INVALID,
            ]
        }
    }

    impl ::std::default::Default for JobStatus {
        fn default() -> Self {
            JobStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a JobStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a JobStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<JobStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: JobStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for JobStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for JobStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("QUEUE", 1),
                ("RUNNING", 2),
                ("FINISHED", 3),
                ("FAILED", 4),
                ("STOPPED", 5),
                ("INVALID", 255),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for JobStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "JobStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for JobStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FAILED", 4),
                ("FINISHED", 3),
                ("INVALID", 255),
                ("QUEUE", 1),
                ("RUNNING", 2),
                ("STOPPED", 5),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobStatus").map(JobStatus)
        }
    }

    impl ::fbthrift::GetTType for JobStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for JobStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for JobStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(JobStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct TaskResult(pub ::std::primitive::i32);

    impl TaskResult {
        pub const SUCCEEDED: Self = TaskResult(0i32);
        pub const FAILED: Self = TaskResult(1i32);
        pub const IN_PROGRESS: Self = TaskResult(2i32);
        pub const INVALID: Self = TaskResult(3i32);
    }

    impl ::fbthrift::ThriftEnum for TaskResult {
        fn enumerate() -> &'static [(TaskResult, &'static str)] {
            &[
                (TaskResult::SUCCEEDED, "SUCCEEDED"),
                (TaskResult::FAILED, "FAILED"),
                (TaskResult::IN_PROGRESS, "IN_PROGRESS"),
                (TaskResult::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "FAILED",
                "IN_PROGRESS",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [TaskResult] {
            &[
                TaskResult::SUCCEEDED,
                TaskResult::FAILED,
                TaskResult::IN_PROGRESS,
                TaskResult::INVALID,
            ]
        }
    }

    impl ::std::default::Default for TaskResult {
        fn default() -> Self {
            TaskResult(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a TaskResult> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a TaskResult) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<TaskResult> for ::std::primitive::i32 {
        #[inline]
        fn from(x: TaskResult) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for TaskResult {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for TaskResult {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("SUCCEEDED", 0),
                ("FAILED", 1),
                ("IN_PROGRESS", 2),
                ("INVALID", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for TaskResult {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "TaskResult::{}", self)
        }
    }

    impl ::std::str::FromStr for TaskResult {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FAILED", 1),
                ("INVALID", 3),
                ("IN_PROGRESS", 2),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TaskResult").map(TaskResult)
        }
    }

    impl ::fbthrift::GetTType for TaskResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for TaskResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for TaskResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(TaskResult::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigModule(pub ::std::primitive::i32);

    impl ConfigModule {
        pub const UNKNOWN: Self = ConfigModule(0i32);
        pub const ALL: Self = ConfigModule(1i32);
        pub const GRAPH: Self = ConfigModule(2i32);
        pub const META: Self = ConfigModule(3i32);
        pub const STORAGE: Self = ConfigModule(4i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigModule {
        fn enumerate() -> &'static [(ConfigModule, &'static str)] {
            &[
                (ConfigModule::UNKNOWN, "UNKNOWN"),
                (ConfigModule::ALL, "ALL"),
                (ConfigModule::GRAPH, "GRAPH"),
                (ConfigModule::META, "META"),
                (ConfigModule::STORAGE, "STORAGE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "ALL",
                "GRAPH",
                "META",
                "STORAGE",
            ]
        }

        fn variant_values() -> &'static [ConfigModule] {
            &[
                ConfigModule::UNKNOWN,
                ConfigModule::ALL,
                ConfigModule::GRAPH,
                ConfigModule::META,
                ConfigModule::STORAGE,
            ]
        }
    }

    impl ::std::default::Default for ConfigModule {
        fn default() -> Self {
            ConfigModule(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigModule> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigModule) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigModule> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigModule) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigModule {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigModule {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNKNOWN", 0),
                ("ALL", 1),
                ("GRAPH", 2),
                ("META", 3),
                ("STORAGE", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigModule {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigModule::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigModule {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALL", 1),
                ("GRAPH", 2),
                ("META", 3),
                ("STORAGE", 4),
                ("UNKNOWN", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigModule").map(ConfigModule)
        }
    }

    impl ::fbthrift::GetTType for ConfigModule {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigModule
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigModule
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigModule::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigType(pub ::std::primitive::i32);

    impl ConfigType {
        pub const INT64: Self = ConfigType(0i32);
        pub const DOUBLE: Self = ConfigType(1i32);
        pub const BOOL: Self = ConfigType(2i32);
        pub const STRING: Self = ConfigType(3i32);
        pub const NESTED: Self = ConfigType(4i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigType {
        fn enumerate() -> &'static [(ConfigType, &'static str)] {
            &[
                (ConfigType::INT64, "INT64"),
                (ConfigType::DOUBLE, "DOUBLE"),
                (ConfigType::BOOL, "BOOL"),
                (ConfigType::STRING, "STRING"),
                (ConfigType::NESTED, "NESTED"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "INT64",
                "DOUBLE",
                "BOOL",
                "STRING",
                "NESTED",
            ]
        }

        fn variant_values() -> &'static [ConfigType] {
            &[
                ConfigType::INT64,
                ConfigType::DOUBLE,
                ConfigType::BOOL,
                ConfigType::STRING,
                ConfigType::NESTED,
            ]
        }
    }

    impl ::std::default::Default for ConfigType {
        fn default() -> Self {
            ConfigType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("INT64", 0),
                ("DOUBLE", 1),
                ("BOOL", 2),
                ("STRING", 3),
                ("NESTED", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigType::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("BOOL", 2),
                ("DOUBLE", 1),
                ("INT64", 0),
                ("NESTED", 4),
                ("STRING", 3),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigType").map(ConfigType)
        }
    }

    impl ::fbthrift::GetTType for ConfigType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigMode(pub ::std::primitive::i32);

    impl ConfigMode {
        pub const IMMUTABLE: Self = ConfigMode(0i32);
        pub const REBOOT: Self = ConfigMode(1i32);
        pub const MUTABLE: Self = ConfigMode(2i32);
        pub const IGNORED: Self = ConfigMode(3i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigMode {
        fn enumerate() -> &'static [(ConfigMode, &'static str)] {
            &[
                (ConfigMode::IMMUTABLE, "IMMUTABLE"),
                (ConfigMode::REBOOT, "REBOOT"),
                (ConfigMode::MUTABLE, "MUTABLE"),
                (ConfigMode::IGNORED, "IGNORED"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "IMMUTABLE",
                "REBOOT",
                "MUTABLE",
                "IGNORED",
            ]
        }

        fn variant_values() -> &'static [ConfigMode] {
            &[
                ConfigMode::IMMUTABLE,
                ConfigMode::REBOOT,
                ConfigMode::MUTABLE,
                ConfigMode::IGNORED,
            ]
        }
    }

    impl ::std::default::Default for ConfigMode {
        fn default() -> Self {
            ConfigMode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigMode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("IMMUTABLE", 0),
                ("REBOOT", 1),
                ("MUTABLE", 2),
                ("IGNORED", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigMode::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigMode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("IGNORED", 3),
                ("IMMUTABLE", 0),
                ("MUTABLE", 2),
                ("REBOOT", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigMode").map(ConfigMode)
        }
    }

    impl ::fbthrift::GetTType for ConfigMode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigMode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigMode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigMode::from(p.read_i32()?))
        }
    }


    impl ::std::default::Default for ID {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for ID {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for ID
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ID");
            match self {
                ID::space_id(inner) => {
                    p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::tag_id(inner) => {
                    p.write_field_begin("tag_id", ::fbthrift::TType::I32, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::edge_type(inner) => {
                    p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::index_id(inner) => {
                    p.write_field_begin("index_id", ::fbthrift::TType::I32, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::cluster_id(inner) => {
                    p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 5);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ID
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 2),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::space_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::tag_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::edge_type(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::index_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I64, 5, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::cluster_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "ID",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::IdName {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IdName {}
    unsafe impl ::std::marker::Sync for self::IdName {}

    impl ::fbthrift::GetTType for self::IdName {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IdName
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IdName");
            p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IdName
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SpaceProperties {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
                partition_num: ::std::default::Default::default(),
                replica_factor: ::std::default::Default::default(),
                charset_name: ::std::default::Default::default(),
                collate_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SpaceProperties {}
    unsafe impl ::std::marker::Sync for self::SpaceProperties {}

    impl ::fbthrift::GetTType for self::SpaceProperties {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SpaceProperties
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SpaceProperties");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_begin("partition_num", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.partition_num, p);
            p.write_field_end();
            p.write_field_begin("replica_factor", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.replica_factor, p);
            p.write_field_end();
            p.write_field_begin("charset_name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.charset_name, p);
            p.write_field_end();
            p.write_field_begin("collate_name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.collate_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SpaceProperties
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("charset_name", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("collate_name", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("partition_num", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("replica_factor", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let mut field_partition_num = ::std::option::Option::None;
            let mut field_replica_factor = ::std::option::Option::None;
            let mut field_charset_name = ::std::option::Option::None;
            let mut field_collate_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_partition_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_replica_factor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_charset_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_collate_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
                partition_num: field_partition_num.unwrap_or_default(),
                replica_factor: field_replica_factor.unwrap_or_default(),
                charset_name: field_charset_name.unwrap_or_default(),
                collate_name: field_collate_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SpaceItem {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                properties: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SpaceItem {}
    unsafe impl ::std::marker::Sync for self::SpaceItem {}

    impl ::fbthrift::GetTType for self::SpaceItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SpaceItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SpaceItem");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("properties", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.properties, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SpaceItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_properties = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                properties: field_properties.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TagItem {
        fn default() -> Self {
            Self {
                tag_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TagItem {}
    unsafe impl ::std::marker::Sync for self::TagItem {}

    impl ::fbthrift::GetTType for self::TagItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TagItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TagItem");
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TagItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_id: field_tag_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterSchemaItem {
        fn default() -> Self {
            Self {
                op: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterSchemaItem {}
    unsafe impl ::std::marker::Sync for self::AlterSchemaItem {}

    impl ::fbthrift::GetTType for self::AlterSchemaItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterSchemaItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterSchemaItem");
            p.write_field_begin("op", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.op, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterSchemaItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_op = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                op: field_op.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgeItem {
        fn default() -> Self {
            Self {
                edge_type: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeItem {}
    unsafe impl ::std::marker::Sync for self::EdgeItem {}

    impl ::fbthrift::GetTType for self::EdgeItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeItem");
            p.write_field_begin("edge_type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.edge_type, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_edge_type = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                edge_type: field_edge_type.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HostItem {
        fn default() -> Self {
            Self {
                hostAddr: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                leader_parts: ::std::default::Default::default(),
                all_parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostItem {}
    unsafe impl ::std::marker::Sync for self::HostItem {}

    impl ::fbthrift::GetTType for self::HostItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostItem");
            p.write_field_begin("hostAddr", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.hostAddr, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.leader_parts, p);
            p.write_field_end();
            p.write_field_begin("all_parts", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(&self.all_parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("all_parts", ::fbthrift::TType::Map, 4),
                ::fbthrift::Field::new("hostAddr", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 3),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
            ];
            let mut field_hostAddr = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_leader_parts = ::std::option::Option::None;
            let mut field_all_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_hostAddr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_all_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hostAddr: field_hostAddr.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                leader_parts: field_leader_parts.unwrap_or_default(),
                all_parts: field_all_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ExecResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ExecResp {}
    unsafe impl ::std::marker::Sync for self::ExecResp {}

    impl ::fbthrift::GetTType for self::ExecResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ExecResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ExecResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ExecResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSpaceReq {
        fn default() -> Self {
            Self {
                properties: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSpaceReq {}
    unsafe impl ::std::marker::Sync for self::CreateSpaceReq {}

    impl ::fbthrift::GetTType for self::CreateSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSpaceReq");
            p.write_field_begin("properties", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.properties, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_properties = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                properties: field_properties.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropSpaceReq {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropSpaceReq {}
    unsafe impl ::std::marker::Sync for self::DropSpaceReq {}

    impl ::fbthrift::GetTType for self::DropSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropSpaceReq");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminJobReq {
        fn default() -> Self {
            Self {
                op: ::std::default::Default::default(),
                paras: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobReq {}
    unsafe impl ::std::marker::Sync for self::AdminJobReq {}

    impl ::fbthrift::GetTType for self::AdminJobReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobReq");
            p.write_field_begin("op", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.op, p);
            p.write_field_end();
            p.write_field_begin("paras", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.paras, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 2),
            ];
            let mut field_op = ::std::option::Option::None;
            let mut field_paras = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                op: field_op.unwrap_or_default(),
                paras: field_paras.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::JobDesc {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                cmd: ::std::default::Default::default(),
                paras: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                stop_time: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::JobDesc {}
    unsafe impl ::std::marker::Sync for self::JobDesc {}

    impl ::fbthrift::GetTType for self::JobDesc {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JobDesc
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JobDesc");
            p.write_field_begin("id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("cmd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.cmd, p);
            p.write_field_end();
            p.write_field_begin("paras", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.paras, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("stop_time", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.stop_time, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JobDesc
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cmd", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 6),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_cmd = ::std::option::Option::None;
            let mut field_paras = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_stop_time = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                cmd: field_cmd.unwrap_or_default(),
                paras: field_paras.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                stop_time: field_stop_time.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TaskDesc {
        fn default() -> Self {
            Self {
                task_id: ::std::default::Default::default(),
                host: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                stop_time: ::std::default::Default::default(),
                job_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TaskDesc {}
    unsafe impl ::std::marker::Sync for self::TaskDesc {}

    impl ::fbthrift::GetTType for self::TaskDesc {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TaskDesc
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TaskDesc");
            p.write_field_begin("task_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.task_id, p);
            p.write_field_end();
            p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("stop_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.stop_time, p);
            p.write_field_end();
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.job_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TaskDesc
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 6),
                ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_task_id = ::std::option::Option::None;
            let mut field_host = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_stop_time = ::std::option::Option::None;
            let mut field_job_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                task_id: field_task_id.unwrap_or_default(),
                host: field_host.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                stop_time: field_stop_time.unwrap_or_default(),
                job_id: field_job_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminJobResult {
        fn default() -> Self {
            Self {
                job_id: ::std::option::Option::None,
                job_desc: ::std::option::Option::None,
                task_desc: ::std::option::Option::None,
                recovered_job_num: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobResult {}
    unsafe impl ::std::marker::Sync for self::AdminJobResult {}

    impl ::fbthrift::GetTType for self::AdminJobResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobResult");
            if let ::std::option::Option::Some(some) = &self.job_id {
                p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.job_desc {
                p.write_field_begin("job_desc", ::fbthrift::TType::List, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.task_desc {
                p.write_field_begin("task_desc", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.recovered_job_num {
                p.write_field_begin("recovered_job_num", ::fbthrift::TType::I32, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("job_desc", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("recovered_job_num", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("task_desc", ::fbthrift::TType::List, 3),
            ];
            let mut field_job_id = ::std::option::Option::None;
            let mut field_job_desc = ::std::option::Option::None;
            let mut field_task_desc = ::std::option::Option::None;
            let mut field_recovered_job_num = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_job_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_task_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_recovered_job_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                job_id: field_job_id,
                job_desc: field_job_desc,
                task_desc: field_task_desc,
                recovered_job_num: field_recovered_job_num,
            })
        }
    }


    impl ::std::default::Default for self::AdminJobResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobResp {}
    unsafe impl ::std::marker::Sync for self::AdminJobResp {}

    impl ::fbthrift::GetTType for self::AdminJobResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("result", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSpacesReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSpacesReq {}
    unsafe impl ::std::marker::Sync for self::ListSpacesReq {}

    impl ::fbthrift::GetTType for self::ListSpacesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSpacesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSpacesReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListSpacesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                spaces: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSpacesResp {}
    unsafe impl ::std::marker::Sync for self::ListSpacesResp {}

    impl ::fbthrift::GetTType for self::ListSpacesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSpacesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSpacesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("spaces", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.spaces, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_spaces = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                spaces: field_spaces.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSpaceReq {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSpaceReq {}
    unsafe impl ::std::marker::Sync for self::GetSpaceReq {}

    impl ::fbthrift::GetTType for self::GetSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSpaceReq");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSpaceResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSpaceResp {}
    unsafe impl ::std::marker::Sync for self::GetSpaceResp {}

    impl ::fbthrift::GetTType for self::GetSpaceResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSpaceResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSpaceResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateTagReq {}
    unsafe impl ::std::marker::Sync for self::CreateTagReq {}

    impl ::fbthrift::GetTType for self::CreateTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                tag_items: ::std::default::Default::default(),
                schema_prop: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterTagReq {}
    unsafe impl ::std::marker::Sync for self::AlterTagReq {}

    impl ::fbthrift::GetTType for self::AlterTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("tag_items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.tag_items, p);
            p.write_field_end();
            p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema_prop, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_tag_items = ::std::option::Option::None;
            let mut field_schema_prop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_tag_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                tag_items: field_tag_items.unwrap_or_default(),
                schema_prop: field_schema_prop.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropTagReq {}
    unsafe impl ::std::marker::Sync for self::DropTagReq {}

    impl ::fbthrift::GetTType for self::DropTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagsReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagsReq {}
    unsafe impl ::std::marker::Sync for self::ListTagsReq {}

    impl ::fbthrift::GetTType for self::ListTagsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagsReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagsResp {}
    unsafe impl ::std::marker::Sync for self::ListTagsResp {}

    impl ::fbthrift::GetTType for self::ListTagsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagReq {}
    unsafe impl ::std::marker::Sync for self::GetTagReq {}

    impl ::fbthrift::GetTType for self::GetTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagResp {}
    unsafe impl ::std::marker::Sync for self::GetTagResp {}

    impl ::fbthrift::GetTType for self::GetTagResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateEdgeReq {}
    unsafe impl ::std::marker::Sync for self::CreateEdgeReq {}

    impl ::fbthrift::GetTType for self::CreateEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                edge_items: ::std::default::Default::default(),
                schema_prop: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterEdgeReq {}
    unsafe impl ::std::marker::Sync for self::AlterEdgeReq {}

    impl ::fbthrift::GetTType for self::AlterEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("edge_items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edge_items, p);
            p.write_field_end();
            p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema_prop, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_edge_items = ::std::option::Option::None;
            let mut field_schema_prop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edge_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                edge_items: field_edge_items.unwrap_or_default(),
                schema_prop: field_schema_prop.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeReq {}
    unsafe impl ::std::marker::Sync for self::GetEdgeReq {}

    impl ::fbthrift::GetTType for self::GetEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeResp {}
    unsafe impl ::std::marker::Sync for self::GetEdgeResp {}

    impl ::fbthrift::GetTType for self::GetEdgeResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropEdgeReq {}
    unsafe impl ::std::marker::Sync for self::DropEdgeReq {}

    impl ::fbthrift::GetTType for self::DropEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgesReq {}
    unsafe impl ::std::marker::Sync for self::ListEdgesReq {}

    impl ::fbthrift::GetTType for self::ListEdgesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                edges: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgesResp {}
    unsafe impl ::std::marker::Sync for self::ListEdgesResp {}

    impl ::fbthrift::GetTType for self::ListEdgesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("edges", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edges, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_edges = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                edges: field_edges.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListHostsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListHostsReq {}
    unsafe impl ::std::marker::Sync for self::ListHostsReq {}

    impl ::fbthrift::GetTType for self::ListHostsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListHostsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListHostsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListHostsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListHostsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListHostsResp {}
    unsafe impl ::std::marker::Sync for self::ListHostsResp {}

    impl ::fbthrift::GetTType for self::ListHostsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListHostsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListHostsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListHostsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PartItem {
        fn default() -> Self {
            Self {
                part_id: ::std::default::Default::default(),
                leader: ::std::option::Option::None,
                peers: ::std::default::Default::default(),
                losts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PartItem {}
    unsafe impl ::std::marker::Sync for self::PartItem {}

    impl ::fbthrift::GetTType for self::PartItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PartItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PartItem");
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader {
                p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("peers", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.peers, p);
            p.write_field_end();
            p.write_field_begin("losts", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.losts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PartItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("losts", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
            ];
            let mut field_part_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_peers = ::std::option::Option::None;
            let mut field_losts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_losts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                part_id: field_part_id.unwrap_or_default(),
                leader: field_leader,
                peers: field_peers.unwrap_or_default(),
                losts: field_losts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListPartsReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_ids: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListPartsReq {}
    unsafe impl ::std::marker::Sync for self::ListPartsReq {}

    impl ::fbthrift::GetTType for self::ListPartsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListPartsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListPartsReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_ids", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.part_ids, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListPartsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("part_ids", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_ids = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_part_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_ids: field_part_ids.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListPartsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListPartsResp {}
    unsafe impl ::std::marker::Sync for self::ListPartsResp {}

    impl ::fbthrift::GetTType for self::ListPartsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListPartsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListPartsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListPartsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetPartsAllocReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPartsAllocReq {}
    unsafe impl ::std::marker::Sync for self::GetPartsAllocReq {}

    impl ::fbthrift::GetTType for self::GetPartsAllocReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPartsAllocReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetPartsAllocResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPartsAllocResp {}
    unsafe impl ::std::marker::Sync for self::GetPartsAllocResp {}

    impl ::fbthrift::GetTType for self::GetPartsAllocResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPartsAllocResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiPutReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                pairs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiPutReq {}
    unsafe impl ::std::marker::Sync for self::MultiPutReq {}

    impl ::fbthrift::GetTType for self::MultiPutReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiPutReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiPutReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("pairs", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.pairs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiPutReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("pairs", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_pairs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_pairs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                pairs: field_pairs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                key: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetReq {}
    unsafe impl ::std::marker::Sync for self::GetReq {}

    impl ::fbthrift::GetTType for self::GetReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("key", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetResp {}
    unsafe impl ::std::marker::Sync for self::GetResp {}

    impl ::fbthrift::GetTType for self::GetResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiGetReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                keys: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiGetReq {}
    unsafe impl ::std::marker::Sync for self::MultiGetReq {}

    impl ::fbthrift::GetTType for self::MultiGetReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiGetReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiGetReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("keys", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.keys, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiGetReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("keys", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_keys = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                keys: field_keys.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiGetResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiGetResp {}
    unsafe impl ::std::marker::Sync for self::MultiGetResp {}

    impl ::fbthrift::GetTType for self::MultiGetResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiGetResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiGetResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("values", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiGetResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                key: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveReq {}
    unsafe impl ::std::marker::Sync for self::RemoveReq {}

    impl ::fbthrift::GetTType for self::RemoveReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("key", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveRangeReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                start: ::std::default::Default::default(),
                end: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveRangeReq {}
    unsafe impl ::std::marker::Sync for self::RemoveRangeReq {}

    impl ::fbthrift::GetTType for self::RemoveRangeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveRangeReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("start", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.start, p);
            p.write_field_end();
            p.write_field_begin("end", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.end, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_start = ::std::option::Option::None;
            let mut field_end = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                start: field_start.unwrap_or_default(),
                end: field_end.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                start: ::std::default::Default::default(),
                end: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanReq {}
    unsafe impl ::std::marker::Sync for self::ScanReq {}

    impl ::fbthrift::GetTType for self::ScanReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("start", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.start, p);
            p.write_field_end();
            p.write_field_begin("end", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.end, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_start = ::std::option::Option::None;
            let mut field_end = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                start: field_start.unwrap_or_default(),
                end: field_end.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanResp {}
    unsafe impl ::std::marker::Sync for self::ScanResp {}

    impl ::fbthrift::GetTType for self::ScanResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("values", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HBResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                cluster_id: ::std::default::Default::default(),
                last_update_time_in_ms: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HBResp {}
    unsafe impl ::std::marker::Sync for self::HBResp {}

    impl ::fbthrift::GetTType for self::HBResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HBResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HBResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.cluster_id, p);
            p.write_field_end();
            p.write_field_begin("last_update_time_in_ms", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.last_update_time_in_ms, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HBResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("last_update_time_in_ms", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_cluster_id = ::std::option::Option::None;
            let mut field_last_update_time_in_ms = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_last_update_time_in_ms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                cluster_id: field_cluster_id.unwrap_or_default(),
                last_update_time_in_ms: field_last_update_time_in_ms.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HBReq {
        fn default() -> Self {
            Self {
                in_storaged: ::std::default::Default::default(),
                host: ::std::default::Default::default(),
                cluster_id: ::std::default::Default::default(),
                leader_partIds: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HBReq {}
    unsafe impl ::std::marker::Sync for self::HBReq {}

    impl ::fbthrift::GetTType for self::HBReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HBReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HBReq");
            p.write_field_begin("in_storaged", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.in_storaged, p);
            p.write_field_end();
            p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.cluster_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader_partIds {
                p.write_field_begin("leader_partIds", ::fbthrift::TType::Map, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HBReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("in_storaged", ::fbthrift::TType::Bool, 1),
                ::fbthrift::Field::new("leader_partIds", ::fbthrift::TType::Map, 4),
            ];
            let mut field_in_storaged = ::std::option::Option::None;
            let mut field_host = ::std::option::Option::None;
            let mut field_cluster_id = ::std::option::Option::None;
            let mut field_leader_partIds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_in_storaged = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_leader_partIds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                in_storaged: field_in_storaged.unwrap_or_default(),
                host: field_host.unwrap_or_default(),
                cluster_id: field_cluster_id.unwrap_or_default(),
                leader_partIds: field_leader_partIds,
            })
        }
    }


    impl ::std::default::Default for self::CreateTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                fields: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::CreateTagIndexReq {}

    impl ::fbthrift::GetTType for self::CreateTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("fields", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.fields, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_fields = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                fields: field_fields.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::DropTagIndexReq {}

    impl ::fbthrift::GetTType for self::DropTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::GetTagIndexReq {}

    impl ::fbthrift::GetTType for self::GetTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagIndexResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagIndexResp {}
    unsafe impl ::std::marker::Sync for self::GetTagIndexResp {}

    impl ::fbthrift::GetTType for self::GetTagIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagIndexResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagIndexesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagIndexesReq {}
    unsafe impl ::std::marker::Sync for self::ListTagIndexesReq {}

    impl ::fbthrift::GetTType for self::ListTagIndexesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagIndexesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagIndexesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagIndexesResp {}
    unsafe impl ::std::marker::Sync for self::ListTagIndexesResp {}

    impl ::fbthrift::GetTType for self::ListTagIndexesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagIndexesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                fields: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::CreateEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::CreateEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("fields", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.fields, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_fields = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                fields: field_fields.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::DropEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::DropEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::GetEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::GetEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeIndexResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeIndexResp {}
    unsafe impl ::std::marker::Sync for self::GetEdgeIndexResp {}

    impl ::fbthrift::GetTType for self::GetEdgeIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeIndexResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgeIndexesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgeIndexesReq {}
    unsafe impl ::std::marker::Sync for self::ListEdgeIndexesReq {}

    impl ::fbthrift::GetTType for self::ListEdgeIndexesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgeIndexesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgeIndexesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgeIndexesResp {}
    unsafe impl ::std::marker::Sync for self::ListEdgeIndexesResp {}

    impl ::fbthrift::GetTType for self::ListEdgeIndexesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgeIndexesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RebuildIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                is_offline: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RebuildIndexReq {}
    unsafe impl ::std::marker::Sync for self::RebuildIndexReq {}

    impl ::fbthrift::GetTType for self::RebuildIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RebuildIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("is_offline", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.is_offline, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("is_offline", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_is_offline = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_is_offline = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                is_offline: field_is_offline.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                encoded_pwd: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateUserReq {}
    unsafe impl ::std::marker::Sync for self::CreateUserReq {}

    impl ::fbthrift::GetTType for self::CreateUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.encoded_pwd, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 3),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_encoded_pwd = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                encoded_pwd: field_encoded_pwd.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropUserReq {}
    unsafe impl ::std::marker::Sync for self::DropUserReq {}

    impl ::fbthrift::GetTType for self::DropUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                encoded_pwd: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterUserReq {}
    unsafe impl ::std::marker::Sync for self::AlterUserReq {}

    impl ::fbthrift::GetTType for self::AlterUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.encoded_pwd, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_encoded_pwd = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GrantRoleReq {
        fn default() -> Self {
            Self {
                role_item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GrantRoleReq {}
    unsafe impl ::std::marker::Sync for self::GrantRoleReq {}

    impl ::fbthrift::GetTType for self::GrantRoleReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GrantRoleReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GrantRoleReq");
            p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.role_item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GrantRoleReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_role_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                role_item: field_role_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RevokeRoleReq {
        fn default() -> Self {
            Self {
                role_item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RevokeRoleReq {}
    unsafe impl ::std::marker::Sync for self::RevokeRoleReq {}

    impl ::fbthrift::GetTType for self::RevokeRoleReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RevokeRoleReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RevokeRoleReq");
            p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.role_item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RevokeRoleReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_role_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                role_item: field_role_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListUsersReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListUsersReq {}
    unsafe impl ::std::marker::Sync for self::ListUsersReq {}

    impl ::fbthrift::GetTType for self::ListUsersReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListUsersReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListUsersReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListUsersReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListUsersResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                users: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListUsersResp {}
    unsafe impl ::std::marker::Sync for self::ListUsersResp {}

    impl ::fbthrift::GetTType for self::ListUsersResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListUsersResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListUsersResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("users", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.users, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListUsersResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("users", ::fbthrift::TType::Map, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_users = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_users = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                users: field_users.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListRolesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListRolesReq {}
    unsafe impl ::std::marker::Sync for self::ListRolesReq {}

    impl ::fbthrift::GetTType for self::ListRolesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListRolesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListRolesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListRolesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetUserRolesReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUserRolesReq {}
    unsafe impl ::std::marker::Sync for self::GetUserRolesReq {}

    impl ::fbthrift::GetTType for self::GetUserRolesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUserRolesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUserRolesReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUserRolesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ];
            let mut field_account = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListRolesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                roles: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListRolesResp {}
    unsafe impl ::std::marker::Sync for self::ListRolesResp {}

    impl ::fbthrift::GetTType for self::ListRolesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListRolesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListRolesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("roles", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.roles, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListRolesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("roles", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_roles = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_roles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                roles: field_roles.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ChangePasswordReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                new_encoded_pwd: ::std::default::Default::default(),
                old_encoded_pwd: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ChangePasswordReq {}
    unsafe impl ::std::marker::Sync for self::ChangePasswordReq {}

    impl ::fbthrift::GetTType for self::ChangePasswordReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ChangePasswordReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ChangePasswordReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("new_encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.new_encoded_pwd, p);
            p.write_field_end();
            p.write_field_begin("old_encoded_pwd", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.old_encoded_pwd, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ChangePasswordReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("new_encoded_pwd", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("old_encoded_pwd", ::fbthrift::TType::String, 3),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_new_encoded_pwd = ::std::option::Option::None;
            let mut field_old_encoded_pwd = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_new_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_old_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                new_encoded_pwd: field_new_encoded_pwd.unwrap_or_default(),
                old_encoded_pwd: field_old_encoded_pwd.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BalanceReq {
        fn default() -> Self {
            Self {
                space_id: ::std::option::Option::None,
                id: ::std::option::Option::None,
                host_del: ::std::option::Option::None,
                stop: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceReq {}
    unsafe impl ::std::marker::Sync for self::BalanceReq {}

    impl ::fbthrift::GetTType for self::BalanceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceReq");
            if let ::std::option::Option::Some(some) = &self.space_id {
                p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.id {
                p.write_field_begin("id", ::fbthrift::TType::I64, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.host_del {
                p.write_field_begin("host_del", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.stop {
                p.write_field_begin("stop", ::fbthrift::TType::Bool, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host_del", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("stop", ::fbthrift::TType::Bool, 4),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_host_del = ::std::option::Option::None;
            let mut field_stop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_host_del = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_stop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id,
                id: field_id,
                host_del: field_host_del,
                stop: field_stop,
            })
        }
    }


    impl ::std::default::Default for self::BalanceTask {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceTask {}
    unsafe impl ::std::marker::Sync for self::BalanceTask {}

    impl ::fbthrift::GetTType for self::BalanceTask {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceTask
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceTask");
            p.write_field_begin("id", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("result", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceTask
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("id", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("result", ::fbthrift::TType::I32, 2),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BalanceResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                tasks: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceResp {}
    unsafe impl ::std::marker::Sync for self::BalanceResp {}

    impl ::fbthrift::GetTType for self::BalanceResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("tasks", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.tasks, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("tasks", ::fbthrift::TType::List, 4),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_tasks = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_tasks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                tasks: field_tasks.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LeaderBalanceReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LeaderBalanceReq {}
    unsafe impl ::std::marker::Sync for self::LeaderBalanceReq {}

    impl ::fbthrift::GetTType for self::LeaderBalanceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LeaderBalanceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LeaderBalanceReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LeaderBalanceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ConfigItem {
        fn default() -> Self {
            Self {
                module: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ConfigItem {}
    unsafe impl ::std::marker::Sync for self::ConfigItem {}

    impl ::fbthrift::GetTType for self::ConfigItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ConfigItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ConfigItem");
            p.write_field_begin("module", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.module, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ConfigItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("value", ::fbthrift::TType::String, 5),
            ];
            let mut field_module = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                module: field_module.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RegConfigReq {
        fn default() -> Self {
            Self {
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RegConfigReq {}
    unsafe impl ::std::marker::Sync for self::RegConfigReq {}

    impl ::fbthrift::GetTType for self::RegConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RegConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RegConfigReq");
            p.write_field_begin("items", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RegConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 1),
            ];
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigReq {
        fn default() -> Self {
            Self {
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigReq {}
    unsafe impl ::std::marker::Sync for self::GetConfigReq {}

    impl ::fbthrift::GetTType for self::GetConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigReq");
            p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigResp {}
    unsafe impl ::std::marker::Sync for self::GetConfigResp {}

    impl ::fbthrift::GetTType for self::GetConfigResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SetConfigReq {
        fn default() -> Self {
            Self {
                item: ::std::default::Default::default(),
                force: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SetConfigReq {}
    unsafe impl ::std::marker::Sync for self::SetConfigReq {}

    impl ::fbthrift::GetTType for self::SetConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetConfigReq");
            p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_begin("force", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.force, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("force", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_item = ::std::option::Option::None;
            let mut field_force = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_force = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                item: field_item.unwrap_or_default(),
                force: field_force.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListConfigsReq {
        fn default() -> Self {
            Self {
                space: ::std::default::Default::default(),
                module: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListConfigsReq {}
    unsafe impl ::std::marker::Sync for self::ListConfigsReq {}

    impl ::fbthrift::GetTType for self::ListConfigsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListConfigsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListConfigsReq");
            p.write_field_begin("space", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space, p);
            p.write_field_end();
            p.write_field_begin("module", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.module, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("space", ::fbthrift::TType::String, 1),
            ];
            let mut field_space = ::std::option::Option::None;
            let mut field_module = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space: field_space.unwrap_or_default(),
                module: field_module.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListConfigsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListConfigsResp {}
    unsafe impl ::std::marker::Sync for self::ListConfigsResp {}

    impl ::fbthrift::GetTType for self::ListConfigsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListConfigsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListConfigsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSnapshotReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSnapshotReq {}
    unsafe impl ::std::marker::Sync for self::CreateSnapshotReq {}

    impl ::fbthrift::GetTType for self::CreateSnapshotReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSnapshotReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSnapshotReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSnapshotReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::DropSnapshotReq {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropSnapshotReq {}
    unsafe impl ::std::marker::Sync for self::DropSnapshotReq {}

    impl ::fbthrift::GetTType for self::DropSnapshotReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropSnapshotReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropSnapshotReq");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropSnapshotReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ];
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSnapshotsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSnapshotsReq {}
    unsafe impl ::std::marker::Sync for self::ListSnapshotsReq {}

    impl ::fbthrift::GetTType for self::ListSnapshotsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSnapshotsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::Snapshot {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Snapshot {}
    unsafe impl ::std::marker::Sync for self::Snapshot {}

    impl ::fbthrift::GetTType for self::Snapshot {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Snapshot
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Snapshot");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Snapshot
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSnapshotsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                snapshots: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSnapshotsResp {}
    unsafe impl ::std::marker::Sync for self::ListSnapshotsResp {}

    impl ::fbthrift::GetTType for self::ListSnapshotsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSnapshotsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("snapshots", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.snapshots, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("snapshots", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_snapshots = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_snapshots = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                snapshots: field_snapshots.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListIndexStatusReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListIndexStatusReq {}
    unsafe impl ::std::marker::Sync for self::ListIndexStatusReq {}

    impl ::fbthrift::GetTType for self::ListIndexStatusReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListIndexStatusReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IndexStatus {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexStatus {}
    unsafe impl ::std::marker::Sync for self::IndexStatus {}

    impl ::fbthrift::GetTType for self::IndexStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexStatus");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("status", ::fbthrift::TType::String, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListIndexStatusResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                statuses: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListIndexStatusResp {}
    unsafe impl ::std::marker::Sync for self::ListIndexStatusResp {}

    impl ::fbthrift::GetTType for self::ListIndexStatusResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListIndexStatusResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("statuses", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.statuses, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("statuses", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_statuses = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_statuses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                statuses: field_statuses.unwrap_or_default(),
            })
        }
    }

}

pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod meta_service {

        #[derive(Clone, Debug)]
        pub enum CreateSpaceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateSpace");
                match self {
                    CreateSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSpaceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropSpace");
                match self {
                    DropSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSpaceExn {
            Success(crate::types::GetSpaceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSpace");
                match self {
                    GetSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSpacesExn {
            Success(crate::types::ListSpacesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSpacesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListSpacesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListSpacesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListSpaces");
                match self {
                    ListSpacesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListSpacesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListSpacesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSpacesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSpacesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateTag");
                match self {
                    CreateTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterTag");
                match self {
                    AlterTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropTag");
                match self {
                    DropTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagExn {
            Success(crate::types::GetTagResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTag");
                match self {
                    GetTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagsExn {
            Success(crate::types::ListTagsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTags");
                match self {
                    ListTagsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateEdge");
                match self {
                    CreateEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterEdge");
                match self {
                    AlterEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropEdge");
                match self {
                    DropEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeExn {
            Success(crate::types::GetEdgeResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEdge");
                match self {
                    GetEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgesExn {
            Success(crate::types::ListEdgesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdges");
                match self {
                    ListEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListHostsExn {
            Success(crate::types::ListHostsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListHostsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListHostsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListHostsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListHosts");
                match self {
                    ListHostsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListHostsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListHostsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPartsAllocExn {
            Success(crate::types::GetPartsAllocResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPartsAllocExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPartsAllocExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetPartsAllocExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetPartsAlloc");
                match self {
                    GetPartsAllocExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPartsAllocExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPartsAllocExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPartsAllocExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPartsAllocExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListPartsExn {
            Success(crate::types::ListPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListPartsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListParts");
                match self {
                    ListPartsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListPartsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListPartsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiPutExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiPutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MultiPutExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MultiPutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MultiPut");
                match self {
                    MultiPutExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MultiPutExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MultiPutExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiPutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiPutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            Success(crate::types::GetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Get");
                match self {
                    GetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiGetExn {
            Success(crate::types::MultiGetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiGetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MultiGetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MultiGetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MultiGet");
                match self {
                    MultiGetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MultiGetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MultiGetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiGetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiGetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Remove");
                match self {
                    RemoveExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveRangeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveRange");
                match self {
                    RemoveRangeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveRangeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveRangeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanExn {
            Success(crate::types::ScanResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ScanExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ScanExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Scan");
                match self {
                    ScanExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ScanExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ScanExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateTagIndex");
                match self {
                    CreateTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropTagIndex");
                match self {
                    DropTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagIndexExn {
            Success(crate::types::GetTagIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTagIndex");
                match self {
                    GetTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexesExn {
            Success(crate::types::ListTagIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagIndexesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTagIndexes");
                match self {
                    ListTagIndexesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagIndexesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagIndexesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    RebuildTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexStatusExn {
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagIndexStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTagIndexStatus");
                match self {
                    ListTagIndexStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagIndexStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagIndexStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateEdgeIndex");
                match self {
                    CreateEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropEdgeIndex");
                match self {
                    DropEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeIndexExn {
            Success(crate::types::GetEdgeIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEdgeIndex");
                match self {
                    GetEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexesExn {
            Success(crate::types::ListEdgeIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgeIndexesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdgeIndexes");
                match self {
                    ListEdgeIndexesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgeIndexesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgeIndexesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    RebuildEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexStatusExn {
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgeIndexStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdgeIndexStatus");
                match self {
                    ListEdgeIndexStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgeIndexStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgeIndexStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateUser");
                match self {
                    CreateUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropUser");
                match self {
                    DropUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterUser");
                match self {
                    AlterUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GrantRoleExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GrantRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GrantRoleExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GrantRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GrantRole");
                match self {
                    GrantRoleExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GrantRoleExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GrantRoleExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GrantRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GrantRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RevokeRoleExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RevokeRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RevokeRoleExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RevokeRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RevokeRole");
                match self {
                    RevokeRoleExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RevokeRoleExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RevokeRoleExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RevokeRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RevokeRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListUsersExn {
            Success(crate::types::ListUsersResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListUsersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListUsersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListUsersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListUsers");
                match self {
                    ListUsersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListUsersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListUsersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListUsersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListUsersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListRolesExn {
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListRolesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListRoles");
                match self {
                    ListRolesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListRolesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListRolesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUserRolesExn {
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUserRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetUserRolesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetUserRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetUserRoles");
                match self {
                    GetUserRolesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetUserRolesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetUserRolesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUserRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUserRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChangePasswordExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChangePasswordExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ChangePasswordExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ChangePasswordExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ChangePassword");
                match self {
                    ChangePasswordExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ChangePasswordExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ChangePasswordExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChangePasswordExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChangePasswordExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum HeartBeatExn {
            Success(crate::types::HBResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for HeartBeatExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                HeartBeatExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for HeartBeatExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("HeartBeat");
                match self {
                    HeartBeatExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    HeartBeatExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(HeartBeatExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "HeartBeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "HeartBeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BalanceExn {
            Success(crate::types::BalanceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                BalanceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for BalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Balance");
                match self {
                    BalanceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    BalanceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(BalanceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LeaderBalanceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LeaderBalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                LeaderBalanceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for LeaderBalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("LeaderBalance");
                match self {
                    LeaderBalanceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    LeaderBalanceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(LeaderBalanceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LeaderBalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LeaderBalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RegConfigExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RegConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RegConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RegConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RegConfig");
                match self {
                    RegConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RegConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RegConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RegConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RegConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            Success(crate::types::GetConfigResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetConfig");
                match self {
                    GetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetConfigExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetConfig");
                match self {
                    SetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListConfigsExn {
            Success(crate::types::ListConfigsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListConfigsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListConfigsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListConfigsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListConfigs");
                match self {
                    ListConfigsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListConfigsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListConfigsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListConfigsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListConfigsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSnapshotExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateSnapshotExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateSnapshot");
                match self {
                    CreateSnapshotExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateSnapshotExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateSnapshotExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSnapshotExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropSnapshotExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropSnapshot");
                match self {
                    DropSnapshotExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropSnapshotExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropSnapshotExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSnapshotsExn {
            Success(crate::types::ListSnapshotsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSnapshotsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListSnapshotsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListSnapshotsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListSnapshots");
                match self {
                    ListSnapshotsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListSnapshotsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListSnapshotsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSnapshotsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSnapshotsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RunAdminJobExn {
            Success(crate::types::AdminJobResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RunAdminJobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RunAdminJobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RunAdminJobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RunAdminJob");
                match self {
                    RunAdminJobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RunAdminJobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RunAdminJobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RunAdminJobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RunAdminJobExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct MetaServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> MetaServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait MetaService: ::std::marker::Send {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>>;
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>>;
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>>;
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>>;
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>>;
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>>;
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>>;
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>>;
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>>;
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>>;
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>>;
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>>;
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>>;
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>>;
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>>;
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>>;
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>>;
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>>;
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>>;
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>>;
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>>;
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>>;
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>>;
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>>;
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>>;
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>>;
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>>;
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>>;
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>>;
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>>;
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>>;
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>>;
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>>;
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>>;
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>>;
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>>;
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>>;
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>>;
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>>;
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>>;
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>>;
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>>;
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>>;
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>>;
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>>;
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>>;
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>>;
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>>;
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>>;
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>>;
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> MetaService for MetaServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSpaces",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListSpacesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListSpacesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListSpacesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTags",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listHosts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListHostsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListHostsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListHostsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPartsAlloc",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetPartsAllocExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetPartsAllocExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listParts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListPartsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListPartsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListPartsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiPut",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::MultiPutExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::MultiPutExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::MultiPutExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiGet",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::MultiGetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::MultiGetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::MultiGetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveRangeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveRangeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveRangeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scan",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ScanExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ScanExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ScanExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ScanError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexes",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagIndexesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagIndexesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RebuildTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RebuildTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagIndexStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagIndexStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexes",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgeIndexesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgeIndexesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RebuildEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RebuildEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgeIndexStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "grantRole",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GrantRoleExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GrantRoleExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GrantRoleExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "revokeRole",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RevokeRoleExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RevokeRoleExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RevokeRoleExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listUsers",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListUsersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListUsersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListUsersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listRoles",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListRolesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListRolesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListRolesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUserRoles",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetUserRolesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetUserRolesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetUserRolesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "changePassword",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ChangePasswordExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ChangePasswordExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ChangePasswordExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "heartBeat",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::HeartBeatExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::HeartBeatExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::HeartBeatExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "balance",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::BalanceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::BalanceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::BalanceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "leaderBalance",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::LeaderBalanceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::LeaderBalanceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "regConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RegConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RegConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RegConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::SetConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::SetConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::SetConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listConfigs",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListConfigsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListConfigsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListConfigsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSnapshot",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateSnapshotExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateSnapshotExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSnapshot",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropSnapshotExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropSnapshotExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropSnapshotExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSnapshots",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListSnapshotsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListSnapshotsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "runAdminJob",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(&SERVICE_NAME, &METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> {
                        use ::fbthrift::{ProtocolReader as _};
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RunAdminJobExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RunAdminJobExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RunAdminJobExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> MetaService for T
    where
        T: ::std::convert::AsRef<dyn MetaService + 'a>,
        T: ::std::marker::Send,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createSpace(
                arg_req,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropSpace(
                arg_req,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSpace(
                arg_req,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listSpaces(
                arg_req,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createTag(
                arg_req,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterTag(
                arg_req,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropTag(
                arg_req,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTag(
                arg_req,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTags(
                arg_req,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createEdge(
                arg_req,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterEdge(
                arg_req,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropEdge(
                arg_req,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEdge(
                arg_req,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdges(
                arg_req,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listHosts(
                arg_req,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getPartsAlloc(
                arg_req,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listParts(
                arg_req,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            self.as_ref().multiPut(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().multiGet(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            self.as_ref().scan(
                arg_req,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createTagIndex(
                arg_req,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropTagIndex(
                arg_req,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTagIndex(
                arg_req,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTagIndexes(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTagIndexStatus(
                arg_req,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createEdgeIndex(
                arg_req,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropEdgeIndex(
                arg_req,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdgeIndexes(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdgeIndexStatus(
                arg_req,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createUser(
                arg_req,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropUser(
                arg_req,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterUser(
                arg_req,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            self.as_ref().grantRole(
                arg_req,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            self.as_ref().revokeRole(
                arg_req,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listUsers(
                arg_req,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listRoles(
                arg_req,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getUserRoles(
                arg_req,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            self.as_ref().changePassword(
                arg_req,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            self.as_ref().heartBeat(
                arg_req,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().balance(
                arg_req,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().leaderBalance(
                arg_req,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().regConfig(
                arg_req,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getConfig(
                arg_req,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setConfig(
                arg_req,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listConfigs(
                arg_req,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createSnapshot(
                arg_req,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropSnapshot(
                arg_req,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listSnapshots(
                arg_req,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().runAdminJob(
                arg_req,
            )
        }
    }

    pub struct make_MetaService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// # };
    /// ```
    impl dyn MetaService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_MetaService {
        type Api = dyn MetaService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            MetaService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait MetaService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn createSpace(
            &self,
            _req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpace",
                ),
            ))
        }
        async fn dropSpace(
            &self,
            _req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSpace",
                ),
            ))
        }
        async fn getSpace(
            &self,
            _req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSpace",
                ),
            ))
        }
        async fn listSpaces(
            &self,
            _req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSpaces",
                ),
            ))
        }
        async fn createTag(
            &self,
            _req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTag",
                ),
            ))
        }
        async fn alterTag(
            &self,
            _req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterTag",
                ),
            ))
        }
        async fn dropTag(
            &self,
            _req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTag",
                ),
            ))
        }
        async fn getTag(
            &self,
            _req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTag",
                ),
            ))
        }
        async fn listTags(
            &self,
            _req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTags",
                ),
            ))
        }
        async fn createEdge(
            &self,
            _req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdge",
                ),
            ))
        }
        async fn alterEdge(
            &self,
            _req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterEdge",
                ),
            ))
        }
        async fn dropEdge(
            &self,
            _req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdge",
                ),
            ))
        }
        async fn getEdge(
            &self,
            _req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdge",
                ),
            ))
        }
        async fn listEdges(
            &self,
            _req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdges",
                ),
            ))
        }
        async fn listHosts(
            &self,
            _req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listHosts",
                ),
            ))
        }
        async fn getPartsAlloc(
            &self,
            _req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getPartsAlloc",
                ),
            ))
        }
        async fn listParts(
            &self,
            _req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listParts",
                ),
            ))
        }
        async fn multiPut(
            &self,
            _req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiPut",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "get",
                ),
            ))
        }
        async fn multiGet(
            &self,
            _req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiGet",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeRange",
                ),
            ))
        }
        async fn scan(
            &self,
            _req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "scan",
                ),
            ))
        }
        async fn createTagIndex(
            &self,
            _req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTagIndex",
                ),
            ))
        }
        async fn dropTagIndex(
            &self,
            _req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTagIndex",
                ),
            ))
        }
        async fn getTagIndex(
            &self,
            _req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTagIndex",
                ),
            ))
        }
        async fn listTagIndexes(
            &self,
            _req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexes",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn listTagIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexStatus",
                ),
            ))
        }
        async fn createEdgeIndex(
            &self,
            _req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdgeIndex",
                ),
            ))
        }
        async fn dropEdgeIndex(
            &self,
            _req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdgeIndex",
                ),
            ))
        }
        async fn getEdgeIndex(
            &self,
            _req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexes(
            &self,
            _req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexes",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexStatus",
                ),
            ))
        }
        async fn createUser(
            &self,
            _req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createUser",
                ),
            ))
        }
        async fn dropUser(
            &self,
            _req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropUser",
                ),
            ))
        }
        async fn alterUser(
            &self,
            _req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterUser",
                ),
            ))
        }
        async fn grantRole(
            &self,
            _req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "grantRole",
                ),
            ))
        }
        async fn revokeRole(
            &self,
            _req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "revokeRole",
                ),
            ))
        }
        async fn listUsers(
            &self,
            _req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listUsers",
                ),
            ))
        }
        async fn listRoles(
            &self,
            _req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listRoles",
                ),
            ))
        }
        async fn getUserRoles(
            &self,
            _req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getUserRoles",
                ),
            ))
        }
        async fn changePassword(
            &self,
            _req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "changePassword",
                ),
            ))
        }
        async fn heartBeat(
            &self,
            _req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "heartBeat",
                ),
            ))
        }
        async fn balance(
            &self,
            _req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "balance",
                ),
            ))
        }
        async fn leaderBalance(
            &self,
            _req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "leaderBalance",
                ),
            ))
        }
        async fn regConfig(
            &self,
            _req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "regConfig",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getConfig",
                ),
            ))
        }
        async fn setConfig(
            &self,
            _req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "setConfig",
                ),
            ))
        }
        async fn listConfigs(
            &self,
            _req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listConfigs",
                ),
            ))
        }
        async fn createSnapshot(
            &self,
            _req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSnapshot",
                ),
            ))
        }
        async fn dropSnapshot(
            &self,
            _req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSnapshot",
                ),
            ))
        }
        async fn listSnapshots(
            &self,
            _req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSnapshots",
                ),
            ))
        }
        async fn runAdminJob(
            &self,
            _req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "runAdminJob",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct MetaServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Sync,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_createSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listSpaces<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listSpaces(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listSpaces",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListSpacesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSpaces",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSpaces",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTags(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTags",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTags",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTags",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdges",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listHosts(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listHosts",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListHostsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listHosts",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listHosts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getPartsAlloc<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getPartsAlloc(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getPartsAlloc",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetPartsAllocExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPartsAlloc",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPartsAlloc",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listParts(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listParts",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListPartsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listParts",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listParts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_multiPut<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.multiPut(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "multiPut",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::MultiPutExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiPut",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiPut",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.get(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "get",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_multiGet<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.multiGet(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "multiGet",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::MultiGetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiGet",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiGet",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.remove(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "remove",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.removeRange(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeRange",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_scan<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.scan(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "scan",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ScanExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ScanExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scan",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scan",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTagIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTagIndexes(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTagIndexes",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagIndexesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexes",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexes",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.rebuildTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTagIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTagIndexStatus(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTagIndexStatus",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexStatus",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdgeIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdgeIndexes(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdgeIndexes",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexes",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexes",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.rebuildEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdgeIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdgeIndexStatus(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdgeIndexStatus",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexStatus",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_grantRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.grantRole(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "grantRole",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GrantRoleExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "grantRole",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "grantRole",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_revokeRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.revokeRole(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "revokeRole",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RevokeRoleExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "revokeRole",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "revokeRole",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listUsers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listUsers(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listUsers",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListUsersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listUsers",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listUsers",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listRoles(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listRoles",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListRolesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listRoles",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listRoles",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getUserRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getUserRoles(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getUserRoles",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetUserRolesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUserRoles",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUserRoles",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_changePassword<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.changePassword(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "changePassword",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ChangePasswordExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "changePassword",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "changePassword",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_heartBeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.heartBeat(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "heartBeat",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::HeartBeatExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "heartBeat",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "heartBeat",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_balance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.balance(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "balance",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::BalanceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::BalanceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "balance",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "balance",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_leaderBalance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.leaderBalance(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "leaderBalance",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::LeaderBalanceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "leaderBalance",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "leaderBalance",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_regConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.regConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "regConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RegConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "regConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "regConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_setConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.setConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::SetConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listConfigs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listConfigs(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listConfigs",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListConfigsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listConfigs",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listConfigs",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createSnapshot(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createSnapshot",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateSnapshotExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSnapshot",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSnapshot",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropSnapshot(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropSnapshot",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropSnapshotExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSnapshot",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSnapshot",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listSnapshots<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listSnapshots(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listSnapshots",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListSnapshotsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSnapshots",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSnapshots",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_runAdminJob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.runAdminJob(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "runAdminJob",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RunAdminJobExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "runAdminJob",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "runAdminJob",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"createSpace" => ::std::result::Result::Ok(0usize),
                b"dropSpace" => ::std::result::Result::Ok(1usize),
                b"getSpace" => ::std::result::Result::Ok(2usize),
                b"listSpaces" => ::std::result::Result::Ok(3usize),
                b"createTag" => ::std::result::Result::Ok(4usize),
                b"alterTag" => ::std::result::Result::Ok(5usize),
                b"dropTag" => ::std::result::Result::Ok(6usize),
                b"getTag" => ::std::result::Result::Ok(7usize),
                b"listTags" => ::std::result::Result::Ok(8usize),
                b"createEdge" => ::std::result::Result::Ok(9usize),
                b"alterEdge" => ::std::result::Result::Ok(10usize),
                b"dropEdge" => ::std::result::Result::Ok(11usize),
                b"getEdge" => ::std::result::Result::Ok(12usize),
                b"listEdges" => ::std::result::Result::Ok(13usize),
                b"listHosts" => ::std::result::Result::Ok(14usize),
                b"getPartsAlloc" => ::std::result::Result::Ok(15usize),
                b"listParts" => ::std::result::Result::Ok(16usize),
                b"multiPut" => ::std::result::Result::Ok(17usize),
                b"get" => ::std::result::Result::Ok(18usize),
                b"multiGet" => ::std::result::Result::Ok(19usize),
                b"remove" => ::std::result::Result::Ok(20usize),
                b"removeRange" => ::std::result::Result::Ok(21usize),
                b"scan" => ::std::result::Result::Ok(22usize),
                b"createTagIndex" => ::std::result::Result::Ok(23usize),
                b"dropTagIndex" => ::std::result::Result::Ok(24usize),
                b"getTagIndex" => ::std::result::Result::Ok(25usize),
                b"listTagIndexes" => ::std::result::Result::Ok(26usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(27usize),
                b"listTagIndexStatus" => ::std::result::Result::Ok(28usize),
                b"createEdgeIndex" => ::std::result::Result::Ok(29usize),
                b"dropEdgeIndex" => ::std::result::Result::Ok(30usize),
                b"getEdgeIndex" => ::std::result::Result::Ok(31usize),
                b"listEdgeIndexes" => ::std::result::Result::Ok(32usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(33usize),
                b"listEdgeIndexStatus" => ::std::result::Result::Ok(34usize),
                b"createUser" => ::std::result::Result::Ok(35usize),
                b"dropUser" => ::std::result::Result::Ok(36usize),
                b"alterUser" => ::std::result::Result::Ok(37usize),
                b"grantRole" => ::std::result::Result::Ok(38usize),
                b"revokeRole" => ::std::result::Result::Ok(39usize),
                b"listUsers" => ::std::result::Result::Ok(40usize),
                b"listRoles" => ::std::result::Result::Ok(41usize),
                b"getUserRoles" => ::std::result::Result::Ok(42usize),
                b"changePassword" => ::std::result::Result::Ok(43usize),
                b"heartBeat" => ::std::result::Result::Ok(44usize),
                b"balance" => ::std::result::Result::Ok(45usize),
                b"leaderBalance" => ::std::result::Result::Ok(46usize),
                b"regConfig" => ::std::result::Result::Ok(47usize),
                b"getConfig" => ::std::result::Result::Ok(48usize),
                b"setConfig" => ::std::result::Result::Ok(49usize),
                b"listConfigs" => ::std::result::Result::Ok(50usize),
                b"createSnapshot" => ::std::result::Result::Ok(51usize),
                b"dropSnapshot" => ::std::result::Result::Ok(52usize),
                b"listSnapshots" => ::std::result::Result::Ok(53usize),
                b"runAdminJob" => ::std::result::Result::Ok(54usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_createSpace(_p, _r, _seqid).await,
                1usize => self.handle_dropSpace(_p, _r, _seqid).await,
                2usize => self.handle_getSpace(_p, _r, _seqid).await,
                3usize => self.handle_listSpaces(_p, _r, _seqid).await,
                4usize => self.handle_createTag(_p, _r, _seqid).await,
                5usize => self.handle_alterTag(_p, _r, _seqid).await,
                6usize => self.handle_dropTag(_p, _r, _seqid).await,
                7usize => self.handle_getTag(_p, _r, _seqid).await,
                8usize => self.handle_listTags(_p, _r, _seqid).await,
                9usize => self.handle_createEdge(_p, _r, _seqid).await,
                10usize => self.handle_alterEdge(_p, _r, _seqid).await,
                11usize => self.handle_dropEdge(_p, _r, _seqid).await,
                12usize => self.handle_getEdge(_p, _r, _seqid).await,
                13usize => self.handle_listEdges(_p, _r, _seqid).await,
                14usize => self.handle_listHosts(_p, _r, _seqid).await,
                15usize => self.handle_getPartsAlloc(_p, _r, _seqid).await,
                16usize => self.handle_listParts(_p, _r, _seqid).await,
                17usize => self.handle_multiPut(_p, _r, _seqid).await,
                18usize => self.handle_get(_p, _r, _seqid).await,
                19usize => self.handle_multiGet(_p, _r, _seqid).await,
                20usize => self.handle_remove(_p, _r, _seqid).await,
                21usize => self.handle_removeRange(_p, _r, _seqid).await,
                22usize => self.handle_scan(_p, _r, _seqid).await,
                23usize => self.handle_createTagIndex(_p, _r, _seqid).await,
                24usize => self.handle_dropTagIndex(_p, _r, _seqid).await,
                25usize => self.handle_getTagIndex(_p, _r, _seqid).await,
                26usize => self.handle_listTagIndexes(_p, _r, _seqid).await,
                27usize => self.handle_rebuildTagIndex(_p, _r, _seqid).await,
                28usize => self.handle_listTagIndexStatus(_p, _r, _seqid).await,
                29usize => self.handle_createEdgeIndex(_p, _r, _seqid).await,
                30usize => self.handle_dropEdgeIndex(_p, _r, _seqid).await,
                31usize => self.handle_getEdgeIndex(_p, _r, _seqid).await,
                32usize => self.handle_listEdgeIndexes(_p, _r, _seqid).await,
                33usize => self.handle_rebuildEdgeIndex(_p, _r, _seqid).await,
                34usize => self.handle_listEdgeIndexStatus(_p, _r, _seqid).await,
                35usize => self.handle_createUser(_p, _r, _seqid).await,
                36usize => self.handle_dropUser(_p, _r, _seqid).await,
                37usize => self.handle_alterUser(_p, _r, _seqid).await,
                38usize => self.handle_grantRole(_p, _r, _seqid).await,
                39usize => self.handle_revokeRole(_p, _r, _seqid).await,
                40usize => self.handle_listUsers(_p, _r, _seqid).await,
                41usize => self.handle_listRoles(_p, _r, _seqid).await,
                42usize => self.handle_getUserRoles(_p, _r, _seqid).await,
                43usize => self.handle_changePassword(_p, _r, _seqid).await,
                44usize => self.handle_heartBeat(_p, _r, _seqid).await,
                45usize => self.handle_balance(_p, _r, _seqid).await,
                46usize => self.handle_leaderBalance(_p, _r, _seqid).await,
                47usize => self.handle_regConfig(_p, _r, _seqid).await,
                48usize => self.handle_getConfig(_p, _r, _seqid).await,
                49usize => self.handle_setConfig(_p, _r, _seqid).await,
                50usize => self.handle_listConfigs(_p, _r, _seqid).await,
                51usize => self.handle_createSnapshot(_p, _r, _seqid).await,
                52usize => self.handle_dropSnapshot(_p, _r, _seqid).await,
                53usize => self.handle_listSnapshots(_p, _r, _seqid).await,
                54usize => self.handle_runAdminJob(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "MetaServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_MetaService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(MyService::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct MetaService<'mock> {
        pub createSpace: r#impl::meta_service::createSpace<'mock>,
        pub dropSpace: r#impl::meta_service::dropSpace<'mock>,
        pub getSpace: r#impl::meta_service::getSpace<'mock>,
        pub listSpaces: r#impl::meta_service::listSpaces<'mock>,
        pub createTag: r#impl::meta_service::createTag<'mock>,
        pub alterTag: r#impl::meta_service::alterTag<'mock>,
        pub dropTag: r#impl::meta_service::dropTag<'mock>,
        pub getTag: r#impl::meta_service::getTag<'mock>,
        pub listTags: r#impl::meta_service::listTags<'mock>,
        pub createEdge: r#impl::meta_service::createEdge<'mock>,
        pub alterEdge: r#impl::meta_service::alterEdge<'mock>,
        pub dropEdge: r#impl::meta_service::dropEdge<'mock>,
        pub getEdge: r#impl::meta_service::getEdge<'mock>,
        pub listEdges: r#impl::meta_service::listEdges<'mock>,
        pub listHosts: r#impl::meta_service::listHosts<'mock>,
        pub getPartsAlloc: r#impl::meta_service::getPartsAlloc<'mock>,
        pub listParts: r#impl::meta_service::listParts<'mock>,
        pub multiPut: r#impl::meta_service::multiPut<'mock>,
        pub get: r#impl::meta_service::get<'mock>,
        pub multiGet: r#impl::meta_service::multiGet<'mock>,
        pub remove: r#impl::meta_service::remove<'mock>,
        pub removeRange: r#impl::meta_service::removeRange<'mock>,
        pub scan: r#impl::meta_service::scan<'mock>,
        pub createTagIndex: r#impl::meta_service::createTagIndex<'mock>,
        pub dropTagIndex: r#impl::meta_service::dropTagIndex<'mock>,
        pub getTagIndex: r#impl::meta_service::getTagIndex<'mock>,
        pub listTagIndexes: r#impl::meta_service::listTagIndexes<'mock>,
        pub rebuildTagIndex: r#impl::meta_service::rebuildTagIndex<'mock>,
        pub listTagIndexStatus: r#impl::meta_service::listTagIndexStatus<'mock>,
        pub createEdgeIndex: r#impl::meta_service::createEdgeIndex<'mock>,
        pub dropEdgeIndex: r#impl::meta_service::dropEdgeIndex<'mock>,
        pub getEdgeIndex: r#impl::meta_service::getEdgeIndex<'mock>,
        pub listEdgeIndexes: r#impl::meta_service::listEdgeIndexes<'mock>,
        pub rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex<'mock>,
        pub listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus<'mock>,
        pub createUser: r#impl::meta_service::createUser<'mock>,
        pub dropUser: r#impl::meta_service::dropUser<'mock>,
        pub alterUser: r#impl::meta_service::alterUser<'mock>,
        pub grantRole: r#impl::meta_service::grantRole<'mock>,
        pub revokeRole: r#impl::meta_service::revokeRole<'mock>,
        pub listUsers: r#impl::meta_service::listUsers<'mock>,
        pub listRoles: r#impl::meta_service::listRoles<'mock>,
        pub getUserRoles: r#impl::meta_service::getUserRoles<'mock>,
        pub changePassword: r#impl::meta_service::changePassword<'mock>,
        pub heartBeat: r#impl::meta_service::heartBeat<'mock>,
        pub balance: r#impl::meta_service::balance<'mock>,
        pub leaderBalance: r#impl::meta_service::leaderBalance<'mock>,
        pub regConfig: r#impl::meta_service::regConfig<'mock>,
        pub getConfig: r#impl::meta_service::getConfig<'mock>,
        pub setConfig: r#impl::meta_service::setConfig<'mock>,
        pub listConfigs: r#impl::meta_service::listConfigs<'mock>,
        pub createSnapshot: r#impl::meta_service::createSnapshot<'mock>,
        pub dropSnapshot: r#impl::meta_service::dropSnapshot<'mock>,
        pub listSnapshots: r#impl::meta_service::listSnapshots<'mock>,
        pub runAdminJob: r#impl::meta_service::runAdminJob<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::MetaService {
        pub fn mock<'mock>() -> MetaService<'mock> {
            MetaService {
                createSpace: r#impl::meta_service::createSpace::unimplemented(),
                dropSpace: r#impl::meta_service::dropSpace::unimplemented(),
                getSpace: r#impl::meta_service::getSpace::unimplemented(),
                listSpaces: r#impl::meta_service::listSpaces::unimplemented(),
                createTag: r#impl::meta_service::createTag::unimplemented(),
                alterTag: r#impl::meta_service::alterTag::unimplemented(),
                dropTag: r#impl::meta_service::dropTag::unimplemented(),
                getTag: r#impl::meta_service::getTag::unimplemented(),
                listTags: r#impl::meta_service::listTags::unimplemented(),
                createEdge: r#impl::meta_service::createEdge::unimplemented(),
                alterEdge: r#impl::meta_service::alterEdge::unimplemented(),
                dropEdge: r#impl::meta_service::dropEdge::unimplemented(),
                getEdge: r#impl::meta_service::getEdge::unimplemented(),
                listEdges: r#impl::meta_service::listEdges::unimplemented(),
                listHosts: r#impl::meta_service::listHosts::unimplemented(),
                getPartsAlloc: r#impl::meta_service::getPartsAlloc::unimplemented(),
                listParts: r#impl::meta_service::listParts::unimplemented(),
                multiPut: r#impl::meta_service::multiPut::unimplemented(),
                get: r#impl::meta_service::get::unimplemented(),
                multiGet: r#impl::meta_service::multiGet::unimplemented(),
                remove: r#impl::meta_service::remove::unimplemented(),
                removeRange: r#impl::meta_service::removeRange::unimplemented(),
                scan: r#impl::meta_service::scan::unimplemented(),
                createTagIndex: r#impl::meta_service::createTagIndex::unimplemented(),
                dropTagIndex: r#impl::meta_service::dropTagIndex::unimplemented(),
                getTagIndex: r#impl::meta_service::getTagIndex::unimplemented(),
                listTagIndexes: r#impl::meta_service::listTagIndexes::unimplemented(),
                rebuildTagIndex: r#impl::meta_service::rebuildTagIndex::unimplemented(),
                listTagIndexStatus: r#impl::meta_service::listTagIndexStatus::unimplemented(),
                createEdgeIndex: r#impl::meta_service::createEdgeIndex::unimplemented(),
                dropEdgeIndex: r#impl::meta_service::dropEdgeIndex::unimplemented(),
                getEdgeIndex: r#impl::meta_service::getEdgeIndex::unimplemented(),
                listEdgeIndexes: r#impl::meta_service::listEdgeIndexes::unimplemented(),
                rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex::unimplemented(),
                listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus::unimplemented(),
                createUser: r#impl::meta_service::createUser::unimplemented(),
                dropUser: r#impl::meta_service::dropUser::unimplemented(),
                alterUser: r#impl::meta_service::alterUser::unimplemented(),
                grantRole: r#impl::meta_service::grantRole::unimplemented(),
                revokeRole: r#impl::meta_service::revokeRole::unimplemented(),
                listUsers: r#impl::meta_service::listUsers::unimplemented(),
                listRoles: r#impl::meta_service::listRoles::unimplemented(),
                getUserRoles: r#impl::meta_service::getUserRoles::unimplemented(),
                changePassword: r#impl::meta_service::changePassword::unimplemented(),
                heartBeat: r#impl::meta_service::heartBeat::unimplemented(),
                balance: r#impl::meta_service::balance::unimplemented(),
                leaderBalance: r#impl::meta_service::leaderBalance::unimplemented(),
                regConfig: r#impl::meta_service::regConfig::unimplemented(),
                getConfig: r#impl::meta_service::getConfig::unimplemented(),
                setConfig: r#impl::meta_service::setConfig::unimplemented(),
                listConfigs: r#impl::meta_service::listConfigs::unimplemented(),
                createSnapshot: r#impl::meta_service::createSnapshot::unimplemented(),
                dropSnapshot: r#impl::meta_service::dropSnapshot::unimplemented(),
                listSnapshots: r#impl::meta_service::listSnapshots::unimplemented(),
                runAdminJob: r#impl::meta_service::runAdminJob::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::MetaService for MetaService<'mock> {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listSpaces.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getPartsAlloc.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.multiPut.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.multiGet.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.scan.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTagIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTagIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdgeIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdgeIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.grantRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.revokeRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listUsers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getUserRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.changePassword.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.heartBeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::HBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.balance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.leaderBalance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.regConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listConfigs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listSnapshots.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.runAdminJob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod meta_service {

            pub struct createSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createSpace<'mock> {
                pub fn unimplemented() -> Self {
                    createSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropSpace<'mock> {
                pub fn unimplemented() -> Self {
                    dropSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<
                        crate::types::GetSpaceResp,
                        crate::errors::meta_service::GetSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSpace<'mock> {
                pub fn unimplemented() -> Self {
                    getSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSpaceResp) {
                    self.mock(move |_: crate::types::GetSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> crate::types::GetSpaceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSpaces<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<
                        crate::types::ListSpacesResp,
                        crate::errors::meta_service::ListSpacesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listSpaces<'mock> {
                pub fn unimplemented() -> Self {
                    listSpaces {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSpacesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSpaces",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSpacesResp) {
                    self.mock(move |_: crate::types::ListSpacesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> crate::types::ListSpacesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSpacesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSpacesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createTag<'mock> {
                pub fn unimplemented() -> Self {
                    createTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterTag<'mock> {
                pub fn unimplemented() -> Self {
                    alterTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropTag<'mock> {
                pub fn unimplemented() -> Self {
                    dropTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<
                        crate::types::GetTagResp,
                        crate::errors::meta_service::GetTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTag<'mock> {
                pub fn unimplemented() -> Self {
                    getTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagResp) {
                    self.mock(move |_: crate::types::GetTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> crate::types::GetTagResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<
                        crate::types::ListTagsResp,
                        crate::errors::meta_service::ListTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTags<'mock> {
                pub fn unimplemented() -> Self {
                    listTags {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagsResp) {
                    self.mock(move |_: crate::types::ListTagsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> crate::types::ListTagsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createEdge<'mock> {
                pub fn unimplemented() -> Self {
                    createEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterEdge<'mock> {
                pub fn unimplemented() -> Self {
                    alterEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropEdge<'mock> {
                pub fn unimplemented() -> Self {
                    dropEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<
                        crate::types::GetEdgeResp,
                        crate::errors::meta_service::GetEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEdge<'mock> {
                pub fn unimplemented() -> Self {
                    getEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeResp) {
                    self.mock(move |_: crate::types::GetEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> crate::types::GetEdgeResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<
                        crate::types::ListEdgesResp,
                        crate::errors::meta_service::ListEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdges<'mock> {
                pub fn unimplemented() -> Self {
                    listEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgesResp) {
                    self.mock(move |_: crate::types::ListEdgesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> crate::types::ListEdgesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<
                        crate::types::ListHostsResp,
                        crate::errors::meta_service::ListHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listHosts<'mock> {
                pub fn unimplemented() -> Self {
                    listHosts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListHostsResp) {
                    self.mock(move |_: crate::types::ListHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> crate::types::ListHostsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPartsAlloc<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<
                        crate::types::GetPartsAllocResp,
                        crate::errors::meta_service::GetPartsAllocError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getPartsAlloc<'mock> {
                pub fn unimplemented() -> Self {
                    getPartsAlloc {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPartsAllocReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getPartsAlloc",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPartsAllocResp) {
                    self.mock(move |_: crate::types::GetPartsAllocReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> crate::types::GetPartsAllocResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetPartsAllocError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPartsAllocReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<
                        crate::types::ListPartsResp,
                        crate::errors::meta_service::ListPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listParts<'mock> {
                pub fn unimplemented() -> Self {
                    listParts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListPartsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListPartsResp) {
                    self.mock(move |_: crate::types::ListPartsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> crate::types::ListPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListPartsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiPut<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::MultiPutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> multiPut<'mock> {
                pub fn unimplemented() -> Self {
                    multiPut {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiPutReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiPut",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::MultiPutReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiPutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiPutReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<
                        crate::types::GetResp,
                        crate::errors::meta_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    get {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetResp) {
                    self.mock(move |_: crate::types::GetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> crate::types::GetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiGet<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<
                        crate::types::MultiGetResp,
                        crate::errors::meta_service::MultiGetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> multiGet<'mock> {
                pub fn unimplemented() -> Self {
                    multiGet {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiGetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiGet",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::MultiGetResp) {
                    self.mock(move |_: crate::types::MultiGetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> crate::types::MultiGetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiGetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiGetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    remove {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    removeRange {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveRangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scan<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<
                        crate::types::ScanResp,
                        crate::errors::meta_service::ScanError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> scan<'mock> {
                pub fn unimplemented() -> Self {
                    scan {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "scan",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanResp) {
                    self.mock(move |_: crate::types::ScanReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> crate::types::ScanResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ScanError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    createTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    dropTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<
                        crate::types::GetTagIndexResp,
                        crate::errors::meta_service::GetTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    getTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagIndexResp) {
                    self.mock(move |_: crate::types::GetTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> crate::types::GetTagIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<
                        crate::types::ListTagIndexesResp,
                        crate::errors::meta_service::ListTagIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTagIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    listTagIndexes {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagIndexesResp) {
                    self.mock(move |_: crate::types::ListTagIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> crate::types::ListTagIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListTagIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTagIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    listTagIndexStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    createEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    dropEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<
                        crate::types::GetEdgeIndexResp,
                        crate::errors::meta_service::GetEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    getEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeIndexResp) {
                    self.mock(move |_: crate::types::GetEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> crate::types::GetEdgeIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<
                        crate::types::ListEdgeIndexesResp,
                        crate::errors::meta_service::ListEdgeIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdgeIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    listEdgeIndexes {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgeIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgeIndexesResp) {
                    self.mock(move |_: crate::types::ListEdgeIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> crate::types::ListEdgeIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgeIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListEdgeIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdgeIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    listEdgeIndexStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createUser<'mock> {
                pub fn unimplemented() -> Self {
                    createUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropUser<'mock> {
                pub fn unimplemented() -> Self {
                    dropUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterUser<'mock> {
                pub fn unimplemented() -> Self {
                    alterUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct grantRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::GrantRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> grantRole<'mock> {
                pub fn unimplemented() -> Self {
                    grantRole {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GrantRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "grantRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::GrantRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GrantRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GrantRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct revokeRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RevokeRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> revokeRole<'mock> {
                pub fn unimplemented() -> Self {
                    revokeRole {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RevokeRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "revokeRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RevokeRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RevokeRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RevokeRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listUsers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<
                        crate::types::ListUsersResp,
                        crate::errors::meta_service::ListUsersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listUsers<'mock> {
                pub fn unimplemented() -> Self {
                    listUsers {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListUsersReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listUsers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListUsersResp) {
                    self.mock(move |_: crate::types::ListUsersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> crate::types::ListUsersResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListUsersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListUsersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::ListRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listRoles<'mock> {
                pub fn unimplemented() -> Self {
                    listRoles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::ListRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUserRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::GetUserRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getUserRoles<'mock> {
                pub fn unimplemented() -> Self {
                    getUserRoles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUserRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getUserRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::GetUserRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetUserRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUserRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct changePassword<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ChangePasswordError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> changePassword<'mock> {
                pub fn unimplemented() -> Self {
                    changePassword {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChangePasswordReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "changePassword",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ChangePasswordReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ChangePasswordError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChangePasswordReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct heartBeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<
                        crate::types::HBResp,
                        crate::errors::meta_service::HeartBeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> heartBeat<'mock> {
                pub fn unimplemented() -> Self {
                    heartBeat {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::HBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "heartBeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::HBResp) {
                    self.mock(move |_: crate::types::HBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> crate::types::HBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::HeartBeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::HBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct balance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<
                        crate::types::BalanceResp,
                        crate::errors::meta_service::BalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> balance<'mock> {
                pub fn unimplemented() -> Self {
                    balance {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "balance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::BalanceResp) {
                    self.mock(move |_: crate::types::BalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> crate::types::BalanceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::BalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct leaderBalance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::LeaderBalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> leaderBalance<'mock> {
                pub fn unimplemented() -> Self {
                    leaderBalance {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LeaderBalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "leaderBalance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::LeaderBalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::LeaderBalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LeaderBalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct regConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RegConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> regConfig<'mock> {
                pub fn unimplemented() -> Self {
                    regConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RegConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "regConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RegConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RegConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RegConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<
                        crate::types::GetConfigResp,
                        crate::errors::meta_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    getConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetConfigResp) {
                    self.mock(move |_: crate::types::GetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> crate::types::GetConfigResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setConfig<'mock> {
                pub fn unimplemented() -> Self {
                    setConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "setConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listConfigs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<
                        crate::types::ListConfigsResp,
                        crate::errors::meta_service::ListConfigsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listConfigs<'mock> {
                pub fn unimplemented() -> Self {
                    listConfigs {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListConfigsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listConfigs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListConfigsResp) {
                    self.mock(move |_: crate::types::ListConfigsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> crate::types::ListConfigsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListConfigsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListConfigsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    createSnapshot {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    dropSnapshot {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSnapshots<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<
                        crate::types::ListSnapshotsResp,
                        crate::errors::meta_service::ListSnapshotsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listSnapshots<'mock> {
                pub fn unimplemented() -> Self {
                    listSnapshots {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSnapshotsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSnapshots",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSnapshotsResp) {
                    self.mock(move |_: crate::types::ListSnapshotsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> crate::types::ListSnapshotsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSnapshotsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSnapshotsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct runAdminJob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<
                        crate::types::AdminJobResp,
                        crate::errors::meta_service::RunAdminJobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> runAdminJob<'mock> {
                pub fn unimplemented() -> Self {
                    runAdminJob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AdminJobReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "runAdminJob",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminJobResp) {
                    self.mock(move |_: crate::types::AdminJobReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> crate::types::AdminJobResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RunAdminJobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AdminJobReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod meta_service {

        pub type CreateSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type DropSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type ListSpacesError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateTagError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterTagError = ::fbthrift::NonthrowingFunctionError;

        pub type DropTagError = ::fbthrift::NonthrowingFunctionError;

        pub type GetTagError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type DropEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type GetEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type ListHostsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetPartsAllocError = ::fbthrift::NonthrowingFunctionError;

        pub type ListPartsError = ::fbthrift::NonthrowingFunctionError;

        pub type MultiPutError = ::fbthrift::NonthrowingFunctionError;

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        pub type MultiGetError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        pub type ScanError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type DropTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type GetTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagIndexesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type DropEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type GetEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgeIndexesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgeIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateUserError = ::fbthrift::NonthrowingFunctionError;

        pub type DropUserError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterUserError = ::fbthrift::NonthrowingFunctionError;

        pub type GrantRoleError = ::fbthrift::NonthrowingFunctionError;

        pub type RevokeRoleError = ::fbthrift::NonthrowingFunctionError;

        pub type ListUsersError = ::fbthrift::NonthrowingFunctionError;

        pub type ListRolesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetUserRolesError = ::fbthrift::NonthrowingFunctionError;

        pub type ChangePasswordError = ::fbthrift::NonthrowingFunctionError;

        pub type HeartBeatError = ::fbthrift::NonthrowingFunctionError;

        pub type BalanceError = ::fbthrift::NonthrowingFunctionError;

        pub type LeaderBalanceError = ::fbthrift::NonthrowingFunctionError;

        pub type RegConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type GetConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type SetConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type ListConfigsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateSnapshotError = ::fbthrift::NonthrowingFunctionError;

        pub type DropSnapshotError = ::fbthrift::NonthrowingFunctionError;

        pub type ListSnapshotsError = ::fbthrift::NonthrowingFunctionError;

        pub type RunAdminJobError = ::fbthrift::NonthrowingFunctionError;

    }

}
