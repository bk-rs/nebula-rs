// @generated by Thrift for src/interface/common.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `common`.

#![allow(clippy::redundant_closure)]


pub type ClusterID = ::std::primitive::i64;

pub type GraphSpaceID = ::std::primitive::i32;

pub type PartitionID = ::std::primitive::i32;

pub type TagID = ::std::primitive::i32;

pub type EdgeType = ::std::primitive::i32;

pub type EdgeRanking = ::std::primitive::i64;

pub type LogID = ::std::primitive::i64;

pub type TermID = ::std::primitive::i64;

pub type Timestamp = ::std::primitive::i64;

pub type IndexID = ::std::primitive::i32;

pub type Port = ::std::primitive::i32;

pub type SessionID = ::std::primitive::i64;

pub type ExecutionPlanID = ::std::primitive::i64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SchemaID {
    tag_id(crate::types::TagID),
    edge_type(crate::types::EdgeType),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Date {
    pub year: ::std::primitive::i16,
    pub month: ::std::primitive::i8,
    pub day: ::std::primitive::i8,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Time {
    pub hour: ::std::primitive::i8,
    pub minute: ::std::primitive::i8,
    pub sec: ::std::primitive::i8,
    pub microsec: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DateTime {
    pub year: ::std::primitive::i16,
    pub month: ::std::primitive::i8,
    pub day: ::std::primitive::i8,
    pub hour: ::std::primitive::i8,
    pub minute: ::std::primitive::i8,
    pub sec: ::std::primitive::i8,
    pub microsec: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Debug, Eq, PartialOrd, Ord)]
pub enum Value {
    nVal(crate::types::NullType),
    bVal(::std::primitive::bool),
    iVal(::std::primitive::i64),
    fVal(crate::double::Double),
    sVal(::std::vec::Vec<::std::primitive::u8>),
    dVal(crate::types::Date),
    tVal(crate::types::Time),
    dtVal(crate::types::DateTime),
    vVal(Box<crate::types::Vertex>),
    eVal(crate::types::Edge),
    pVal(crate::types::Path),
    lVal(crate::types::NList),
    mVal(crate::types::NMap),
    uVal(crate::types::NSet),
    gVal(crate::types::DataSet),
    ggVal(crate::types::Geography),
    duVal(crate::types::Duration),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NList {
    pub values: ::std::vec::Vec<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NMap {
    pub kvs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NSet {
    pub values: ::std::collections::BTreeSet<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Row {
    pub values: ::std::vec::Vec<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct DataSet {
    pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub rows: ::std::vec::Vec<crate::types::Row>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Coordinate {
    pub x: crate::double::Double,
    pub y: crate::double::Double,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Point {
    pub coord: crate::types::Coordinate,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct LineString {
    pub coordList: ::std::vec::Vec<crate::types::Coordinate>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Polygon {
    pub coordListList: ::std::vec::Vec<::std::vec::Vec<crate::types::Coordinate>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Debug, Eq, PartialOrd, Ord)]
pub enum Geography {
    ptVal(crate::types::Point),
    lsVal(crate::types::LineString),
    pgVal(crate::types::Polygon),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Tag {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Vertex {
    pub vid: Box<crate::types::Value>,
    pub tags: ::std::vec::Vec<crate::types::Tag>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Edge {
    pub src: Box<crate::types::Value>,
    pub dst: Box<crate::types::Value>,
    pub r#type: crate::types::EdgeType,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub ranking: crate::types::EdgeRanking,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Step {
    pub dst: crate::types::Vertex,
    pub r#type: crate::types::EdgeType,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub ranking: crate::types::EdgeRanking,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Path {
    pub src: crate::types::Vertex,
    pub steps: ::std::vec::Vec<crate::types::Step>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HostAddr {
    pub host: ::std::string::String,
    pub port: crate::types::Port,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyValue {
    pub key: ::std::vec::Vec<::std::primitive::u8>,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Duration {
    pub seconds: ::std::primitive::i64,
    pub microseconds: ::std::primitive::i32,
    pub months: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LogInfo {
    pub log_id: crate::types::LogID,
    pub term_id: crate::types::TermID,
    pub commit_log_id: crate::types::LogID,
    pub checkpoint_path: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DirInfo {
    pub root: ::std::vec::Vec<::std::primitive::u8>,
    pub data: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct CheckpointInfo {
    pub space_id: crate::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<crate::types::PartitionID, crate::types::LogInfo>,
    pub data_path: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LogEntry {
    pub cluster: crate::types::ClusterID,
    pub log_str: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NullType(pub ::std::primitive::i32);

impl NullType {
    pub const __NULL__: Self = NullType(0i32);
    pub const NaN: Self = NullType(1i32);
    pub const BAD_DATA: Self = NullType(2i32);
    pub const BAD_TYPE: Self = NullType(3i32);
    pub const ERR_OVERFLOW: Self = NullType(4i32);
    pub const UNKNOWN_PROP: Self = NullType(5i32);
    pub const DIV_BY_ZERO: Self = NullType(6i32);
    pub const OUT_OF_RANGE: Self = NullType(7i32);
}

impl ::fbthrift::ThriftEnum for NullType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::__NULL__, "__NULL__"),
            (Self::NaN, "NaN"),
            (Self::BAD_DATA, "BAD_DATA"),
            (Self::BAD_TYPE, "BAD_TYPE"),
            (Self::ERR_OVERFLOW, "ERR_OVERFLOW"),
            (Self::UNKNOWN_PROP, "UNKNOWN_PROP"),
            (Self::DIV_BY_ZERO, "DIV_BY_ZERO"),
            (Self::OUT_OF_RANGE, "OUT_OF_RANGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "__NULL__",
            "NaN",
            "BAD_DATA",
            "BAD_TYPE",
            "ERR_OVERFLOW",
            "UNKNOWN_PROP",
            "DIV_BY_ZERO",
            "OUT_OF_RANGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::__NULL__,
            Self::NaN,
            Self::BAD_DATA,
            Self::BAD_TYPE,
            Self::ERR_OVERFLOW,
            Self::UNKNOWN_PROP,
            Self::DIV_BY_ZERO,
            Self::OUT_OF_RANGE,
        ]
    }
}

impl ::std::default::Default for NullType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a NullType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a NullType) -> Self {
        x.0
    }
}

impl ::std::convert::From<NullType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: NullType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for NullType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for NullType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("__NULL__", 0),
            ("NaN", 1),
            ("BAD_DATA", 2),
            ("BAD_TYPE", 3),
            ("ERR_OVERFLOW", 4),
            ("UNKNOWN_PROP", 5),
            ("DIV_BY_ZERO", 6),
            ("OUT_OF_RANGE", 7),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for NullType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "NullType::{}", self)
    }
}

impl ::std::str::FromStr for NullType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BAD_DATA", 2),
            ("BAD_TYPE", 3),
            ("DIV_BY_ZERO", 6),
            ("ERR_OVERFLOW", 4),
            ("NaN", 1),
            ("OUT_OF_RANGE", 7),
            ("UNKNOWN_PROP", 5),
            ("__NULL__", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "NullType").map(Self)
    }
}

impl ::fbthrift::GetTType for NullType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for NullType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for NullType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PropertyType(pub ::std::primitive::i32);

impl PropertyType {
    pub const UNKNOWN: Self = PropertyType(0i32);
    pub const BOOL: Self = PropertyType(1i32);
    pub const INT64: Self = PropertyType(2i32);
    pub const VID: Self = PropertyType(3i32);
    pub const FLOAT: Self = PropertyType(4i32);
    pub const DOUBLE: Self = PropertyType(5i32);
    pub const STRING: Self = PropertyType(6i32);
    pub const FIXED_STRING: Self = PropertyType(7i32);
    pub const INT8: Self = PropertyType(8i32);
    pub const INT16: Self = PropertyType(9i32);
    pub const INT32: Self = PropertyType(10i32);
    pub const TIMESTAMP: Self = PropertyType(21i32);
    pub const DURATION: Self = PropertyType(23i32);
    pub const DATE: Self = PropertyType(24i32);
    pub const DATETIME: Self = PropertyType(25i32);
    pub const TIME: Self = PropertyType(26i32);
    pub const GEOGRAPHY: Self = PropertyType(31i32);
}

impl ::fbthrift::ThriftEnum for PropertyType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::BOOL, "BOOL"),
            (Self::INT64, "INT64"),
            (Self::VID, "VID"),
            (Self::FLOAT, "FLOAT"),
            (Self::DOUBLE, "DOUBLE"),
            (Self::STRING, "STRING"),
            (Self::FIXED_STRING, "FIXED_STRING"),
            (Self::INT8, "INT8"),
            (Self::INT16, "INT16"),
            (Self::INT32, "INT32"),
            (Self::TIMESTAMP, "TIMESTAMP"),
            (Self::DURATION, "DURATION"),
            (Self::DATE, "DATE"),
            (Self::DATETIME, "DATETIME"),
            (Self::TIME, "TIME"),
            (Self::GEOGRAPHY, "GEOGRAPHY"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "BOOL",
            "INT64",
            "VID",
            "FLOAT",
            "DOUBLE",
            "STRING",
            "FIXED_STRING",
            "INT8",
            "INT16",
            "INT32",
            "TIMESTAMP",
            "DURATION",
            "DATE",
            "DATETIME",
            "TIME",
            "GEOGRAPHY",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::BOOL,
            Self::INT64,
            Self::VID,
            Self::FLOAT,
            Self::DOUBLE,
            Self::STRING,
            Self::FIXED_STRING,
            Self::INT8,
            Self::INT16,
            Self::INT32,
            Self::TIMESTAMP,
            Self::DURATION,
            Self::DATE,
            Self::DATETIME,
            Self::TIME,
            Self::GEOGRAPHY,
        ]
    }
}

impl ::std::default::Default for PropertyType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a PropertyType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a PropertyType) -> Self {
        x.0
    }
}

impl ::std::convert::From<PropertyType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: PropertyType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for PropertyType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for PropertyType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("BOOL", 1),
            ("INT64", 2),
            ("VID", 3),
            ("FLOAT", 4),
            ("DOUBLE", 5),
            ("STRING", 6),
            ("FIXED_STRING", 7),
            ("INT8", 8),
            ("INT16", 9),
            ("INT32", 10),
            ("TIMESTAMP", 21),
            ("DURATION", 23),
            ("DATE", 24),
            ("DATETIME", 25),
            ("TIME", 26),
            ("GEOGRAPHY", 31),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for PropertyType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "PropertyType::{}", self)
    }
}

impl ::std::str::FromStr for PropertyType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BOOL", 1),
            ("DATE", 24),
            ("DATETIME", 25),
            ("DOUBLE", 5),
            ("DURATION", 23),
            ("FIXED_STRING", 7),
            ("FLOAT", 4),
            ("GEOGRAPHY", 31),
            ("INT16", 9),
            ("INT32", 10),
            ("INT64", 2),
            ("INT8", 8),
            ("STRING", 6),
            ("TIME", 26),
            ("TIMESTAMP", 21),
            ("UNKNOWN", 0),
            ("VID", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "PropertyType").map(Self)
    }
}

impl ::fbthrift::GetTType for PropertyType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for PropertyType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for PropertyType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ErrorCode(pub ::std::primitive::i32);

impl ErrorCode {
    pub const SUCCEEDED: Self = ErrorCode(0i32);
    pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
    pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
    pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
    pub const E_LEADER_CHANGED: Self = ErrorCode(-4i32);
    pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-5i32);
    pub const E_TAG_NOT_FOUND: Self = ErrorCode(-6i32);
    pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-7i32);
    pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-8i32);
    pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-9i32);
    pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-10i32);
    pub const E_ROLE_NOT_FOUND: Self = ErrorCode(-11i32);
    pub const E_CONFIG_NOT_FOUND: Self = ErrorCode(-12i32);
    pub const E_MACHINE_NOT_FOUND: Self = ErrorCode(-13i32);
    pub const E_ZONE_NOT_FOUND: Self = ErrorCode(-14i32);
    pub const E_LISTENER_NOT_FOUND: Self = ErrorCode(-15i32);
    pub const E_PART_NOT_FOUND: Self = ErrorCode(-16i32);
    pub const E_KEY_NOT_FOUND: Self = ErrorCode(-17i32);
    pub const E_USER_NOT_FOUND: Self = ErrorCode(-18i32);
    pub const E_STATS_NOT_FOUND: Self = ErrorCode(-19i32);
    pub const E_SERVICE_NOT_FOUND: Self = ErrorCode(-20i32);
    pub const E_BACKUP_FAILED: Self = ErrorCode(-24i32);
    pub const E_BACKUP_EMPTY_TABLE: Self = ErrorCode(-25i32);
    pub const E_BACKUP_TABLE_FAILED: Self = ErrorCode(-26i32);
    pub const E_PARTIAL_RESULT: Self = ErrorCode(-27i32);
    pub const E_REBUILD_INDEX_FAILED: Self = ErrorCode(-28i32);
    pub const E_INVALID_PASSWORD: Self = ErrorCode(-29i32);
    pub const E_FAILED_GET_ABS_PATH: Self = ErrorCode(-30i32);
    pub const E_BAD_USERNAME_PASSWORD: Self = ErrorCode(-1001i32);
    pub const E_SESSION_INVALID: Self = ErrorCode(-1002i32);
    pub const E_SESSION_TIMEOUT: Self = ErrorCode(-1003i32);
    pub const E_SYNTAX_ERROR: Self = ErrorCode(-1004i32);
    pub const E_EXECUTION_ERROR: Self = ErrorCode(-1005i32);
    pub const E_STATEMENT_EMPTY: Self = ErrorCode(-1006i32);
    pub const E_BAD_PERMISSION: Self = ErrorCode(-1008i32);
    pub const E_SEMANTIC_ERROR: Self = ErrorCode(-1009i32);
    pub const E_TOO_MANY_CONNECTIONS: Self = ErrorCode(-1010i32);
    pub const E_PARTIAL_SUCCEEDED: Self = ErrorCode(-1011i32);
    pub const E_NO_HOSTS: Self = ErrorCode(-2001i32);
    pub const E_EXISTED: Self = ErrorCode(-2002i32);
    pub const E_INVALID_HOST: Self = ErrorCode(-2003i32);
    pub const E_UNSUPPORTED: Self = ErrorCode(-2004i32);
    pub const E_NOT_DROP: Self = ErrorCode(-2005i32);
    pub const E_BALANCER_RUNNING: Self = ErrorCode(-2006i32);
    pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-2007i32);
    pub const E_CONFLICT: Self = ErrorCode(-2008i32);
    pub const E_INVALID_PARM: Self = ErrorCode(-2009i32);
    pub const E_WRONGCLUSTER: Self = ErrorCode(-2010i32);
    pub const E_ZONE_NOT_ENOUGH: Self = ErrorCode(-2011i32);
    pub const E_ZONE_IS_EMPTY: Self = ErrorCode(-2012i32);
    pub const E_SCHEMA_NAME_EXISTS: Self = ErrorCode(-2013i32);
    pub const E_RELATED_INDEX_EXISTS: Self = ErrorCode(-2014i32);
    pub const E_RELATED_SPACE_EXISTS: Self = ErrorCode(-2015i32);
    pub const E_STORE_FAILURE: Self = ErrorCode(-2021i32);
    pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-2022i32);
    pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-2023i32);
    pub const E_BALANCED: Self = ErrorCode(-2024i32);
    pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-2025i32);
    pub const E_NO_VALID_HOST: Self = ErrorCode(-2026i32);
    pub const E_CORRUPTED_BALANCE_PLAN: Self = ErrorCode(-2027i32);
    pub const E_NO_INVALID_BALANCE_PLAN: Self = ErrorCode(-2028i32);
    pub const E_IMPROPER_ROLE: Self = ErrorCode(-2030i32);
    pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-2031i32);
    pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-2032i32);
    pub const E_INVALID_CHARSET: Self = ErrorCode(-2033i32);
    pub const E_INVALID_COLLATE: Self = ErrorCode(-2034i32);
    pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-2035i32);
    pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-2040i32);
    pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-2041i32);
    pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-2042i32);
    pub const E_INDEX_WITH_TTL: Self = ErrorCode(-2043i32);
    pub const E_ADD_JOB_FAILURE: Self = ErrorCode(-2044i32);
    pub const E_STOP_JOB_FAILURE: Self = ErrorCode(-2045i32);
    pub const E_SAVE_JOB_FAILURE: Self = ErrorCode(-2046i32);
    pub const E_BALANCER_FAILURE: Self = ErrorCode(-2047i32);
    pub const E_JOB_NOT_FINISHED: Self = ErrorCode(-2048i32);
    pub const E_TASK_REPORT_OUT_DATE: Self = ErrorCode(-2049i32);
    pub const E_JOB_NOT_IN_SPACE: Self = ErrorCode(-2050i32);
    pub const E_JOB_NEED_RECOVER: Self = ErrorCode(-2051i32);
    pub const E_JOB_ALREADY_FINISH: Self = ErrorCode(-2052i32);
    pub const E_JOB_SUBMITTED: Self = ErrorCode(-2053i32);
    pub const E_JOB_NOT_STOPPABLE: Self = ErrorCode(-2054i32);
    pub const E_JOB_HAS_NO_TARGET_STORAGE: Self = ErrorCode(-2055i32);
    pub const E_INVALID_JOB: Self = ErrorCode(-2065i32);
    pub const E_BACKUP_BUILDING_INDEX: Self = ErrorCode(-2066i32);
    pub const E_BACKUP_SPACE_NOT_FOUND: Self = ErrorCode(-2067i32);
    pub const E_RESTORE_FAILURE: Self = ErrorCode(-2068i32);
    pub const E_SESSION_NOT_FOUND: Self = ErrorCode(-2069i32);
    pub const E_LIST_CLUSTER_FAILURE: Self = ErrorCode(-2070i32);
    pub const E_LIST_CLUSTER_GET_ABS_PATH_FAILURE: Self = ErrorCode(-2071i32);
    pub const E_LIST_CLUSTER_NO_AGENT_FAILURE: Self = ErrorCode(-2072i32);
    pub const E_QUERY_NOT_FOUND: Self = ErrorCode(-2073i32);
    pub const E_AGENT_HB_FAILUE: Self = ErrorCode(-2074i32);
    pub const E_CONSENSUS_ERROR: Self = ErrorCode(-3001i32);
    pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-3002i32);
    pub const E_DATA_TYPE_MISMATCH: Self = ErrorCode(-3003i32);
    pub const E_INVALID_FIELD_VALUE: Self = ErrorCode(-3004i32);
    pub const E_INVALID_OPERATION: Self = ErrorCode(-3005i32);
    pub const E_NOT_NULLABLE: Self = ErrorCode(-3006i32);
    pub const E_FIELD_UNSET: Self = ErrorCode(-3007i32);
    pub const E_OUT_OF_RANGE: Self = ErrorCode(-3008i32);
    pub const E_DATA_CONFLICT_ERROR: Self = ErrorCode(-3010i32);
    pub const E_WRITE_STALLED: Self = ErrorCode(-3011i32);
    pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-3021i32);
    pub const E_INVALID_SPACEVIDLEN: Self = ErrorCode(-3022i32);
    pub const E_INVALID_FILTER: Self = ErrorCode(-3031i32);
    pub const E_INVALID_UPDATER: Self = ErrorCode(-3032i32);
    pub const E_INVALID_STORE: Self = ErrorCode(-3033i32);
    pub const E_INVALID_PEER: Self = ErrorCode(-3034i32);
    pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-3035i32);
    pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-3036i32);
    pub const E_INVALID_STAT_TYPE: Self = ErrorCode(-3037i32);
    pub const E_INVALID_VID: Self = ErrorCode(-3038i32);
    pub const E_NO_TRANSFORMED: Self = ErrorCode(-3039i32);
    pub const E_LOAD_META_FAILED: Self = ErrorCode(-3040i32);
    pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-3041i32);
    pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-3042i32);
    pub const E_FILTER_OUT: Self = ErrorCode(-3043i32);
    pub const E_INVALID_DATA: Self = ErrorCode(-3044i32);
    pub const E_MUTATE_EDGE_CONFLICT: Self = ErrorCode(-3045i32);
    pub const E_MUTATE_TAG_CONFLICT: Self = ErrorCode(-3046i32);
    pub const E_OUTDATED_LOCK: Self = ErrorCode(-3047i32);
    pub const E_INVALID_TASK_PARA: Self = ErrorCode(-3051i32);
    pub const E_USER_CANCEL: Self = ErrorCode(-3052i32);
    pub const E_TASK_EXECUTION_FAILED: Self = ErrorCode(-3053i32);
    pub const E_PLAN_IS_KILLED: Self = ErrorCode(-3060i32);
    pub const E_NO_TERM: Self = ErrorCode(-3070i32);
    pub const E_OUTDATED_TERM: Self = ErrorCode(-3071i32);
    pub const E_OUTDATED_EDGE: Self = ErrorCode(-3072i32);
    pub const E_WRITE_WRITE_CONFLICT: Self = ErrorCode(-3073i32);
    pub const E_CLIENT_SERVER_INCOMPATIBLE: Self = ErrorCode(-3061i32);
    pub const E_ID_FAILED: Self = ErrorCode(-3062i32);
    pub const E_RAFT_UNKNOWN_PART: Self = ErrorCode(-3500i32);
    pub const E_RAFT_LOG_GAP: Self = ErrorCode(-3501i32);
    pub const E_RAFT_LOG_STALE: Self = ErrorCode(-3502i32);
    pub const E_RAFT_TERM_OUT_OF_DATE: Self = ErrorCode(-3503i32);
    pub const E_RAFT_UNKNOWN_APPEND_LOG: Self = ErrorCode(-3504i32);
    pub const E_RAFT_WAITING_SNAPSHOT: Self = ErrorCode(-3511i32);
    pub const E_RAFT_SENDING_SNAPSHOT: Self = ErrorCode(-3512i32);
    pub const E_RAFT_INVALID_PEER: Self = ErrorCode(-3513i32);
    pub const E_RAFT_NOT_READY: Self = ErrorCode(-3514i32);
    pub const E_RAFT_STOPPED: Self = ErrorCode(-3515i32);
    pub const E_RAFT_BAD_ROLE: Self = ErrorCode(-3516i32);
    pub const E_RAFT_WAL_FAIL: Self = ErrorCode(-3521i32);
    pub const E_RAFT_HOST_STOPPED: Self = ErrorCode(-3522i32);
    pub const E_RAFT_TOO_MANY_REQUESTS: Self = ErrorCode(-3523i32);
    pub const E_RAFT_PERSIST_SNAPSHOT_FAILED: Self = ErrorCode(-3524i32);
    pub const E_RAFT_RPC_EXCEPTION: Self = ErrorCode(-3525i32);
    pub const E_RAFT_NO_WAL_FOUND: Self = ErrorCode(-3526i32);
    pub const E_RAFT_HOST_PAUSED: Self = ErrorCode(-3527i32);
    pub const E_RAFT_WRITE_BLOCKED: Self = ErrorCode(-3528i32);
    pub const E_RAFT_BUFFER_OVERFLOW: Self = ErrorCode(-3529i32);
    pub const E_RAFT_ATOMIC_OP_FAILED: Self = ErrorCode(-3530i32);
    pub const E_LEADER_LEASE_FAILED: Self = ErrorCode(-3531i32);
    pub const E_UNKNOWN: Self = ErrorCode(-8000i32);
}

impl ::fbthrift::ThriftEnum for ErrorCode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::E_DISCONNECTED, "E_DISCONNECTED"),
            (Self::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
            (Self::E_RPC_FAILURE, "E_RPC_FAILURE"),
            (Self::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
            (Self::E_SPACE_NOT_FOUND, "E_SPACE_NOT_FOUND"),
            (Self::E_TAG_NOT_FOUND, "E_TAG_NOT_FOUND"),
            (Self::E_EDGE_NOT_FOUND, "E_EDGE_NOT_FOUND"),
            (Self::E_INDEX_NOT_FOUND, "E_INDEX_NOT_FOUND"),
            (Self::E_EDGE_PROP_NOT_FOUND, "E_EDGE_PROP_NOT_FOUND"),
            (Self::E_TAG_PROP_NOT_FOUND, "E_TAG_PROP_NOT_FOUND"),
            (Self::E_ROLE_NOT_FOUND, "E_ROLE_NOT_FOUND"),
            (Self::E_CONFIG_NOT_FOUND, "E_CONFIG_NOT_FOUND"),
            (Self::E_MACHINE_NOT_FOUND, "E_MACHINE_NOT_FOUND"),
            (Self::E_ZONE_NOT_FOUND, "E_ZONE_NOT_FOUND"),
            (Self::E_LISTENER_NOT_FOUND, "E_LISTENER_NOT_FOUND"),
            (Self::E_PART_NOT_FOUND, "E_PART_NOT_FOUND"),
            (Self::E_KEY_NOT_FOUND, "E_KEY_NOT_FOUND"),
            (Self::E_USER_NOT_FOUND, "E_USER_NOT_FOUND"),
            (Self::E_STATS_NOT_FOUND, "E_STATS_NOT_FOUND"),
            (Self::E_SERVICE_NOT_FOUND, "E_SERVICE_NOT_FOUND"),
            (Self::E_BACKUP_FAILED, "E_BACKUP_FAILED"),
            (Self::E_BACKUP_EMPTY_TABLE, "E_BACKUP_EMPTY_TABLE"),
            (Self::E_BACKUP_TABLE_FAILED, "E_BACKUP_TABLE_FAILED"),
            (Self::E_PARTIAL_RESULT, "E_PARTIAL_RESULT"),
            (Self::E_REBUILD_INDEX_FAILED, "E_REBUILD_INDEX_FAILED"),
            (Self::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
            (Self::E_FAILED_GET_ABS_PATH, "E_FAILED_GET_ABS_PATH"),
            (Self::E_BAD_USERNAME_PASSWORD, "E_BAD_USERNAME_PASSWORD"),
            (Self::E_SESSION_INVALID, "E_SESSION_INVALID"),
            (Self::E_SESSION_TIMEOUT, "E_SESSION_TIMEOUT"),
            (Self::E_SYNTAX_ERROR, "E_SYNTAX_ERROR"),
            (Self::E_EXECUTION_ERROR, "E_EXECUTION_ERROR"),
            (Self::E_STATEMENT_EMPTY, "E_STATEMENT_EMPTY"),
            (Self::E_BAD_PERMISSION, "E_BAD_PERMISSION"),
            (Self::E_SEMANTIC_ERROR, "E_SEMANTIC_ERROR"),
            (Self::E_TOO_MANY_CONNECTIONS, "E_TOO_MANY_CONNECTIONS"),
            (Self::E_PARTIAL_SUCCEEDED, "E_PARTIAL_SUCCEEDED"),
            (Self::E_NO_HOSTS, "E_NO_HOSTS"),
            (Self::E_EXISTED, "E_EXISTED"),
            (Self::E_INVALID_HOST, "E_INVALID_HOST"),
            (Self::E_UNSUPPORTED, "E_UNSUPPORTED"),
            (Self::E_NOT_DROP, "E_NOT_DROP"),
            (Self::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
            (Self::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
            (Self::E_CONFLICT, "E_CONFLICT"),
            (Self::E_INVALID_PARM, "E_INVALID_PARM"),
            (Self::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
            (Self::E_ZONE_NOT_ENOUGH, "E_ZONE_NOT_ENOUGH"),
            (Self::E_ZONE_IS_EMPTY, "E_ZONE_IS_EMPTY"),
            (Self::E_SCHEMA_NAME_EXISTS, "E_SCHEMA_NAME_EXISTS"),
            (Self::E_RELATED_INDEX_EXISTS, "E_RELATED_INDEX_EXISTS"),
            (Self::E_RELATED_SPACE_EXISTS, "E_RELATED_SPACE_EXISTS"),
            (Self::E_STORE_FAILURE, "E_STORE_FAILURE"),
            (Self::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
            (Self::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
            (Self::E_BALANCED, "E_BALANCED"),
            (Self::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
            (Self::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
            (Self::E_CORRUPTED_BALANCE_PLAN, "E_CORRUPTED_BALANCE_PLAN"),
            (Self::E_NO_INVALID_BALANCE_PLAN, "E_NO_INVALID_BALANCE_PLAN"),
            (Self::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
            (Self::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
            (Self::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
            (Self::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
            (Self::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
            (Self::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
            (Self::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
            (Self::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
            (Self::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
            (Self::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
            (Self::E_ADD_JOB_FAILURE, "E_ADD_JOB_FAILURE"),
            (Self::E_STOP_JOB_FAILURE, "E_STOP_JOB_FAILURE"),
            (Self::E_SAVE_JOB_FAILURE, "E_SAVE_JOB_FAILURE"),
            (Self::E_BALANCER_FAILURE, "E_BALANCER_FAILURE"),
            (Self::E_JOB_NOT_FINISHED, "E_JOB_NOT_FINISHED"),
            (Self::E_TASK_REPORT_OUT_DATE, "E_TASK_REPORT_OUT_DATE"),
            (Self::E_JOB_NOT_IN_SPACE, "E_JOB_NOT_IN_SPACE"),
            (Self::E_JOB_NEED_RECOVER, "E_JOB_NEED_RECOVER"),
            (Self::E_JOB_ALREADY_FINISH, "E_JOB_ALREADY_FINISH"),
            (Self::E_JOB_SUBMITTED, "E_JOB_SUBMITTED"),
            (Self::E_JOB_NOT_STOPPABLE, "E_JOB_NOT_STOPPABLE"),
            (Self::E_JOB_HAS_NO_TARGET_STORAGE, "E_JOB_HAS_NO_TARGET_STORAGE"),
            (Self::E_INVALID_JOB, "E_INVALID_JOB"),
            (Self::E_BACKUP_BUILDING_INDEX, "E_BACKUP_BUILDING_INDEX"),
            (Self::E_BACKUP_SPACE_NOT_FOUND, "E_BACKUP_SPACE_NOT_FOUND"),
            (Self::E_RESTORE_FAILURE, "E_RESTORE_FAILURE"),
            (Self::E_SESSION_NOT_FOUND, "E_SESSION_NOT_FOUND"),
            (Self::E_LIST_CLUSTER_FAILURE, "E_LIST_CLUSTER_FAILURE"),
            (Self::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE, "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE"),
            (Self::E_LIST_CLUSTER_NO_AGENT_FAILURE, "E_LIST_CLUSTER_NO_AGENT_FAILURE"),
            (Self::E_QUERY_NOT_FOUND, "E_QUERY_NOT_FOUND"),
            (Self::E_AGENT_HB_FAILUE, "E_AGENT_HB_FAILUE"),
            (Self::E_CONSENSUS_ERROR, "E_CONSENSUS_ERROR"),
            (Self::E_KEY_HAS_EXISTS, "E_KEY_HAS_EXISTS"),
            (Self::E_DATA_TYPE_MISMATCH, "E_DATA_TYPE_MISMATCH"),
            (Self::E_INVALID_FIELD_VALUE, "E_INVALID_FIELD_VALUE"),
            (Self::E_INVALID_OPERATION, "E_INVALID_OPERATION"),
            (Self::E_NOT_NULLABLE, "E_NOT_NULLABLE"),
            (Self::E_FIELD_UNSET, "E_FIELD_UNSET"),
            (Self::E_OUT_OF_RANGE, "E_OUT_OF_RANGE"),
            (Self::E_DATA_CONFLICT_ERROR, "E_DATA_CONFLICT_ERROR"),
            (Self::E_WRITE_STALLED, "E_WRITE_STALLED"),
            (Self::E_IMPROPER_DATA_TYPE, "E_IMPROPER_DATA_TYPE"),
            (Self::E_INVALID_SPACEVIDLEN, "E_INVALID_SPACEVIDLEN"),
            (Self::E_INVALID_FILTER, "E_INVALID_FILTER"),
            (Self::E_INVALID_UPDATER, "E_INVALID_UPDATER"),
            (Self::E_INVALID_STORE, "E_INVALID_STORE"),
            (Self::E_INVALID_PEER, "E_INVALID_PEER"),
            (Self::E_RETRY_EXHAUSTED, "E_RETRY_EXHAUSTED"),
            (Self::E_TRANSFER_LEADER_FAILED, "E_TRANSFER_LEADER_FAILED"),
            (Self::E_INVALID_STAT_TYPE, "E_INVALID_STAT_TYPE"),
            (Self::E_INVALID_VID, "E_INVALID_VID"),
            (Self::E_NO_TRANSFORMED, "E_NO_TRANSFORMED"),
            (Self::E_LOAD_META_FAILED, "E_LOAD_META_FAILED"),
            (Self::E_FAILED_TO_CHECKPOINT, "E_FAILED_TO_CHECKPOINT"),
            (Self::E_CHECKPOINT_BLOCKED, "E_CHECKPOINT_BLOCKED"),
            (Self::E_FILTER_OUT, "E_FILTER_OUT"),
            (Self::E_INVALID_DATA, "E_INVALID_DATA"),
            (Self::E_MUTATE_EDGE_CONFLICT, "E_MUTATE_EDGE_CONFLICT"),
            (Self::E_MUTATE_TAG_CONFLICT, "E_MUTATE_TAG_CONFLICT"),
            (Self::E_OUTDATED_LOCK, "E_OUTDATED_LOCK"),
            (Self::E_INVALID_TASK_PARA, "E_INVALID_TASK_PARA"),
            (Self::E_USER_CANCEL, "E_USER_CANCEL"),
            (Self::E_TASK_EXECUTION_FAILED, "E_TASK_EXECUTION_FAILED"),
            (Self::E_PLAN_IS_KILLED, "E_PLAN_IS_KILLED"),
            (Self::E_NO_TERM, "E_NO_TERM"),
            (Self::E_OUTDATED_TERM, "E_OUTDATED_TERM"),
            (Self::E_OUTDATED_EDGE, "E_OUTDATED_EDGE"),
            (Self::E_WRITE_WRITE_CONFLICT, "E_WRITE_WRITE_CONFLICT"),
            (Self::E_CLIENT_SERVER_INCOMPATIBLE, "E_CLIENT_SERVER_INCOMPATIBLE"),
            (Self::E_ID_FAILED, "E_ID_FAILED"),
            (Self::E_RAFT_UNKNOWN_PART, "E_RAFT_UNKNOWN_PART"),
            (Self::E_RAFT_LOG_GAP, "E_RAFT_LOG_GAP"),
            (Self::E_RAFT_LOG_STALE, "E_RAFT_LOG_STALE"),
            (Self::E_RAFT_TERM_OUT_OF_DATE, "E_RAFT_TERM_OUT_OF_DATE"),
            (Self::E_RAFT_UNKNOWN_APPEND_LOG, "E_RAFT_UNKNOWN_APPEND_LOG"),
            (Self::E_RAFT_WAITING_SNAPSHOT, "E_RAFT_WAITING_SNAPSHOT"),
            (Self::E_RAFT_SENDING_SNAPSHOT, "E_RAFT_SENDING_SNAPSHOT"),
            (Self::E_RAFT_INVALID_PEER, "E_RAFT_INVALID_PEER"),
            (Self::E_RAFT_NOT_READY, "E_RAFT_NOT_READY"),
            (Self::E_RAFT_STOPPED, "E_RAFT_STOPPED"),
            (Self::E_RAFT_BAD_ROLE, "E_RAFT_BAD_ROLE"),
            (Self::E_RAFT_WAL_FAIL, "E_RAFT_WAL_FAIL"),
            (Self::E_RAFT_HOST_STOPPED, "E_RAFT_HOST_STOPPED"),
            (Self::E_RAFT_TOO_MANY_REQUESTS, "E_RAFT_TOO_MANY_REQUESTS"),
            (Self::E_RAFT_PERSIST_SNAPSHOT_FAILED, "E_RAFT_PERSIST_SNAPSHOT_FAILED"),
            (Self::E_RAFT_RPC_EXCEPTION, "E_RAFT_RPC_EXCEPTION"),
            (Self::E_RAFT_NO_WAL_FOUND, "E_RAFT_NO_WAL_FOUND"),
            (Self::E_RAFT_HOST_PAUSED, "E_RAFT_HOST_PAUSED"),
            (Self::E_RAFT_WRITE_BLOCKED, "E_RAFT_WRITE_BLOCKED"),
            (Self::E_RAFT_BUFFER_OVERFLOW, "E_RAFT_BUFFER_OVERFLOW"),
            (Self::E_RAFT_ATOMIC_OP_FAILED, "E_RAFT_ATOMIC_OP_FAILED"),
            (Self::E_LEADER_LEASE_FAILED, "E_LEADER_LEASE_FAILED"),
            (Self::E_UNKNOWN, "E_UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "E_DISCONNECTED",
            "E_FAIL_TO_CONNECT",
            "E_RPC_FAILURE",
            "E_LEADER_CHANGED",
            "E_SPACE_NOT_FOUND",
            "E_TAG_NOT_FOUND",
            "E_EDGE_NOT_FOUND",
            "E_INDEX_NOT_FOUND",
            "E_EDGE_PROP_NOT_FOUND",
            "E_TAG_PROP_NOT_FOUND",
            "E_ROLE_NOT_FOUND",
            "E_CONFIG_NOT_FOUND",
            "E_MACHINE_NOT_FOUND",
            "E_ZONE_NOT_FOUND",
            "E_LISTENER_NOT_FOUND",
            "E_PART_NOT_FOUND",
            "E_KEY_NOT_FOUND",
            "E_USER_NOT_FOUND",
            "E_STATS_NOT_FOUND",
            "E_SERVICE_NOT_FOUND",
            "E_BACKUP_FAILED",
            "E_BACKUP_EMPTY_TABLE",
            "E_BACKUP_TABLE_FAILED",
            "E_PARTIAL_RESULT",
            "E_REBUILD_INDEX_FAILED",
            "E_INVALID_PASSWORD",
            "E_FAILED_GET_ABS_PATH",
            "E_BAD_USERNAME_PASSWORD",
            "E_SESSION_INVALID",
            "E_SESSION_TIMEOUT",
            "E_SYNTAX_ERROR",
            "E_EXECUTION_ERROR",
            "E_STATEMENT_EMPTY",
            "E_BAD_PERMISSION",
            "E_SEMANTIC_ERROR",
            "E_TOO_MANY_CONNECTIONS",
            "E_PARTIAL_SUCCEEDED",
            "E_NO_HOSTS",
            "E_EXISTED",
            "E_INVALID_HOST",
            "E_UNSUPPORTED",
            "E_NOT_DROP",
            "E_BALANCER_RUNNING",
            "E_CONFIG_IMMUTABLE",
            "E_CONFLICT",
            "E_INVALID_PARM",
            "E_WRONGCLUSTER",
            "E_ZONE_NOT_ENOUGH",
            "E_ZONE_IS_EMPTY",
            "E_SCHEMA_NAME_EXISTS",
            "E_RELATED_INDEX_EXISTS",
            "E_RELATED_SPACE_EXISTS",
            "E_STORE_FAILURE",
            "E_STORE_SEGMENT_ILLEGAL",
            "E_BAD_BALANCE_PLAN",
            "E_BALANCED",
            "E_NO_RUNNING_BALANCE_PLAN",
            "E_NO_VALID_HOST",
            "E_CORRUPTED_BALANCE_PLAN",
            "E_NO_INVALID_BALANCE_PLAN",
            "E_IMPROPER_ROLE",
            "E_INVALID_PARTITION_NUM",
            "E_INVALID_REPLICA_FACTOR",
            "E_INVALID_CHARSET",
            "E_INVALID_COLLATE",
            "E_CHARSET_COLLATE_NOT_MATCH",
            "E_SNAPSHOT_FAILURE",
            "E_BLOCK_WRITE_FAILURE",
            "E_REBUILD_INDEX_FAILURE",
            "E_INDEX_WITH_TTL",
            "E_ADD_JOB_FAILURE",
            "E_STOP_JOB_FAILURE",
            "E_SAVE_JOB_FAILURE",
            "E_BALANCER_FAILURE",
            "E_JOB_NOT_FINISHED",
            "E_TASK_REPORT_OUT_DATE",
            "E_JOB_NOT_IN_SPACE",
            "E_JOB_NEED_RECOVER",
            "E_JOB_ALREADY_FINISH",
            "E_JOB_SUBMITTED",
            "E_JOB_NOT_STOPPABLE",
            "E_JOB_HAS_NO_TARGET_STORAGE",
            "E_INVALID_JOB",
            "E_BACKUP_BUILDING_INDEX",
            "E_BACKUP_SPACE_NOT_FOUND",
            "E_RESTORE_FAILURE",
            "E_SESSION_NOT_FOUND",
            "E_LIST_CLUSTER_FAILURE",
            "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE",
            "E_LIST_CLUSTER_NO_AGENT_FAILURE",
            "E_QUERY_NOT_FOUND",
            "E_AGENT_HB_FAILUE",
            "E_CONSENSUS_ERROR",
            "E_KEY_HAS_EXISTS",
            "E_DATA_TYPE_MISMATCH",
            "E_INVALID_FIELD_VALUE",
            "E_INVALID_OPERATION",
            "E_NOT_NULLABLE",
            "E_FIELD_UNSET",
            "E_OUT_OF_RANGE",
            "E_DATA_CONFLICT_ERROR",
            "E_WRITE_STALLED",
            "E_IMPROPER_DATA_TYPE",
            "E_INVALID_SPACEVIDLEN",
            "E_INVALID_FILTER",
            "E_INVALID_UPDATER",
            "E_INVALID_STORE",
            "E_INVALID_PEER",
            "E_RETRY_EXHAUSTED",
            "E_TRANSFER_LEADER_FAILED",
            "E_INVALID_STAT_TYPE",
            "E_INVALID_VID",
            "E_NO_TRANSFORMED",
            "E_LOAD_META_FAILED",
            "E_FAILED_TO_CHECKPOINT",
            "E_CHECKPOINT_BLOCKED",
            "E_FILTER_OUT",
            "E_INVALID_DATA",
            "E_MUTATE_EDGE_CONFLICT",
            "E_MUTATE_TAG_CONFLICT",
            "E_OUTDATED_LOCK",
            "E_INVALID_TASK_PARA",
            "E_USER_CANCEL",
            "E_TASK_EXECUTION_FAILED",
            "E_PLAN_IS_KILLED",
            "E_NO_TERM",
            "E_OUTDATED_TERM",
            "E_OUTDATED_EDGE",
            "E_WRITE_WRITE_CONFLICT",
            "E_CLIENT_SERVER_INCOMPATIBLE",
            "E_ID_FAILED",
            "E_RAFT_UNKNOWN_PART",
            "E_RAFT_LOG_GAP",
            "E_RAFT_LOG_STALE",
            "E_RAFT_TERM_OUT_OF_DATE",
            "E_RAFT_UNKNOWN_APPEND_LOG",
            "E_RAFT_WAITING_SNAPSHOT",
            "E_RAFT_SENDING_SNAPSHOT",
            "E_RAFT_INVALID_PEER",
            "E_RAFT_NOT_READY",
            "E_RAFT_STOPPED",
            "E_RAFT_BAD_ROLE",
            "E_RAFT_WAL_FAIL",
            "E_RAFT_HOST_STOPPED",
            "E_RAFT_TOO_MANY_REQUESTS",
            "E_RAFT_PERSIST_SNAPSHOT_FAILED",
            "E_RAFT_RPC_EXCEPTION",
            "E_RAFT_NO_WAL_FOUND",
            "E_RAFT_HOST_PAUSED",
            "E_RAFT_WRITE_BLOCKED",
            "E_RAFT_BUFFER_OVERFLOW",
            "E_RAFT_ATOMIC_OP_FAILED",
            "E_LEADER_LEASE_FAILED",
            "E_UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::E_DISCONNECTED,
            Self::E_FAIL_TO_CONNECT,
            Self::E_RPC_FAILURE,
            Self::E_LEADER_CHANGED,
            Self::E_SPACE_NOT_FOUND,
            Self::E_TAG_NOT_FOUND,
            Self::E_EDGE_NOT_FOUND,
            Self::E_INDEX_NOT_FOUND,
            Self::E_EDGE_PROP_NOT_FOUND,
            Self::E_TAG_PROP_NOT_FOUND,
            Self::E_ROLE_NOT_FOUND,
            Self::E_CONFIG_NOT_FOUND,
            Self::E_MACHINE_NOT_FOUND,
            Self::E_ZONE_NOT_FOUND,
            Self::E_LISTENER_NOT_FOUND,
            Self::E_PART_NOT_FOUND,
            Self::E_KEY_NOT_FOUND,
            Self::E_USER_NOT_FOUND,
            Self::E_STATS_NOT_FOUND,
            Self::E_SERVICE_NOT_FOUND,
            Self::E_BACKUP_FAILED,
            Self::E_BACKUP_EMPTY_TABLE,
            Self::E_BACKUP_TABLE_FAILED,
            Self::E_PARTIAL_RESULT,
            Self::E_REBUILD_INDEX_FAILED,
            Self::E_INVALID_PASSWORD,
            Self::E_FAILED_GET_ABS_PATH,
            Self::E_BAD_USERNAME_PASSWORD,
            Self::E_SESSION_INVALID,
            Self::E_SESSION_TIMEOUT,
            Self::E_SYNTAX_ERROR,
            Self::E_EXECUTION_ERROR,
            Self::E_STATEMENT_EMPTY,
            Self::E_BAD_PERMISSION,
            Self::E_SEMANTIC_ERROR,
            Self::E_TOO_MANY_CONNECTIONS,
            Self::E_PARTIAL_SUCCEEDED,
            Self::E_NO_HOSTS,
            Self::E_EXISTED,
            Self::E_INVALID_HOST,
            Self::E_UNSUPPORTED,
            Self::E_NOT_DROP,
            Self::E_BALANCER_RUNNING,
            Self::E_CONFIG_IMMUTABLE,
            Self::E_CONFLICT,
            Self::E_INVALID_PARM,
            Self::E_WRONGCLUSTER,
            Self::E_ZONE_NOT_ENOUGH,
            Self::E_ZONE_IS_EMPTY,
            Self::E_SCHEMA_NAME_EXISTS,
            Self::E_RELATED_INDEX_EXISTS,
            Self::E_RELATED_SPACE_EXISTS,
            Self::E_STORE_FAILURE,
            Self::E_STORE_SEGMENT_ILLEGAL,
            Self::E_BAD_BALANCE_PLAN,
            Self::E_BALANCED,
            Self::E_NO_RUNNING_BALANCE_PLAN,
            Self::E_NO_VALID_HOST,
            Self::E_CORRUPTED_BALANCE_PLAN,
            Self::E_NO_INVALID_BALANCE_PLAN,
            Self::E_IMPROPER_ROLE,
            Self::E_INVALID_PARTITION_NUM,
            Self::E_INVALID_REPLICA_FACTOR,
            Self::E_INVALID_CHARSET,
            Self::E_INVALID_COLLATE,
            Self::E_CHARSET_COLLATE_NOT_MATCH,
            Self::E_SNAPSHOT_FAILURE,
            Self::E_BLOCK_WRITE_FAILURE,
            Self::E_REBUILD_INDEX_FAILURE,
            Self::E_INDEX_WITH_TTL,
            Self::E_ADD_JOB_FAILURE,
            Self::E_STOP_JOB_FAILURE,
            Self::E_SAVE_JOB_FAILURE,
            Self::E_BALANCER_FAILURE,
            Self::E_JOB_NOT_FINISHED,
            Self::E_TASK_REPORT_OUT_DATE,
            Self::E_JOB_NOT_IN_SPACE,
            Self::E_JOB_NEED_RECOVER,
            Self::E_JOB_ALREADY_FINISH,
            Self::E_JOB_SUBMITTED,
            Self::E_JOB_NOT_STOPPABLE,
            Self::E_JOB_HAS_NO_TARGET_STORAGE,
            Self::E_INVALID_JOB,
            Self::E_BACKUP_BUILDING_INDEX,
            Self::E_BACKUP_SPACE_NOT_FOUND,
            Self::E_RESTORE_FAILURE,
            Self::E_SESSION_NOT_FOUND,
            Self::E_LIST_CLUSTER_FAILURE,
            Self::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE,
            Self::E_LIST_CLUSTER_NO_AGENT_FAILURE,
            Self::E_QUERY_NOT_FOUND,
            Self::E_AGENT_HB_FAILUE,
            Self::E_CONSENSUS_ERROR,
            Self::E_KEY_HAS_EXISTS,
            Self::E_DATA_TYPE_MISMATCH,
            Self::E_INVALID_FIELD_VALUE,
            Self::E_INVALID_OPERATION,
            Self::E_NOT_NULLABLE,
            Self::E_FIELD_UNSET,
            Self::E_OUT_OF_RANGE,
            Self::E_DATA_CONFLICT_ERROR,
            Self::E_WRITE_STALLED,
            Self::E_IMPROPER_DATA_TYPE,
            Self::E_INVALID_SPACEVIDLEN,
            Self::E_INVALID_FILTER,
            Self::E_INVALID_UPDATER,
            Self::E_INVALID_STORE,
            Self::E_INVALID_PEER,
            Self::E_RETRY_EXHAUSTED,
            Self::E_TRANSFER_LEADER_FAILED,
            Self::E_INVALID_STAT_TYPE,
            Self::E_INVALID_VID,
            Self::E_NO_TRANSFORMED,
            Self::E_LOAD_META_FAILED,
            Self::E_FAILED_TO_CHECKPOINT,
            Self::E_CHECKPOINT_BLOCKED,
            Self::E_FILTER_OUT,
            Self::E_INVALID_DATA,
            Self::E_MUTATE_EDGE_CONFLICT,
            Self::E_MUTATE_TAG_CONFLICT,
            Self::E_OUTDATED_LOCK,
            Self::E_INVALID_TASK_PARA,
            Self::E_USER_CANCEL,
            Self::E_TASK_EXECUTION_FAILED,
            Self::E_PLAN_IS_KILLED,
            Self::E_NO_TERM,
            Self::E_OUTDATED_TERM,
            Self::E_OUTDATED_EDGE,
            Self::E_WRITE_WRITE_CONFLICT,
            Self::E_CLIENT_SERVER_INCOMPATIBLE,
            Self::E_ID_FAILED,
            Self::E_RAFT_UNKNOWN_PART,
            Self::E_RAFT_LOG_GAP,
            Self::E_RAFT_LOG_STALE,
            Self::E_RAFT_TERM_OUT_OF_DATE,
            Self::E_RAFT_UNKNOWN_APPEND_LOG,
            Self::E_RAFT_WAITING_SNAPSHOT,
            Self::E_RAFT_SENDING_SNAPSHOT,
            Self::E_RAFT_INVALID_PEER,
            Self::E_RAFT_NOT_READY,
            Self::E_RAFT_STOPPED,
            Self::E_RAFT_BAD_ROLE,
            Self::E_RAFT_WAL_FAIL,
            Self::E_RAFT_HOST_STOPPED,
            Self::E_RAFT_TOO_MANY_REQUESTS,
            Self::E_RAFT_PERSIST_SNAPSHOT_FAILED,
            Self::E_RAFT_RPC_EXCEPTION,
            Self::E_RAFT_NO_WAL_FOUND,
            Self::E_RAFT_HOST_PAUSED,
            Self::E_RAFT_WRITE_BLOCKED,
            Self::E_RAFT_BUFFER_OVERFLOW,
            Self::E_RAFT_ATOMIC_OP_FAILED,
            Self::E_LEADER_LEASE_FAILED,
            Self::E_UNKNOWN,
        ]
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_UNKNOWN", -8000),
            ("E_LEADER_LEASE_FAILED", -3531),
            ("E_RAFT_ATOMIC_OP_FAILED", -3530),
            ("E_RAFT_BUFFER_OVERFLOW", -3529),
            ("E_RAFT_WRITE_BLOCKED", -3528),
            ("E_RAFT_HOST_PAUSED", -3527),
            ("E_RAFT_NO_WAL_FOUND", -3526),
            ("E_RAFT_RPC_EXCEPTION", -3525),
            ("E_RAFT_PERSIST_SNAPSHOT_FAILED", -3524),
            ("E_RAFT_TOO_MANY_REQUESTS", -3523),
            ("E_RAFT_HOST_STOPPED", -3522),
            ("E_RAFT_WAL_FAIL", -3521),
            ("E_RAFT_BAD_ROLE", -3516),
            ("E_RAFT_STOPPED", -3515),
            ("E_RAFT_NOT_READY", -3514),
            ("E_RAFT_INVALID_PEER", -3513),
            ("E_RAFT_SENDING_SNAPSHOT", -3512),
            ("E_RAFT_WAITING_SNAPSHOT", -3511),
            ("E_RAFT_UNKNOWN_APPEND_LOG", -3504),
            ("E_RAFT_TERM_OUT_OF_DATE", -3503),
            ("E_RAFT_LOG_STALE", -3502),
            ("E_RAFT_LOG_GAP", -3501),
            ("E_RAFT_UNKNOWN_PART", -3500),
            ("E_WRITE_WRITE_CONFLICT", -3073),
            ("E_OUTDATED_EDGE", -3072),
            ("E_OUTDATED_TERM", -3071),
            ("E_NO_TERM", -3070),
            ("E_ID_FAILED", -3062),
            ("E_CLIENT_SERVER_INCOMPATIBLE", -3061),
            ("E_PLAN_IS_KILLED", -3060),
            ("E_TASK_EXECUTION_FAILED", -3053),
            ("E_USER_CANCEL", -3052),
            ("E_INVALID_TASK_PARA", -3051),
            ("E_OUTDATED_LOCK", -3047),
            ("E_MUTATE_TAG_CONFLICT", -3046),
            ("E_MUTATE_EDGE_CONFLICT", -3045),
            ("E_INVALID_DATA", -3044),
            ("E_FILTER_OUT", -3043),
            ("E_CHECKPOINT_BLOCKED", -3042),
            ("E_FAILED_TO_CHECKPOINT", -3041),
            ("E_LOAD_META_FAILED", -3040),
            ("E_NO_TRANSFORMED", -3039),
            ("E_INVALID_VID", -3038),
            ("E_INVALID_STAT_TYPE", -3037),
            ("E_TRANSFER_LEADER_FAILED", -3036),
            ("E_RETRY_EXHAUSTED", -3035),
            ("E_INVALID_PEER", -3034),
            ("E_INVALID_STORE", -3033),
            ("E_INVALID_UPDATER", -3032),
            ("E_INVALID_FILTER", -3031),
            ("E_INVALID_SPACEVIDLEN", -3022),
            ("E_IMPROPER_DATA_TYPE", -3021),
            ("E_WRITE_STALLED", -3011),
            ("E_DATA_CONFLICT_ERROR", -3010),
            ("E_OUT_OF_RANGE", -3008),
            ("E_FIELD_UNSET", -3007),
            ("E_NOT_NULLABLE", -3006),
            ("E_INVALID_OPERATION", -3005),
            ("E_INVALID_FIELD_VALUE", -3004),
            ("E_DATA_TYPE_MISMATCH", -3003),
            ("E_KEY_HAS_EXISTS", -3002),
            ("E_CONSENSUS_ERROR", -3001),
            ("E_AGENT_HB_FAILUE", -2074),
            ("E_QUERY_NOT_FOUND", -2073),
            ("E_LIST_CLUSTER_NO_AGENT_FAILURE", -2072),
            ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
            ("E_LIST_CLUSTER_FAILURE", -2070),
            ("E_SESSION_NOT_FOUND", -2069),
            ("E_RESTORE_FAILURE", -2068),
            ("E_BACKUP_SPACE_NOT_FOUND", -2067),
            ("E_BACKUP_BUILDING_INDEX", -2066),
            ("E_INVALID_JOB", -2065),
            ("E_JOB_HAS_NO_TARGET_STORAGE", -2055),
            ("E_JOB_NOT_STOPPABLE", -2054),
            ("E_JOB_SUBMITTED", -2053),
            ("E_JOB_ALREADY_FINISH", -2052),
            ("E_JOB_NEED_RECOVER", -2051),
            ("E_JOB_NOT_IN_SPACE", -2050),
            ("E_TASK_REPORT_OUT_DATE", -2049),
            ("E_JOB_NOT_FINISHED", -2048),
            ("E_BALANCER_FAILURE", -2047),
            ("E_SAVE_JOB_FAILURE", -2046),
            ("E_STOP_JOB_FAILURE", -2045),
            ("E_ADD_JOB_FAILURE", -2044),
            ("E_INDEX_WITH_TTL", -2043),
            ("E_REBUILD_INDEX_FAILURE", -2042),
            ("E_BLOCK_WRITE_FAILURE", -2041),
            ("E_SNAPSHOT_FAILURE", -2040),
            ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
            ("E_INVALID_COLLATE", -2034),
            ("E_INVALID_CHARSET", -2033),
            ("E_INVALID_REPLICA_FACTOR", -2032),
            ("E_INVALID_PARTITION_NUM", -2031),
            ("E_IMPROPER_ROLE", -2030),
            ("E_NO_INVALID_BALANCE_PLAN", -2028),
            ("E_CORRUPTED_BALANCE_PLAN", -2027),
            ("E_NO_VALID_HOST", -2026),
            ("E_NO_RUNNING_BALANCE_PLAN", -2025),
            ("E_BALANCED", -2024),
            ("E_BAD_BALANCE_PLAN", -2023),
            ("E_STORE_SEGMENT_ILLEGAL", -2022),
            ("E_STORE_FAILURE", -2021),
            ("E_RELATED_SPACE_EXISTS", -2015),
            ("E_RELATED_INDEX_EXISTS", -2014),
            ("E_SCHEMA_NAME_EXISTS", -2013),
            ("E_ZONE_IS_EMPTY", -2012),
            ("E_ZONE_NOT_ENOUGH", -2011),
            ("E_WRONGCLUSTER", -2010),
            ("E_INVALID_PARM", -2009),
            ("E_CONFLICT", -2008),
            ("E_CONFIG_IMMUTABLE", -2007),
            ("E_BALANCER_RUNNING", -2006),
            ("E_NOT_DROP", -2005),
            ("E_UNSUPPORTED", -2004),
            ("E_INVALID_HOST", -2003),
            ("E_EXISTED", -2002),
            ("E_NO_HOSTS", -2001),
            ("E_PARTIAL_SUCCEEDED", -1011),
            ("E_TOO_MANY_CONNECTIONS", -1010),
            ("E_SEMANTIC_ERROR", -1009),
            ("E_BAD_PERMISSION", -1008),
            ("E_STATEMENT_EMPTY", -1006),
            ("E_EXECUTION_ERROR", -1005),
            ("E_SYNTAX_ERROR", -1004),
            ("E_SESSION_TIMEOUT", -1003),
            ("E_SESSION_INVALID", -1002),
            ("E_BAD_USERNAME_PASSWORD", -1001),
            ("E_FAILED_GET_ABS_PATH", -30),
            ("E_INVALID_PASSWORD", -29),
            ("E_REBUILD_INDEX_FAILED", -28),
            ("E_PARTIAL_RESULT", -27),
            ("E_BACKUP_TABLE_FAILED", -26),
            ("E_BACKUP_EMPTY_TABLE", -25),
            ("E_BACKUP_FAILED", -24),
            ("E_SERVICE_NOT_FOUND", -20),
            ("E_STATS_NOT_FOUND", -19),
            ("E_USER_NOT_FOUND", -18),
            ("E_KEY_NOT_FOUND", -17),
            ("E_PART_NOT_FOUND", -16),
            ("E_LISTENER_NOT_FOUND", -15),
            ("E_ZONE_NOT_FOUND", -14),
            ("E_MACHINE_NOT_FOUND", -13),
            ("E_CONFIG_NOT_FOUND", -12),
            ("E_ROLE_NOT_FOUND", -11),
            ("E_TAG_PROP_NOT_FOUND", -10),
            ("E_EDGE_PROP_NOT_FOUND", -9),
            ("E_INDEX_NOT_FOUND", -8),
            ("E_EDGE_NOT_FOUND", -7),
            ("E_TAG_NOT_FOUND", -6),
            ("E_SPACE_NOT_FOUND", -5),
            ("E_LEADER_CHANGED", -4),
            ("E_RPC_FAILURE", -3),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_DISCONNECTED", -1),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ErrorCode::{}", self)
    }
}

impl ::std::str::FromStr for ErrorCode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_ADD_JOB_FAILURE", -2044),
            ("E_AGENT_HB_FAILUE", -2074),
            ("E_BACKUP_BUILDING_INDEX", -2066),
            ("E_BACKUP_EMPTY_TABLE", -25),
            ("E_BACKUP_FAILED", -24),
            ("E_BACKUP_SPACE_NOT_FOUND", -2067),
            ("E_BACKUP_TABLE_FAILED", -26),
            ("E_BAD_BALANCE_PLAN", -2023),
            ("E_BAD_PERMISSION", -1008),
            ("E_BAD_USERNAME_PASSWORD", -1001),
            ("E_BALANCED", -2024),
            ("E_BALANCER_FAILURE", -2047),
            ("E_BALANCER_RUNNING", -2006),
            ("E_BLOCK_WRITE_FAILURE", -2041),
            ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
            ("E_CHECKPOINT_BLOCKED", -3042),
            ("E_CLIENT_SERVER_INCOMPATIBLE", -3061),
            ("E_CONFIG_IMMUTABLE", -2007),
            ("E_CONFIG_NOT_FOUND", -12),
            ("E_CONFLICT", -2008),
            ("E_CONSENSUS_ERROR", -3001),
            ("E_CORRUPTED_BALANCE_PLAN", -2027),
            ("E_DATA_CONFLICT_ERROR", -3010),
            ("E_DATA_TYPE_MISMATCH", -3003),
            ("E_DISCONNECTED", -1),
            ("E_EDGE_NOT_FOUND", -7),
            ("E_EDGE_PROP_NOT_FOUND", -9),
            ("E_EXECUTION_ERROR", -1005),
            ("E_EXISTED", -2002),
            ("E_FAILED_GET_ABS_PATH", -30),
            ("E_FAILED_TO_CHECKPOINT", -3041),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_FIELD_UNSET", -3007),
            ("E_FILTER_OUT", -3043),
            ("E_ID_FAILED", -3062),
            ("E_IMPROPER_DATA_TYPE", -3021),
            ("E_IMPROPER_ROLE", -2030),
            ("E_INDEX_NOT_FOUND", -8),
            ("E_INDEX_WITH_TTL", -2043),
            ("E_INVALID_CHARSET", -2033),
            ("E_INVALID_COLLATE", -2034),
            ("E_INVALID_DATA", -3044),
            ("E_INVALID_FIELD_VALUE", -3004),
            ("E_INVALID_FILTER", -3031),
            ("E_INVALID_HOST", -2003),
            ("E_INVALID_JOB", -2065),
            ("E_INVALID_OPERATION", -3005),
            ("E_INVALID_PARM", -2009),
            ("E_INVALID_PARTITION_NUM", -2031),
            ("E_INVALID_PASSWORD", -29),
            ("E_INVALID_PEER", -3034),
            ("E_INVALID_REPLICA_FACTOR", -2032),
            ("E_INVALID_SPACEVIDLEN", -3022),
            ("E_INVALID_STAT_TYPE", -3037),
            ("E_INVALID_STORE", -3033),
            ("E_INVALID_TASK_PARA", -3051),
            ("E_INVALID_UPDATER", -3032),
            ("E_INVALID_VID", -3038),
            ("E_JOB_ALREADY_FINISH", -2052),
            ("E_JOB_HAS_NO_TARGET_STORAGE", -2055),
            ("E_JOB_NEED_RECOVER", -2051),
            ("E_JOB_NOT_FINISHED", -2048),
            ("E_JOB_NOT_IN_SPACE", -2050),
            ("E_JOB_NOT_STOPPABLE", -2054),
            ("E_JOB_SUBMITTED", -2053),
            ("E_KEY_HAS_EXISTS", -3002),
            ("E_KEY_NOT_FOUND", -17),
            ("E_LEADER_CHANGED", -4),
            ("E_LEADER_LEASE_FAILED", -3531),
            ("E_LISTENER_NOT_FOUND", -15),
            ("E_LIST_CLUSTER_FAILURE", -2070),
            ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
            ("E_LIST_CLUSTER_NO_AGENT_FAILURE", -2072),
            ("E_LOAD_META_FAILED", -3040),
            ("E_MACHINE_NOT_FOUND", -13),
            ("E_MUTATE_EDGE_CONFLICT", -3045),
            ("E_MUTATE_TAG_CONFLICT", -3046),
            ("E_NOT_DROP", -2005),
            ("E_NOT_NULLABLE", -3006),
            ("E_NO_HOSTS", -2001),
            ("E_NO_INVALID_BALANCE_PLAN", -2028),
            ("E_NO_RUNNING_BALANCE_PLAN", -2025),
            ("E_NO_TERM", -3070),
            ("E_NO_TRANSFORMED", -3039),
            ("E_NO_VALID_HOST", -2026),
            ("E_OUTDATED_EDGE", -3072),
            ("E_OUTDATED_LOCK", -3047),
            ("E_OUTDATED_TERM", -3071),
            ("E_OUT_OF_RANGE", -3008),
            ("E_PARTIAL_RESULT", -27),
            ("E_PARTIAL_SUCCEEDED", -1011),
            ("E_PART_NOT_FOUND", -16),
            ("E_PLAN_IS_KILLED", -3060),
            ("E_QUERY_NOT_FOUND", -2073),
            ("E_RAFT_ATOMIC_OP_FAILED", -3530),
            ("E_RAFT_BAD_ROLE", -3516),
            ("E_RAFT_BUFFER_OVERFLOW", -3529),
            ("E_RAFT_HOST_PAUSED", -3527),
            ("E_RAFT_HOST_STOPPED", -3522),
            ("E_RAFT_INVALID_PEER", -3513),
            ("E_RAFT_LOG_GAP", -3501),
            ("E_RAFT_LOG_STALE", -3502),
            ("E_RAFT_NOT_READY", -3514),
            ("E_RAFT_NO_WAL_FOUND", -3526),
            ("E_RAFT_PERSIST_SNAPSHOT_FAILED", -3524),
            ("E_RAFT_RPC_EXCEPTION", -3525),
            ("E_RAFT_SENDING_SNAPSHOT", -3512),
            ("E_RAFT_STOPPED", -3515),
            ("E_RAFT_TERM_OUT_OF_DATE", -3503),
            ("E_RAFT_TOO_MANY_REQUESTS", -3523),
            ("E_RAFT_UNKNOWN_APPEND_LOG", -3504),
            ("E_RAFT_UNKNOWN_PART", -3500),
            ("E_RAFT_WAITING_SNAPSHOT", -3511),
            ("E_RAFT_WAL_FAIL", -3521),
            ("E_RAFT_WRITE_BLOCKED", -3528),
            ("E_REBUILD_INDEX_FAILED", -28),
            ("E_REBUILD_INDEX_FAILURE", -2042),
            ("E_RELATED_INDEX_EXISTS", -2014),
            ("E_RELATED_SPACE_EXISTS", -2015),
            ("E_RESTORE_FAILURE", -2068),
            ("E_RETRY_EXHAUSTED", -3035),
            ("E_ROLE_NOT_FOUND", -11),
            ("E_RPC_FAILURE", -3),
            ("E_SAVE_JOB_FAILURE", -2046),
            ("E_SCHEMA_NAME_EXISTS", -2013),
            ("E_SEMANTIC_ERROR", -1009),
            ("E_SERVICE_NOT_FOUND", -20),
            ("E_SESSION_INVALID", -1002),
            ("E_SESSION_NOT_FOUND", -2069),
            ("E_SESSION_TIMEOUT", -1003),
            ("E_SNAPSHOT_FAILURE", -2040),
            ("E_SPACE_NOT_FOUND", -5),
            ("E_STATEMENT_EMPTY", -1006),
            ("E_STATS_NOT_FOUND", -19),
            ("E_STOP_JOB_FAILURE", -2045),
            ("E_STORE_FAILURE", -2021),
            ("E_STORE_SEGMENT_ILLEGAL", -2022),
            ("E_SYNTAX_ERROR", -1004),
            ("E_TAG_NOT_FOUND", -6),
            ("E_TAG_PROP_NOT_FOUND", -10),
            ("E_TASK_EXECUTION_FAILED", -3053),
            ("E_TASK_REPORT_OUT_DATE", -2049),
            ("E_TOO_MANY_CONNECTIONS", -1010),
            ("E_TRANSFER_LEADER_FAILED", -3036),
            ("E_UNKNOWN", -8000),
            ("E_UNSUPPORTED", -2004),
            ("E_USER_CANCEL", -3052),
            ("E_USER_NOT_FOUND", -18),
            ("E_WRITE_STALLED", -3011),
            ("E_WRITE_WRITE_CONFLICT", -3073),
            ("E_WRONGCLUSTER", -2010),
            ("E_ZONE_IS_EMPTY", -2012),
            ("E_ZONE_NOT_ENOUGH", -2011),
            ("E_ZONE_NOT_FOUND", -14),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(Self)
    }
}

impl ::fbthrift::GetTType for ErrorCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}















impl ::std::default::Default for SchemaID {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for SchemaID {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for SchemaID
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SchemaID");
        match self {
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for SchemaID
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "SchemaID",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Date {
    fn default() -> Self {
        Self {
            year: ::std::default::Default::default(),
            month: ::std::default::Default::default(),
            day: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Date {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Date")
            .field("year", &self.year)
            .field("month", &self.month)
            .field("day", &self.day)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Date {}
unsafe impl ::std::marker::Sync for self::Date {}

impl ::fbthrift::GetTType for self::Date {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Date
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Date");
        p.write_field_begin("year", ::fbthrift::TType::I16, 1);
        ::fbthrift::Serialize::write(&self.year, p);
        p.write_field_end();
        p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.month, p);
        p.write_field_end();
        p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.day, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Date
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
            ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
        ];
        let mut field_year = ::std::option::Option::None;
        let mut field_month = ::std::option::Option::None;
        let mut field_day = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            year: field_year.unwrap_or_default(),
            month: field_month.unwrap_or_default(),
            day: field_day.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Time {
    fn default() -> Self {
        Self {
            hour: ::std::default::Default::default(),
            minute: ::std::default::Default::default(),
            sec: ::std::default::Default::default(),
            microsec: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Time {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Time")
            .field("hour", &self.hour)
            .field("minute", &self.minute)
            .field("sec", &self.sec)
            .field("microsec", &self.microsec)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Time {}
unsafe impl ::std::marker::Sync for self::Time {}

impl ::fbthrift::GetTType for self::Time {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Time
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Time");
        p.write_field_begin("hour", ::fbthrift::TType::Byte, 1);
        ::fbthrift::Serialize::write(&self.hour, p);
        p.write_field_end();
        p.write_field_begin("minute", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.minute, p);
        p.write_field_end();
        p.write_field_begin("sec", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.sec, p);
        p.write_field_end();
        p.write_field_begin("microsec", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.microsec, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Time
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 1),
            ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 3),
        ];
        let mut field_hour = ::std::option::Option::None;
        let mut field_minute = ::std::option::Option::None;
        let mut field_sec = ::std::option::Option::None;
        let mut field_microsec = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Byte, 1) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hour: field_hour.unwrap_or_default(),
            minute: field_minute.unwrap_or_default(),
            sec: field_sec.unwrap_or_default(),
            microsec: field_microsec.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DateTime {
    fn default() -> Self {
        Self {
            year: ::std::default::Default::default(),
            month: ::std::default::Default::default(),
            day: ::std::default::Default::default(),
            hour: ::std::default::Default::default(),
            minute: ::std::default::Default::default(),
            sec: ::std::default::Default::default(),
            microsec: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DateTime {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DateTime")
            .field("year", &self.year)
            .field("month", &self.month)
            .field("day", &self.day)
            .field("hour", &self.hour)
            .field("minute", &self.minute)
            .field("sec", &self.sec)
            .field("microsec", &self.microsec)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DateTime {}
unsafe impl ::std::marker::Sync for self::DateTime {}

impl ::fbthrift::GetTType for self::DateTime {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DateTime
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DateTime");
        p.write_field_begin("year", ::fbthrift::TType::I16, 1);
        ::fbthrift::Serialize::write(&self.year, p);
        p.write_field_end();
        p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.month, p);
        p.write_field_end();
        p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.day, p);
        p.write_field_end();
        p.write_field_begin("hour", ::fbthrift::TType::Byte, 4);
        ::fbthrift::Serialize::write(&self.hour, p);
        p.write_field_end();
        p.write_field_begin("minute", ::fbthrift::TType::Byte, 5);
        ::fbthrift::Serialize::write(&self.minute, p);
        p.write_field_end();
        p.write_field_begin("sec", ::fbthrift::TType::Byte, 6);
        ::fbthrift::Serialize::write(&self.sec, p);
        p.write_field_end();
        p.write_field_begin("microsec", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.microsec, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DateTime
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
            ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 4),
            ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 5),
            ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 6),
            ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
        ];
        let mut field_year = ::std::option::Option::None;
        let mut field_month = ::std::option::Option::None;
        let mut field_day = ::std::option::Option::None;
        let mut field_hour = ::std::option::Option::None;
        let mut field_minute = ::std::option::Option::None;
        let mut field_sec = ::std::option::Option::None;
        let mut field_microsec = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 4) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 5) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 6) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            year: field_year.unwrap_or_default(),
            month: field_month.unwrap_or_default(),
            day: field_day.unwrap_or_default(),
            hour: field_hour.unwrap_or_default(),
            minute: field_minute.unwrap_or_default(),
            sec: field_sec.unwrap_or_default(),
            microsec: field_microsec.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}



impl ::std::default::Default for Value {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for Value {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for Value
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Value");
        match self {
            Self::nVal(inner) => {
                p.write_field_begin("nVal", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::bVal(inner) => {
                p.write_field_begin("bVal", ::fbthrift::TType::Bool, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::iVal(inner) => {
                p.write_field_begin("iVal", ::fbthrift::TType::I64, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::fVal(inner) => {
                p.write_field_begin("fVal", ::fbthrift::TType::Double, 4);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::sVal(inner) => {
                p.write_field_begin("sVal", ::fbthrift::TType::String, 5);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::dVal(inner) => {
                p.write_field_begin("dVal", ::fbthrift::TType::Struct, 6);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::tVal(inner) => {
                p.write_field_begin("tVal", ::fbthrift::TType::Struct, 7);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::dtVal(inner) => {
                p.write_field_begin("dtVal", ::fbthrift::TType::Struct, 8);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::vVal(inner) => {
                p.write_field_begin("vVal", ::fbthrift::TType::Struct, 9);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::eVal(inner) => {
                p.write_field_begin("eVal", ::fbthrift::TType::Struct, 10);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::pVal(inner) => {
                p.write_field_begin("pVal", ::fbthrift::TType::Struct, 11);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::lVal(inner) => {
                p.write_field_begin("lVal", ::fbthrift::TType::Struct, 12);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::mVal(inner) => {
                p.write_field_begin("mVal", ::fbthrift::TType::Struct, 13);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::uVal(inner) => {
                p.write_field_begin("uVal", ::fbthrift::TType::Struct, 14);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::gVal(inner) => {
                p.write_field_begin("gVal", ::fbthrift::TType::Struct, 15);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::ggVal(inner) => {
                p.write_field_begin("ggVal", ::fbthrift::TType::Struct, 16);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::duVal(inner) => {
                p.write_field_begin("duVal", ::fbthrift::TType::Struct, 17);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for Value
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("bVal", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("dVal", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("dtVal", ::fbthrift::TType::Struct, 8),
            ::fbthrift::Field::new("duVal", ::fbthrift::TType::Struct, 17),
            ::fbthrift::Field::new("eVal", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("fVal", ::fbthrift::TType::Double, 4),
            ::fbthrift::Field::new("gVal", ::fbthrift::TType::Struct, 15),
            ::fbthrift::Field::new("ggVal", ::fbthrift::TType::Struct, 16),
            ::fbthrift::Field::new("iVal", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("lVal", ::fbthrift::TType::Struct, 12),
            ::fbthrift::Field::new("mVal", ::fbthrift::TType::Struct, 13),
            ::fbthrift::Field::new("nVal", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("pVal", ::fbthrift::TType::Struct, 11),
            ::fbthrift::Field::new("sVal", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("tVal", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("uVal", ::fbthrift::TType::Struct, 14),
            ::fbthrift::Field::new("vVal", ::fbthrift::TType::Struct, 9),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::nVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Bool, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::bVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I64, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::iVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Double, 4, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::fVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::String, 5, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::sVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 6, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::dVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 7, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 8, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::dtVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 9, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::vVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 10, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::eVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 11, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::pVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 12, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::lVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 13, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::mVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 14, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::uVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 15, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::gVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 16, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::ggVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 17, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::duVal(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "Value",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NList {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NList {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NList")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NList {}
unsafe impl ::std::marker::Sync for self::NList {}

impl ::fbthrift::GetTType for self::NList {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NList
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NList");
        p.write_field_begin("values", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NList
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NMap {
    fn default() -> Self {
        Self {
            kvs: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NMap {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NMap")
            .field("kvs", &self.kvs)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NMap {}
unsafe impl ::std::marker::Sync for self::NMap {}

impl ::fbthrift::GetTType for self::NMap {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NMap
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NMap");
        p.write_field_begin("kvs", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.kvs, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NMap
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("kvs", ::fbthrift::TType::Map, 1),
        ];
        let mut field_kvs = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_kvs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            kvs: field_kvs.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NSet {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NSet {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NSet")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NSet {}
unsafe impl ::std::marker::Sync for self::NSet {}

impl ::fbthrift::GetTType for self::NSet {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NSet
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NSet");
        p.write_field_begin("values", ::fbthrift::TType::Set, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NSet
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::Set, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Set, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Row {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Row {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Row")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Row {}
unsafe impl ::std::marker::Sync for self::Row {}

impl ::fbthrift::GetTType for self::Row {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Row
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Row");
        p.write_field_begin("values", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Row
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DataSet {
    fn default() -> Self {
        Self {
            column_names: ::std::default::Default::default(),
            rows: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DataSet {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DataSet")
            .field("column_names", &self.column_names)
            .field("rows", &self.rows)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DataSet {}
unsafe impl ::std::marker::Sync for self::DataSet {}

impl ::fbthrift::GetTType for self::DataSet {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DataSet
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DataSet");
        p.write_field_begin("column_names", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.column_names, p);
        p.write_field_end();
        p.write_field_begin("rows", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.rows, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DataSet
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("column_names", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 2),
        ];
        let mut field_column_names = ::std::option::Option::None;
        let mut field_rows = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            column_names: field_column_names.unwrap_or_default(),
            rows: field_rows.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Coordinate {
    fn default() -> Self {
        Self {
            x: ::std::default::Default::default(),
            y: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Coordinate {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Coordinate")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Coordinate {}
unsafe impl ::std::marker::Sync for self::Coordinate {}

impl ::fbthrift::GetTType for self::Coordinate {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Coordinate
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Coordinate");
        p.write_field_begin("x", ::fbthrift::TType::Double, 1);
        ::fbthrift::Serialize::write(&self.x, p);
        p.write_field_end();
        p.write_field_begin("y", ::fbthrift::TType::Double, 2);
        ::fbthrift::Serialize::write(&self.y, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Coordinate
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("x", ::fbthrift::TType::Double, 1),
            ::fbthrift::Field::new("y", ::fbthrift::TType::Double, 2),
        ];
        let mut field_x = ::std::option::Option::None;
        let mut field_y = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Double, 1) => field_x = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 2) => field_y = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            x: field_x.unwrap_or_default(),
            y: field_y.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Point {
    fn default() -> Self {
        Self {
            coord: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Point {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Point")
            .field("coord", &self.coord)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Point {}
unsafe impl ::std::marker::Sync for self::Point {}

impl ::fbthrift::GetTType for self::Point {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Point
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Point");
        p.write_field_begin("coord", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.coord, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Point
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coord", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_coord = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_coord = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coord: field_coord.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LineString {
    fn default() -> Self {
        Self {
            coordList: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LineString {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LineString")
            .field("coordList", &self.coordList)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LineString {}
unsafe impl ::std::marker::Sync for self::LineString {}

impl ::fbthrift::GetTType for self::LineString {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LineString
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LineString");
        p.write_field_begin("coordList", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.coordList, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LineString
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coordList", ::fbthrift::TType::List, 1),
        ];
        let mut field_coordList = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_coordList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coordList: field_coordList.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Polygon {
    fn default() -> Self {
        Self {
            coordListList: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Polygon {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Polygon")
            .field("coordListList", &self.coordListList)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Polygon {}
unsafe impl ::std::marker::Sync for self::Polygon {}

impl ::fbthrift::GetTType for self::Polygon {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Polygon
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Polygon");
        p.write_field_begin("coordListList", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.coordListList, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Polygon
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coordListList", ::fbthrift::TType::List, 1),
        ];
        let mut field_coordListList = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_coordListList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coordListList: field_coordListList.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}



impl ::std::default::Default for Geography {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for Geography {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for Geography
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Geography");
        match self {
            Self::ptVal(inner) => {
                p.write_field_begin("ptVal", ::fbthrift::TType::Struct, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::lsVal(inner) => {
                p.write_field_begin("lsVal", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::pgVal(inner) => {
                p.write_field_begin("pgVal", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for Geography
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("lsVal", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("pgVal", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("ptVal", ::fbthrift::TType::Struct, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::Struct, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::ptVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::lsVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::pgVal(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "Geography",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Tag {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Tag {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Tag")
            .field("name", &self.name)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Tag {}
unsafe impl ::std::marker::Sync for self::Tag {}

impl ::fbthrift::GetTType for self::Tag {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Tag");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Vertex {
    fn default() -> Self {
        Self {
            vid: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Vertex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Vertex")
            .field("vid", &self.vid)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Vertex {}
unsafe impl ::std::marker::Sync for self::Vertex {}

impl ::fbthrift::GetTType for self::Vertex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Vertex");
        p.write_field_begin("vid", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.vid, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("vid", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_vid = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_vid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            vid: field_vid.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Edge {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            dst: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Edge {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Edge")
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("r#type", &self.r#type)
            .field("name", &self.name)
            .field("ranking", &self.ranking)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Edge {}
unsafe impl ::std::marker::Sync for self::Edge {}

impl ::fbthrift::GetTType for self::Edge {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Edge");
        p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("dst", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_dst = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            dst: field_dst.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Step {
    fn default() -> Self {
        Self {
            dst: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Step {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Step")
            .field("dst", &self.dst)
            .field("r#type", &self.r#type)
            .field("name", &self.name)
            .field("ranking", &self.ranking)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Step {}
unsafe impl ::std::marker::Sync for self::Step {}

impl ::fbthrift::GetTType for self::Step {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Step
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Step");
        p.write_field_begin("dst", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Step
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_dst = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            dst: field_dst.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Path {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            steps: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Path {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Path")
            .field("src", &self.src)
            .field("steps", &self.steps)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Path {}
unsafe impl ::std::marker::Sync for self::Path {}

impl ::fbthrift::GetTType for self::Path {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Path
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Path");
        p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("steps", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.steps, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Path
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("steps", ::fbthrift::TType::List, 2),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_steps = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_steps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            steps: field_steps.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostAddr {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            port: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostAddr {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostAddr")
            .field("host", &self.host)
            .field("port", &self.port)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostAddr {}
unsafe impl ::std::marker::Sync for self::HostAddr {}

impl ::fbthrift::GetTType for self::HostAddr {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostAddr
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostAddr");
        p.write_field_begin("host", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("port", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.port, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostAddr
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("port", ::fbthrift::TType::I32, 2),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_port = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            port: field_port.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KeyValue {
    fn default() -> Self {
        Self {
            key: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KeyValue {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KeyValue")
            .field("key", &self.key)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KeyValue {}
unsafe impl ::std::marker::Sync for self::KeyValue {}

impl ::fbthrift::GetTType for self::KeyValue {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KeyValue
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KeyValue");
        p.write_field_begin("key", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KeyValue
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
        ];
        let mut field_key = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            key: field_key.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Duration {
    fn default() -> Self {
        Self {
            seconds: ::std::default::Default::default(),
            microseconds: ::std::default::Default::default(),
            months: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Duration {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Duration")
            .field("seconds", &self.seconds)
            .field("microseconds", &self.microseconds)
            .field("months", &self.months)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Duration {}
unsafe impl ::std::marker::Sync for self::Duration {}

impl ::fbthrift::GetTType for self::Duration {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Duration
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Duration");
        p.write_field_begin("seconds", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.seconds, p);
        p.write_field_end();
        p.write_field_begin("microseconds", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.microseconds, p);
        p.write_field_end();
        p.write_field_begin("months", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.months, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Duration
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("microseconds", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("months", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("seconds", ::fbthrift::TType::I64, 1),
        ];
        let mut field_seconds = ::std::option::Option::None;
        let mut field_microseconds = ::std::option::Option::None;
        let mut field_months = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_seconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_microseconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_months = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            seconds: field_seconds.unwrap_or_default(),
            microseconds: field_microseconds.unwrap_or_default(),
            months: field_months.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LogInfo {
    fn default() -> Self {
        Self {
            log_id: ::std::default::Default::default(),
            term_id: ::std::default::Default::default(),
            commit_log_id: ::std::default::Default::default(),
            checkpoint_path: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LogInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LogInfo")
            .field("log_id", &self.log_id)
            .field("term_id", &self.term_id)
            .field("commit_log_id", &self.commit_log_id)
            .field("checkpoint_path", &self.checkpoint_path)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LogInfo {}
unsafe impl ::std::marker::Sync for self::LogInfo {}

impl ::fbthrift::GetTType for self::LogInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LogInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LogInfo");
        p.write_field_begin("log_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.log_id, p);
        p.write_field_end();
        p.write_field_begin("term_id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.term_id, p);
        p.write_field_end();
        p.write_field_begin("commit_log_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.commit_log_id, p);
        p.write_field_end();
        p.write_field_begin("checkpoint_path", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.checkpoint_path, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LogInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("checkpoint_path", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("commit_log_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("log_id", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("term_id", ::fbthrift::TType::I64, 2),
        ];
        let mut field_log_id = ::std::option::Option::None;
        let mut field_term_id = ::std::option::Option::None;
        let mut field_commit_log_id = ::std::option::Option::None;
        let mut field_checkpoint_path = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_term_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_commit_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_checkpoint_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            log_id: field_log_id.unwrap_or_default(),
            term_id: field_term_id.unwrap_or_default(),
            commit_log_id: field_commit_log_id.unwrap_or_default(),
            checkpoint_path: field_checkpoint_path.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DirInfo {
    fn default() -> Self {
        Self {
            root: ::std::default::Default::default(),
            data: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DirInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DirInfo")
            .field("root", &self.root)
            .field("data", &self.data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DirInfo {}
unsafe impl ::std::marker::Sync for self::DirInfo {}

impl ::fbthrift::GetTType for self::DirInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DirInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DirInfo");
        p.write_field_begin("root", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.root, p);
        p.write_field_end();
        p.write_field_begin("data", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.data, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DirInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("root", ::fbthrift::TType::String, 1),
        ];
        let mut field_root = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_root = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            root: field_root.unwrap_or_default(),
            data: field_data.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CheckpointInfo {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            data_path: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CheckpointInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CheckpointInfo")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("data_path", &self.data_path)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CheckpointInfo {}
unsafe impl ::std::marker::Sync for self::CheckpointInfo {}

impl ::fbthrift::GetTType for self::CheckpointInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CheckpointInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CheckpointInfo");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("data_path", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.data_path, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CheckpointInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data_path", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_data_path = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_data_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            data_path: field_data_path.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LogEntry {
    fn default() -> Self {
        Self {
            cluster: ::std::default::Default::default(),
            log_str: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LogEntry {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LogEntry")
            .field("cluster", &self.cluster)
            .field("log_str", &self.log_str)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LogEntry {}
unsafe impl ::std::marker::Sync for self::LogEntry {}

impl ::fbthrift::GetTType for self::LogEntry {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LogEntry
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LogEntry");
        p.write_field_begin("cluster", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.cluster, p);
        p.write_field_end();
        p.write_field_begin("log_str", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.log_str, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LogEntry
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("log_str", ::fbthrift::TType::String, 2),
        ];
        let mut field_cluster = ::std::option::Option::None;
        let mut field_log_str = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_cluster = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_log_str = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            cluster: field_cluster.unwrap_or_default(),
            log_str: field_log_str.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
