// @generated by Thrift for src/interface/raftex.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `raftex`.

#![allow(clippy::redundant_closure)]


pub type ClusterID = ::std::primitive::i64;

pub type GraphSpaceID = ::std::primitive::i32;

pub type PartitionID = ::std::primitive::i32;

pub type TermID = ::std::primitive::i64;

pub type LogID = ::std::primitive::i64;

pub type Port = ::std::primitive::i32;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AskForVoteRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub candidate_addr: ::std::string::String,
    pub candidate_port: crate::types::Port,
    pub term: crate::types::TermID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    pub is_pre_vote: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AskForVoteResponse {
    pub error_code: common::types::ErrorCode,
    pub current_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RaftLogEntry {
    pub cluster: crate::types::ClusterID,
    pub log_str: ::std::vec::Vec<::std::primitive::u8>,
    pub log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AppendLogRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub current_term: crate::types::TermID,
    pub committed_log_id: crate::types::LogID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub last_log_term_sent: crate::types::TermID,
    pub last_log_id_sent: crate::types::LogID,
    pub log_str_list: ::std::vec::Vec<crate::types::RaftLogEntry>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AppendLogResponse {
    pub error_code: common::types::ErrorCode,
    pub current_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub committed_log_id: crate::types::LogID,
    pub last_matched_log_id: crate::types::LogID,
    pub last_matched_log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SendSnapshotRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub current_term: crate::types::TermID,
    pub committed_log_id: crate::types::LogID,
    pub committed_log_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub rows: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub total_size: ::std::primitive::i64,
    pub total_count: ::std::primitive::i64,
    pub done: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HeartbeatRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub current_term: crate::types::TermID,
    pub committed_log_id: crate::types::LogID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub last_log_term_sent: crate::types::TermID,
    pub last_log_id_sent: crate::types::LogID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HeartbeatResponse {
    pub error_code: common::types::ErrorCode,
    pub current_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub committed_log_id: crate::types::LogID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SendSnapshotResponse {
    pub error_code: common::types::ErrorCode,
    pub current_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetStateRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetStateResponse {
    pub error_code: common::types::ErrorCode,
    pub role: crate::types::Role,
    pub term: crate::types::TermID,
    pub is_leader: ::std::primitive::bool,
    pub committed_log_id: crate::types::LogID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    pub status: crate::types::Status,
    pub peers: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Role(pub ::std::primitive::i32);

impl Role {
    pub const LEADER: Self = Role(1i32);
    pub const FOLLOWER: Self = Role(2i32);
    pub const CANDIDATE: Self = Role(3i32);
    pub const LEARNER: Self = Role(4i32);
}

impl ::fbthrift::ThriftEnum for Role {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::LEADER, "LEADER"),
            (Self::FOLLOWER, "FOLLOWER"),
            (Self::CANDIDATE, "CANDIDATE"),
            (Self::LEARNER, "LEARNER"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "LEADER",
            "FOLLOWER",
            "CANDIDATE",
            "LEARNER",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::LEADER,
            Self::FOLLOWER,
            Self::CANDIDATE,
            Self::LEARNER,
        ]
    }
}

impl ::std::default::Default for Role {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a Role> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a Role) -> Self {
        x.0
    }
}

impl ::std::convert::From<Role> for ::std::primitive::i32 {
    #[inline]
    fn from(x: Role) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for Role {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for Role {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("LEADER", 1),
            ("FOLLOWER", 2),
            ("CANDIDATE", 3),
            ("LEARNER", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for Role {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "Role::{}", self)
    }
}

impl ::std::str::FromStr for Role {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("CANDIDATE", 3),
            ("FOLLOWER", 2),
            ("LEADER", 1),
            ("LEARNER", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Role").map(Self)
    }
}

impl ::fbthrift::GetTType for Role {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for Role
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for Role
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Status(pub ::std::primitive::i32);

impl Status {
    pub const STARTING: Self = Status(0i32);
    pub const RUNNING: Self = Status(1i32);
    pub const STOPPED: Self = Status(2i32);
    pub const WAITING_SNAPSHOT: Self = Status(3i32);
}

impl ::fbthrift::ThriftEnum for Status {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::STARTING, "STARTING"),
            (Self::RUNNING, "RUNNING"),
            (Self::STOPPED, "STOPPED"),
            (Self::WAITING_SNAPSHOT, "WAITING_SNAPSHOT"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "STARTING",
            "RUNNING",
            "STOPPED",
            "WAITING_SNAPSHOT",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::STARTING,
            Self::RUNNING,
            Self::STOPPED,
            Self::WAITING_SNAPSHOT,
        ]
    }
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a Status> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a Status) -> Self {
        x.0
    }
}

impl ::std::convert::From<Status> for ::std::primitive::i32 {
    #[inline]
    fn from(x: Status) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for Status {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for Status {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("STARTING", 0),
            ("RUNNING", 1),
            ("STOPPED", 2),
            ("WAITING_SNAPSHOT", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "Status::{}", self)
    }
}

impl ::std::str::FromStr for Status {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("RUNNING", 1),
            ("STARTING", 0),
            ("STOPPED", 2),
            ("WAITING_SNAPSHOT", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Status").map(Self)
    }
}

impl ::fbthrift::GetTType for Status {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for Status
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for Status
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}







#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AskForVoteRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            candidate_addr: ::std::default::Default::default(),
            candidate_port: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            is_pre_vote: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AskForVoteRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AskForVoteRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("candidate_addr", &self.candidate_addr)
            .field("candidate_port", &self.candidate_port)
            .field("term", &self.term)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .field("is_pre_vote", &self.is_pre_vote)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AskForVoteRequest {}
unsafe impl ::std::marker::Sync for self::AskForVoteRequest {}

impl ::fbthrift::GetTType for self::AskForVoteRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AskForVoteRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AskForVoteRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("candidate_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.candidate_addr, p);
        p.write_field_end();
        p.write_field_begin("candidate_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.candidate_port, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_begin("is_pre_vote", ::fbthrift::TType::Bool, 8);
        ::fbthrift::Serialize::write(&self.is_pre_vote, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AskForVoteRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("candidate_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("candidate_port", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("is_pre_vote", ::fbthrift::TType::Bool, 8),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 5),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_candidate_addr = ::std::option::Option::None;
        let mut field_candidate_port = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let mut field_is_pre_vote = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_candidate_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_candidate_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 8) => field_is_pre_vote = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            candidate_addr: field_candidate_addr.unwrap_or_default(),
            candidate_port: field_candidate_port.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            is_pre_vote: field_is_pre_vote.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AskForVoteResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AskForVoteResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AskForVoteResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AskForVoteResponse {}
unsafe impl ::std::marker::Sync for self::AskForVoteResponse {}

impl ::fbthrift::GetTType for self::AskForVoteResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AskForVoteResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AskForVoteResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AskForVoteResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RaftLogEntry {
    fn default() -> Self {
        Self {
            cluster: ::std::default::Default::default(),
            log_str: ::std::default::Default::default(),
            log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RaftLogEntry {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RaftLogEntry")
            .field("cluster", &self.cluster)
            .field("log_str", &self.log_str)
            .field("log_term", &self.log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RaftLogEntry {}
unsafe impl ::std::marker::Sync for self::RaftLogEntry {}

impl ::fbthrift::GetTType for self::RaftLogEntry {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RaftLogEntry
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RaftLogEntry");
        p.write_field_begin("cluster", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.cluster, p);
        p.write_field_end();
        p.write_field_begin("log_str", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.log_str, p);
        p.write_field_end();
        p.write_field_begin("log_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RaftLogEntry
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("log_str", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("log_term", ::fbthrift::TType::I64, 3),
        ];
        let mut field_cluster = ::std::option::Option::None;
        let mut field_log_str = ::std::option::Option::None;
        let mut field_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_cluster = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_log_str = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            cluster: field_cluster.unwrap_or_default(),
            log_str: field_log_str.unwrap_or_default(),
            log_term: field_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AppendLogRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            last_log_term_sent: ::std::default::Default::default(),
            last_log_id_sent: ::std::default::Default::default(),
            log_str_list: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AppendLogRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AppendLogRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("current_term", &self.current_term)
            .field("committed_log_id", &self.committed_log_id)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("last_log_term_sent", &self.last_log_term_sent)
            .field("last_log_id_sent", &self.last_log_id_sent)
            .field("log_str_list", &self.log_str_list)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AppendLogRequest {}
unsafe impl ::std::marker::Sync for self::AppendLogRequest {}

impl ::fbthrift::GetTType for self::AppendLogRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AppendLogRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AppendLogRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("last_log_term_sent", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term_sent, p);
        p.write_field_end();
        p.write_field_begin("last_log_id_sent", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.last_log_id_sent, p);
        p.write_field_end();
        p.write_field_begin("log_str_list", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.log_str_list, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AppendLogRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("last_log_id_sent", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("last_log_term_sent", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 6),
            ::fbthrift::Field::new("log_str_list", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_last_log_term_sent = ::std::option::Option::None;
        let mut field_last_log_id_sent = ::std::option::Option::None;
        let mut field_log_str_list = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_last_log_id_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_log_str_list = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            last_log_term_sent: field_last_log_term_sent.unwrap_or_default(),
            last_log_id_sent: field_last_log_id_sent.unwrap_or_default(),
            log_str_list: field_log_str_list.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AppendLogResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            last_matched_log_id: ::std::default::Default::default(),
            last_matched_log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AppendLogResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AppendLogResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("committed_log_id", &self.committed_log_id)
            .field("last_matched_log_id", &self.last_matched_log_id)
            .field("last_matched_log_term", &self.last_matched_log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AppendLogResponse {}
unsafe impl ::std::marker::Sync for self::AppendLogResponse {}

impl ::fbthrift::GetTType for self::AppendLogResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AppendLogResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AppendLogResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_matched_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_matched_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_matched_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_matched_log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AppendLogResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_matched_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_matched_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_last_matched_log_id = ::std::option::Option::None;
        let mut field_last_matched_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_matched_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_matched_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            last_matched_log_id: field_last_matched_log_id.unwrap_or_default(),
            last_matched_log_term: field_last_matched_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SendSnapshotRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            committed_log_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            rows: ::std::default::Default::default(),
            total_size: ::std::default::Default::default(),
            total_count: ::std::default::Default::default(),
            done: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SendSnapshotRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SendSnapshotRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("current_term", &self.current_term)
            .field("committed_log_id", &self.committed_log_id)
            .field("committed_log_term", &self.committed_log_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("rows", &self.rows)
            .field("total_size", &self.total_size)
            .field("total_count", &self.total_count)
            .field("done", &self.done)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SendSnapshotRequest {}
unsafe impl ::std::marker::Sync for self::SendSnapshotRequest {}

impl ::fbthrift::GetTType for self::SendSnapshotRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SendSnapshotRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SendSnapshotRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("committed_log_term", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("rows", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.rows, p);
        p.write_field_end();
        p.write_field_begin("total_size", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.total_size, p);
        p.write_field_end();
        p.write_field_begin("total_count", ::fbthrift::TType::I64, 10);
        ::fbthrift::Serialize::write(&self.total_count, p);
        p.write_field_end();
        p.write_field_begin("done", ::fbthrift::TType::Bool, 11);
        ::fbthrift::Serialize::write(&self.done, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SendSnapshotRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("committed_log_term", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("done", ::fbthrift::TType::Bool, 11),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 8),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("total_count", ::fbthrift::TType::I64, 10),
            ::fbthrift::Field::new("total_size", ::fbthrift::TType::I64, 9),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_committed_log_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_rows = ::std::option::Option::None;
        let mut field_total_size = ::std::option::Option::None;
        let mut field_total_count = ::std::option::Option::None;
        let mut field_done = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_total_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 10) => field_total_count = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 11) => field_done = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            committed_log_term: field_committed_log_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            rows: field_rows.unwrap_or_default(),
            total_size: field_total_size.unwrap_or_default(),
            total_count: field_total_count.unwrap_or_default(),
            done: field_done.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HeartbeatRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            last_log_term_sent: ::std::default::Default::default(),
            last_log_id_sent: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HeartbeatRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HeartbeatRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("current_term", &self.current_term)
            .field("committed_log_id", &self.committed_log_id)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("last_log_term_sent", &self.last_log_term_sent)
            .field("last_log_id_sent", &self.last_log_id_sent)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HeartbeatRequest {}
unsafe impl ::std::marker::Sync for self::HeartbeatRequest {}

impl ::fbthrift::GetTType for self::HeartbeatRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HeartbeatRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HeartbeatRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("last_log_term_sent", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.last_log_term_sent, p);
        p.write_field_end();
        p.write_field_begin("last_log_id_sent", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.last_log_id_sent, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HeartbeatRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("last_log_id_sent", ::fbthrift::TType::I64, 9),
            ::fbthrift::Field::new("last_log_term_sent", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_last_log_term_sent = ::std::option::Option::None;
        let mut field_last_log_id_sent = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_last_log_term_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_last_log_id_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            last_log_term_sent: field_last_log_term_sent.unwrap_or_default(),
            last_log_id_sent: field_last_log_id_sent.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HeartbeatResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HeartbeatResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HeartbeatResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("committed_log_id", &self.committed_log_id)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HeartbeatResponse {}
unsafe impl ::std::marker::Sync for self::HeartbeatResponse {}

impl ::fbthrift::GetTType for self::HeartbeatResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HeartbeatResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HeartbeatResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HeartbeatResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SendSnapshotResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SendSnapshotResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SendSnapshotResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SendSnapshotResponse {}
unsafe impl ::std::marker::Sync for self::SendSnapshotResponse {}

impl ::fbthrift::GetTType for self::SendSnapshotResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SendSnapshotResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SendSnapshotResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SendSnapshotResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStateRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStateRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStateRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStateRequest {}
unsafe impl ::std::marker::Sync for self::GetStateRequest {}

impl ::fbthrift::GetTType for self::GetStateRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStateRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStateRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStateRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStateResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            role: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            is_leader: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            peers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStateResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStateResponse")
            .field("error_code", &self.error_code)
            .field("role", &self.role)
            .field("term", &self.term)
            .field("is_leader", &self.is_leader)
            .field("committed_log_id", &self.committed_log_id)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .field("status", &self.status)
            .field("peers", &self.peers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStateResponse {}
unsafe impl ::std::marker::Sync for self::GetStateResponse {}

impl ::fbthrift::GetTType for self::GetStateResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStateResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStateResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("role", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_begin("is_leader", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.is_leader, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 8);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("peers", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStateResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("is_leader", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 8),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 3),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_role = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_is_leader = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_is_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 8) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            role: field_role.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            is_leader: field_is_leader.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            peers: field_peers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
