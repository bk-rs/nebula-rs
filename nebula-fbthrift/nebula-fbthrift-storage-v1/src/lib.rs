// @generated by Thrift for src/interface/storage.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(bare_trait_objects)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types;

#[doc(hidden)]
pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod storage_service {
        #[derive(Clone, Debug)]
        pub enum GetBoundExn {
            #[doc(hidden)]
            Success(crate::types::QueryResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetBoundError> for GetBoundExn {
            fn from(err: crate::errors::storage_service::GetBoundError) -> Self {
                match err {
                    crate::errors::storage_service::GetBoundError::ApplicationException(aexn) => GetBoundExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetBoundError::ThriftError(err) => GetBoundExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBoundExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetBoundExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetBoundExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetBoundExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetBoundExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetBound");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetBoundExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetBoundExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetBoundExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BoundStatsExn {
            #[doc(hidden)]
            Success(crate::types::QueryStatsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::BoundStatsError> for BoundStatsExn {
            fn from(err: crate::errors::storage_service::BoundStatsError) -> Self {
                match err {
                    crate::errors::storage_service::BoundStatsError::ApplicationException(aexn) => BoundStatsExn::ApplicationException(aexn),
                    crate::errors::storage_service::BoundStatsError::ThriftError(err) => BoundStatsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BoundStatsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for BoundStatsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for BoundStatsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for BoundStatsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BoundStatsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("BoundStats");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BoundStatsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BoundStatsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BoundStatsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPropsExn {
            #[doc(hidden)]
            Success(crate::types::QueryResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetPropsError> for GetPropsExn {
            fn from(err: crate::errors::storage_service::GetPropsError) -> Self {
                match err {
                    crate::errors::storage_service::GetPropsError::ApplicationException(aexn) => GetPropsExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetPropsError::ThriftError(err) => GetPropsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetPropsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetPropsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetPropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetProps");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgePropsExn {
            #[doc(hidden)]
            Success(crate::types::EdgePropResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetEdgePropsError> for GetEdgePropsExn {
            fn from(err: crate::errors::storage_service::GetEdgePropsError) -> Self {
                match err {
                    crate::errors::storage_service::GetEdgePropsError::ApplicationException(aexn) => GetEdgePropsExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetEdgePropsError::ThriftError(err) => GetEdgePropsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgePropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEdgePropsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEdgePropsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEdgePropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgePropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdgeProps");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgePropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgePropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgePropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddVerticesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::AddVerticesError> for AddVerticesExn {
            fn from(err: crate::errors::storage_service::AddVerticesError) -> Self {
                match err {
                    crate::errors::storage_service::AddVerticesError::ApplicationException(aexn) => AddVerticesExn::ApplicationException(aexn),
                    crate::errors::storage_service::AddVerticesError::ThriftError(err) => AddVerticesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddVerticesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddVerticesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddVertices");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::AddEdgesError> for AddEdgesExn {
            fn from(err: crate::errors::storage_service::AddEdgesError) -> Self {
                match err {
                    crate::errors::storage_service::AddEdgesError::ApplicationException(aexn) => AddEdgesExn::ApplicationException(aexn),
                    crate::errors::storage_service::AddEdgesError::ThriftError(err) => AddEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::DeleteEdgesError> for DeleteEdgesExn {
            fn from(err: crate::errors::storage_service::DeleteEdgesError) -> Self {
                match err {
                    crate::errors::storage_service::DeleteEdgesError::ApplicationException(aexn) => DeleteEdgesExn::ApplicationException(aexn),
                    crate::errors::storage_service::DeleteEdgesError::ThriftError(err) => DeleteEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DeleteEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DeleteEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DeleteEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DeleteEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteVerticesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::DeleteVerticesError> for DeleteVerticesExn {
            fn from(err: crate::errors::storage_service::DeleteVerticesError) -> Self {
                match err {
                    crate::errors::storage_service::DeleteVerticesError::ApplicationException(aexn) => DeleteVerticesExn::ApplicationException(aexn),
                    crate::errors::storage_service::DeleteVerticesError::ThriftError(err) => DeleteVerticesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DeleteVerticesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DeleteVerticesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DeleteVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DeleteVertices");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateVertexExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::UpdateVertexError> for UpdateVertexExn {
            fn from(err: crate::errors::storage_service::UpdateVertexError) -> Self {
                match err {
                    crate::errors::storage_service::UpdateVertexError::ApplicationException(aexn) => UpdateVertexExn::ApplicationException(aexn),
                    crate::errors::storage_service::UpdateVertexError::ThriftError(err) => UpdateVertexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UpdateVertexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UpdateVertexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for UpdateVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateVertex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::UpdateEdgeError> for UpdateEdgeExn {
            fn from(err: crate::errors::storage_service::UpdateEdgeError) -> Self {
                match err {
                    crate::errors::storage_service::UpdateEdgeError::ApplicationException(aexn) => UpdateEdgeExn::ApplicationException(aexn),
                    crate::errors::storage_service::UpdateEdgeError::ThriftError(err) => UpdateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UpdateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UpdateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for UpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ScanEdgeResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::ScanEdgeError> for ScanEdgeExn {
            fn from(err: crate::errors::storage_service::ScanEdgeError) -> Self {
                match err {
                    crate::errors::storage_service::ScanEdgeError::ApplicationException(aexn) => ScanEdgeExn::ApplicationException(aexn),
                    crate::errors::storage_service::ScanEdgeError::ThriftError(err) => ScanEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ScanEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanVertexExn {
            #[doc(hidden)]
            Success(crate::types::ScanVertexResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::ScanVertexError> for ScanVertexExn {
            fn from(err: crate::errors::storage_service::ScanVertexError) -> Self {
                match err {
                    crate::errors::storage_service::ScanVertexError::ApplicationException(aexn) => ScanVertexExn::ApplicationException(aexn),
                    crate::errors::storage_service::ScanVertexError::ThriftError(err) => ScanVertexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanVertexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanVertexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ScanVertex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum TransLeaderExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::TransLeaderError> for TransLeaderExn {
            fn from(err: crate::errors::storage_service::TransLeaderError) -> Self {
                match err {
                    crate::errors::storage_service::TransLeaderError::ApplicationException(aexn) => TransLeaderExn::ApplicationException(aexn),
                    crate::errors::storage_service::TransLeaderError::ThriftError(err) => TransLeaderExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for TransLeaderExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for TransLeaderExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for TransLeaderExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for TransLeaderExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("TransLeader");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "TransLeaderExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "TransLeaderExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddPartExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::AddPartError> for AddPartExn {
            fn from(err: crate::errors::storage_service::AddPartError) -> Self {
                match err {
                    crate::errors::storage_service::AddPartError::ApplicationException(aexn) => AddPartExn::ApplicationException(aexn),
                    crate::errors::storage_service::AddPartError::ThriftError(err) => AddPartExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddPartExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddPartExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddPart");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddLearnerExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::AddLearnerError> for AddLearnerExn {
            fn from(err: crate::errors::storage_service::AddLearnerError) -> Self {
                match err {
                    crate::errors::storage_service::AddLearnerError::ApplicationException(aexn) => AddLearnerExn::ApplicationException(aexn),
                    crate::errors::storage_service::AddLearnerError::ThriftError(err) => AddLearnerExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddLearnerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddLearnerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddLearnerExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddLearnerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddLearner");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddLearnerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddLearnerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum WaitingForCatchUpDataExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::WaitingForCatchUpDataError> for WaitingForCatchUpDataExn {
            fn from(err: crate::errors::storage_service::WaitingForCatchUpDataError) -> Self {
                match err {
                    crate::errors::storage_service::WaitingForCatchUpDataError::ApplicationException(aexn) => WaitingForCatchUpDataExn::ApplicationException(aexn),
                    crate::errors::storage_service::WaitingForCatchUpDataError::ThriftError(err) => WaitingForCatchUpDataExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for WaitingForCatchUpDataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for WaitingForCatchUpDataExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for WaitingForCatchUpDataExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for WaitingForCatchUpDataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("WaitingForCatchUpData");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "WaitingForCatchUpDataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "WaitingForCatchUpDataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemovePartExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::RemovePartError> for RemovePartExn {
            fn from(err: crate::errors::storage_service::RemovePartError) -> Self {
                match err {
                    crate::errors::storage_service::RemovePartError::ApplicationException(aexn) => RemovePartExn::ApplicationException(aexn),
                    crate::errors::storage_service::RemovePartError::ThriftError(err) => RemovePartExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemovePartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemovePartExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemovePartExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemovePartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemovePart");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemovePartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemovePartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MemberChangeExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::MemberChangeError> for MemberChangeExn {
            fn from(err: crate::errors::storage_service::MemberChangeError) -> Self {
                match err {
                    crate::errors::storage_service::MemberChangeError::ApplicationException(aexn) => MemberChangeExn::ApplicationException(aexn),
                    crate::errors::storage_service::MemberChangeError::ThriftError(err) => MemberChangeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MemberChangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MemberChangeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MemberChangeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MemberChangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MemberChange");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MemberChangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MemberChangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckPeersExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::CheckPeersError> for CheckPeersExn {
            fn from(err: crate::errors::storage_service::CheckPeersError) -> Self {
                match err {
                    crate::errors::storage_service::CheckPeersError::ApplicationException(aexn) => CheckPeersExn::ApplicationException(aexn),
                    crate::errors::storage_service::CheckPeersError::ThriftError(err) => CheckPeersExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPeersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CheckPeersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CheckPeersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CheckPeersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CheckPeers");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckPeersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckPeersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetLeaderPartExn {
            #[doc(hidden)]
            Success(crate::types::GetLeaderResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetLeaderPartError> for GetLeaderPartExn {
            fn from(err: crate::errors::storage_service::GetLeaderPartError) -> Self {
                match err {
                    crate::errors::storage_service::GetLeaderPartError::ApplicationException(aexn) => GetLeaderPartExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetLeaderPartError::ThriftError(err) => GetLeaderPartExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetLeaderPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetLeaderPartExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetLeaderPartExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetLeaderPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetLeaderPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetLeaderPart");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetLeaderPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetLeaderPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetLeaderPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateCheckpointExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::CreateCheckpointError> for CreateCheckpointExn {
            fn from(err: crate::errors::storage_service::CreateCheckpointError) -> Self {
                match err {
                    crate::errors::storage_service::CreateCheckpointError::ApplicationException(aexn) => CreateCheckpointExn::ApplicationException(aexn),
                    crate::errors::storage_service::CreateCheckpointError::ThriftError(err) => CreateCheckpointExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateCheckpointExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateCheckpointExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateCheckpoint");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropCheckpointExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::DropCheckpointError> for DropCheckpointExn {
            fn from(err: crate::errors::storage_service::DropCheckpointError) -> Self {
                match err {
                    crate::errors::storage_service::DropCheckpointError::ApplicationException(aexn) => DropCheckpointExn::ApplicationException(aexn),
                    crate::errors::storage_service::DropCheckpointError::ThriftError(err) => DropCheckpointExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropCheckpointExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropCheckpointExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropCheckpoint");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BlockingWritesExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::BlockingWritesError> for BlockingWritesExn {
            fn from(err: crate::errors::storage_service::BlockingWritesError) -> Self {
                match err {
                    crate::errors::storage_service::BlockingWritesError::ApplicationException(aexn) => BlockingWritesExn::ApplicationException(aexn),
                    crate::errors::storage_service::BlockingWritesError::ThriftError(err) => BlockingWritesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BlockingWritesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for BlockingWritesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for BlockingWritesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for BlockingWritesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("BlockingWrites");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BlockingWritesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BlockingWritesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::RebuildTagIndexError> for RebuildTagIndexExn {
            fn from(err: crate::errors::storage_service::RebuildTagIndexError) -> Self {
                match err {
                    crate::errors::storage_service::RebuildTagIndexError::ApplicationException(aexn) => RebuildTagIndexExn::ApplicationException(aexn),
                    crate::errors::storage_service::RebuildTagIndexError::ThriftError(err) => RebuildTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::RebuildEdgeIndexError> for RebuildEdgeIndexExn {
            fn from(err: crate::errors::storage_service::RebuildEdgeIndexError) -> Self {
                match err {
                    crate::errors::storage_service::RebuildEdgeIndexError::ApplicationException(aexn) => RebuildEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::storage_service::RebuildEdgeIndexError::ThriftError(err) => RebuildEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum PutExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::PutError> for PutExn {
            fn from(err: crate::errors::storage_service::PutError) -> Self {
                match err {
                    crate::errors::storage_service::PutError::ApplicationException(aexn) => PutExn::ApplicationException(aexn),
                    crate::errors::storage_service::PutError::ThriftError(err) => PutExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for PutExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for PutExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for PutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Put");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "PutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "PutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            #[doc(hidden)]
            Success(crate::types::GeneralResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetError> for GetExn {
            fn from(err: crate::errors::storage_service::GetError) -> Self {
                match err {
                    crate::errors::storage_service::GetError::ApplicationException(aexn) => GetExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetError::ThriftError(err) => GetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Get");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::RemoveError> for RemoveExn {
            fn from(err: crate::errors::storage_service::RemoveError) -> Self {
                match err {
                    crate::errors::storage_service::RemoveError::ApplicationException(aexn) => RemoveExn::ApplicationException(aexn),
                    crate::errors::storage_service::RemoveError::ThriftError(err) => RemoveExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Remove");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::RemoveRangeError> for RemoveRangeExn {
            fn from(err: crate::errors::storage_service::RemoveRangeError) -> Self {
                match err {
                    crate::errors::storage_service::RemoveRangeError::ApplicationException(aexn) => RemoveRangeExn::ApplicationException(aexn),
                    crate::errors::storage_service::RemoveRangeError::ThriftError(err) => RemoveRangeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveRangeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveRangeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveRange");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUUIDExn {
            #[doc(hidden)]
            Success(crate::types::GetUUIDResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::GetUUIDError> for GetUUIDExn {
            fn from(err: crate::errors::storage_service::GetUUIDError) -> Self {
                match err {
                    crate::errors::storage_service::GetUUIDError::ApplicationException(aexn) => GetUUIDExn::ApplicationException(aexn),
                    crate::errors::storage_service::GetUUIDError::ThriftError(err) => GetUUIDExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUUIDExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetUUIDExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetUUIDExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetUUIDExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetUUID");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUUIDExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUUIDExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookUpIndexExn {
            #[doc(hidden)]
            Success(crate::types::LookUpIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_service::LookUpIndexError> for LookUpIndexExn {
            fn from(err: crate::errors::storage_service::LookUpIndexError) -> Self {
                match err {
                    crate::errors::storage_service::LookUpIndexError::ApplicationException(aexn) => LookUpIndexExn::ApplicationException(aexn),
                    crate::errors::storage_service::LookUpIndexError::ThriftError(err) => LookUpIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookUpIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for LookUpIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for LookUpIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for LookUpIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookUpIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("LookUpIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookUpIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookUpIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookUpIndexExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `storage`.
pub mod client {

    pub struct StorageServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> StorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _getBound_impl(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getBound";
            }
            let args = self::Args_StorageService_getBound {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getBound", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.getBound"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetBoundExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetBoundError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.getBound"))
            .boxed()
        }

        fn _boundStats_impl(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.boundStats";
            }
            let args = self::Args_StorageService_boundStats {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("boundStats", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.boundStats"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::BoundStatsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::BoundStatsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.boundStats"))
            .boxed()
        }

        fn _getProps_impl(
            &self,
            arg_req: &crate::types::VertexPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getProps";
            }
            let args = self::Args_StorageService_getProps {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getProps", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.getProps"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetPropsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetPropsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.getProps"))
            .boxed()
        }

        fn _getEdgeProps_impl(
            &self,
            arg_req: &crate::types::EdgePropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getEdgeProps";
            }
            let args = self::Args_StorageService_getEdgeProps {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEdgeProps", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.getEdgeProps"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetEdgePropsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetEdgePropsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.getEdgeProps"))
            .boxed()
        }

        fn _addVertices_impl(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addVertices";
            }
            let args = self::Args_StorageService_addVertices {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addVertices", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.addVertices"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::AddVerticesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::AddVerticesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.addVertices"))
            .boxed()
        }

        fn _addEdges_impl(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addEdges";
            }
            let args = self::Args_StorageService_addEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.addEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::AddEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::AddEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.addEdges"))
            .boxed()
        }

        fn _deleteEdges_impl(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.deleteEdges";
            }
            let args = self::Args_StorageService_deleteEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("deleteEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.deleteEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::DeleteEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::DeleteEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.deleteEdges"))
            .boxed()
        }

        fn _deleteVertices_impl(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.deleteVertices";
            }
            let args = self::Args_StorageService_deleteVertices {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("deleteVertices", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.deleteVertices"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::DeleteVerticesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::DeleteVerticesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.deleteVertices"))
            .boxed()
        }

        fn _updateVertex_impl(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.updateVertex";
            }
            let args = self::Args_StorageService_updateVertex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("updateVertex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.updateVertex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::UpdateVertexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::UpdateVertexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.updateVertex"))
            .boxed()
        }

        fn _updateEdge_impl(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.updateEdge";
            }
            let args = self::Args_StorageService_updateEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("updateEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.updateEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::UpdateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::UpdateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.updateEdge"))
            .boxed()
        }

        fn _scanEdge_impl(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.scanEdge";
            }
            let args = self::Args_StorageService_scanEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scanEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.scanEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::ScanEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::ScanEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.scanEdge"))
            .boxed()
        }

        fn _scanVertex_impl(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.scanVertex";
            }
            let args = self::Args_StorageService_scanVertex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scanVertex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.scanVertex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::ScanVertexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::ScanVertexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.scanVertex"))
            .boxed()
        }

        fn _transLeader_impl(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.transLeader";
            }
            let args = self::Args_StorageService_transLeader {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("transLeader", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.transLeader"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::TransLeaderExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::TransLeaderError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.transLeader"))
            .boxed()
        }

        fn _addPart_impl(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addPart";
            }
            let args = self::Args_StorageService_addPart {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addPart", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.addPart"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::AddPartExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::AddPartError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.addPart"))
            .boxed()
        }

        fn _addLearner_impl(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addLearner";
            }
            let args = self::Args_StorageService_addLearner {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addLearner", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.addLearner"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::AddLearnerExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::AddLearnerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.addLearner"))
            .boxed()
        }

        fn _waitingForCatchUpData_impl(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.waitingForCatchUpData";
            }
            let args = self::Args_StorageService_waitingForCatchUpData {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("waitingForCatchUpData", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.waitingForCatchUpData"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::WaitingForCatchUpDataExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::WaitingForCatchUpDataError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.waitingForCatchUpData"))
            .boxed()
        }

        fn _removePart_impl(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.removePart";
            }
            let args = self::Args_StorageService_removePart {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removePart", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.removePart"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::RemovePartExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::RemovePartError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.removePart"))
            .boxed()
        }

        fn _memberChange_impl(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.memberChange";
            }
            let args = self::Args_StorageService_memberChange {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("memberChange", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.memberChange"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::MemberChangeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::MemberChangeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.memberChange"))
            .boxed()
        }

        fn _checkPeers_impl(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.checkPeers";
            }
            let args = self::Args_StorageService_checkPeers {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("checkPeers", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.checkPeers"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::CheckPeersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::CheckPeersError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.checkPeers"))
            .boxed()
        }

        fn _getLeaderPart_impl(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getLeaderPart";
            }
            let args = self::Args_StorageService_getLeaderPart {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getLeaderPart", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.getLeaderPart"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetLeaderPartExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetLeaderPartError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.getLeaderPart"))
            .boxed()
        }

        fn _createCheckpoint_impl(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.createCheckpoint";
            }
            let args = self::Args_StorageService_createCheckpoint {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createCheckpoint", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.createCheckpoint"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::CreateCheckpointExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::CreateCheckpointError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.createCheckpoint"))
            .boxed()
        }

        fn _dropCheckpoint_impl(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.dropCheckpoint";
            }
            let args = self::Args_StorageService_dropCheckpoint {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropCheckpoint", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.dropCheckpoint"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::DropCheckpointExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::DropCheckpointError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.dropCheckpoint"))
            .boxed()
        }

        fn _blockingWrites_impl(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.blockingWrites";
            }
            let args = self::Args_StorageService_blockingWrites {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("blockingWrites", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.blockingWrites"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::BlockingWritesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::BlockingWritesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.blockingWrites"))
            .boxed()
        }

        fn _rebuildTagIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.rebuildTagIndex";
            }
            let args = self::Args_StorageService_rebuildTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.rebuildTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::RebuildTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::RebuildTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.rebuildTagIndex"))
            .boxed()
        }

        fn _rebuildEdgeIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.rebuildEdgeIndex";
            }
            let args = self::Args_StorageService_rebuildEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.rebuildEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::RebuildEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::RebuildEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.rebuildEdgeIndex"))
            .boxed()
        }

        fn _put_impl(
            &self,
            arg_req: &crate::types::PutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.put";
            }
            let args = self::Args_StorageService_put {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("put", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.put"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::PutExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::PutError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.put"))
            .boxed()
        }

        fn _get_impl(
            &self,
            arg_req: &crate::types::GetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.get";
            }
            let args = self::Args_StorageService_get {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("get", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.get"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.get"))
            .boxed()
        }

        fn _remove_impl(
            &self,
            arg_req: &crate::types::RemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.remove";
            }
            let args = self::Args_StorageService_remove {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("remove", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.remove"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::RemoveExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::RemoveError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.remove"))
            .boxed()
        }

        fn _removeRange_impl(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.removeRange";
            }
            let args = self::Args_StorageService_removeRange {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeRange", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.removeRange"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::RemoveRangeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::RemoveRangeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.removeRange"))
            .boxed()
        }

        fn _getUUID_impl(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getUUID";
            }
            let args = self::Args_StorageService_getUUID {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getUUID", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.getUUID"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::GetUUIDExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::GetUUIDError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.getUUID"))
            .boxed()
        }

        fn _lookUpIndex_impl(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.lookUpIndex";
            }
            let args = self::Args_StorageService_lookUpIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("lookUpIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageService.lookUpIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_service::LookUpIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_service::LookUpIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageService.lookUpIndex"))
            .boxed()
        }
    }

    pub trait StorageService: ::std::marker::Send {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>>;

        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>>;

        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>>;

        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>>;

        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>>;

        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>>;

        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>>;

        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>>;

        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>>;

        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>>;

        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>>;

        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>>;

        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>>;

        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>>;

        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>>;

        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>>;

        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>>;

        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>>;

        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>>;

        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>>;

        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>>;

        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>>;

        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>>;

        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>>;

        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>>;

        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>>;

        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>>;

        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>>;

        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>>;

        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>>;

        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>>;
    }

    pub trait StorageServiceExt<T>: StorageService
    where
        T: ::fbthrift::Transport,
    {
        fn getBound_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>>;
        fn boundStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>>;
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::VertexPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>>;
        fn getEdgeProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::EdgePropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>>;
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>>;
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>>;
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>>;
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>>;
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>>;
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>>;
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>>;
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>>;
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>>;
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>>;
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>>;
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>>;
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>>;
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>>;
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>>;
        fn getLeaderPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>>;
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>>;
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>>;
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>>;
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>>;
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>>;
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::PutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>>;
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>>;
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>>;
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>>;
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>>;
        fn lookUpIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>>;
    }

    struct Args_StorageService_getBound<'a> {
        req: &'a crate::types::GetNeighborsRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_getBound<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.getBound"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_boundStats<'a> {
        req: &'a crate::types::GetNeighborsRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_boundStats<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.boundStats"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_getProps<'a> {
        req: &'a crate::types::VertexPropRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_getProps<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.getProps"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_getEdgeProps<'a> {
        req: &'a crate::types::EdgePropRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_getEdgeProps<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.getEdgeProps"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_addVertices<'a> {
        req: &'a crate::types::AddVerticesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_addVertices<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.addVertices"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_addEdges<'a> {
        req: &'a crate::types::AddEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_addEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.addEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_deleteEdges<'a> {
        req: &'a crate::types::DeleteEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_deleteEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.deleteEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_deleteVertices<'a> {
        req: &'a crate::types::DeleteVerticesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_deleteVertices<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.deleteVertices"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_updateVertex<'a> {
        req: &'a crate::types::UpdateVertexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_updateVertex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.updateVertex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_updateEdge<'a> {
        req: &'a crate::types::UpdateEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_updateEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.updateEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_scanEdge<'a> {
        req: &'a crate::types::ScanEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_scanEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.scanEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_scanVertex<'a> {
        req: &'a crate::types::ScanVertexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_scanVertex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.scanVertex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_transLeader<'a> {
        req: &'a crate::types::TransLeaderReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_transLeader<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.transLeader"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_addPart<'a> {
        req: &'a crate::types::AddPartReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_addPart<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.addPart"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_addLearner<'a> {
        req: &'a crate::types::AddLearnerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_addLearner<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.addLearner"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_waitingForCatchUpData<'a> {
        req: &'a crate::types::CatchUpDataReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_waitingForCatchUpData<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.waitingForCatchUpData"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_removePart<'a> {
        req: &'a crate::types::RemovePartReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_removePart<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.removePart"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_memberChange<'a> {
        req: &'a crate::types::MemberChangeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_memberChange<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.memberChange"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_checkPeers<'a> {
        req: &'a crate::types::CheckPeersReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_checkPeers<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.checkPeers"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_getLeaderPart<'a> {
        req: &'a crate::types::GetLeaderReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_getLeaderPart<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.getLeaderPart"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_createCheckpoint<'a> {
        req: &'a crate::types::CreateCPRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_createCheckpoint<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.createCheckpoint"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_dropCheckpoint<'a> {
        req: &'a crate::types::DropCPRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_dropCheckpoint<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.dropCheckpoint"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_blockingWrites<'a> {
        req: &'a crate::types::BlockingSignRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_blockingWrites<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.blockingWrites"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_rebuildTagIndex<'a> {
        req: &'a crate::types::RebuildIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_rebuildTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.rebuildTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_rebuildEdgeIndex<'a> {
        req: &'a crate::types::RebuildIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_rebuildEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.rebuildEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_put<'a> {
        req: &'a crate::types::PutRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_put<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.put"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_get<'a> {
        req: &'a crate::types::GetRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_get<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.get"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_remove<'a> {
        req: &'a crate::types::RemoveRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_remove<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.remove"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_removeRange<'a> {
        req: &'a crate::types::RemoveRangeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_removeRange<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.removeRange"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_getUUID<'a> {
        req: &'a crate::types::GetUUIDReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_getUUID<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.getUUID"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageService_lookUpIndex<'a> {
        req: &'a crate::types::LookUpIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageService_lookUpIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageService.lookUpIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> StorageService for StorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            let rpc_options = T::RpcOptions::default();
            self._getBound_impl(
                arg_req,
                rpc_options,
            )
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            let rpc_options = T::RpcOptions::default();
            self._boundStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdgeProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            let rpc_options = T::RpcOptions::default();
            self._addVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._addEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._deleteEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            let rpc_options = T::RpcOptions::default();
            self._deleteVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._scanEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            let rpc_options = T::RpcOptions::default();
            self._scanVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            let rpc_options = T::RpcOptions::default();
            self._transLeader_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            let rpc_options = T::RpcOptions::default();
            self._addPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            let rpc_options = T::RpcOptions::default();
            self._addLearner_impl(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            let rpc_options = T::RpcOptions::default();
            self._waitingForCatchUpData_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            let rpc_options = T::RpcOptions::default();
            self._removePart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            let rpc_options = T::RpcOptions::default();
            self._memberChange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            let rpc_options = T::RpcOptions::default();
            self._checkPeers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            let rpc_options = T::RpcOptions::default();
            self._getLeaderPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            let rpc_options = T::RpcOptions::default();
            self._createCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            let rpc_options = T::RpcOptions::default();
            self._blockingWrites_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            let rpc_options = T::RpcOptions::default();
            self._put_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            let rpc_options = T::RpcOptions::default();
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            let rpc_options = T::RpcOptions::default();
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            let rpc_options = T::RpcOptions::default();
            self._getUUID_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._lookUpIndex_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> StorageServiceExt<T> for StorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn getBound_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            self._getBound_impl(
                arg_req,
                rpc_options,
            )
        }
        fn boundStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            self._boundStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::VertexPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            self._getProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::EdgePropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            self._getEdgeProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            self._addVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            self._addEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            self._deleteEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            self._deleteVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            self._updateVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            self._updateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            self._scanEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            self._scanVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            self._transLeader_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            self._addPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            self._addLearner_impl(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            self._waitingForCatchUpData_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            self._removePart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            self._memberChange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            self._checkPeers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            self._getLeaderPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            self._createCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            self._dropCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            self._blockingWrites_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::PutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            self._put_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            self._getUUID_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookUpIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            self._lookUpIndex_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> StorageService for S
    where
        S: ::std::convert::AsRef<dyn StorageService + 'a>,
        S: ::std::marker::Send,
    {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            self.as_ref().getBound(
                arg_req,
            )
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            self.as_ref().boundStats(
                arg_req,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            self.as_ref().getProps(
                arg_req,
            )
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            self.as_ref().getEdgeProps(
                arg_req,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            self.as_ref().addVertices(
                arg_req,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            self.as_ref().addEdges(
                arg_req,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            self.as_ref().deleteEdges(
                arg_req,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            self.as_ref().deleteVertices(
                arg_req,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            self.as_ref().updateVertex(
                arg_req,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            self.as_ref().updateEdge(
                arg_req,
            )
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            self.as_ref().scanEdge(
                arg_req,
            )
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            self.as_ref().scanVertex(
                arg_req,
            )
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            self.as_ref().transLeader(
                arg_req,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            self.as_ref().addPart(
                arg_req,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            self.as_ref().addLearner(
                arg_req,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            self.as_ref().waitingForCatchUpData(
                arg_req,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            self.as_ref().removePart(
                arg_req,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            self.as_ref().memberChange(
                arg_req,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            self.as_ref().checkPeers(
                arg_req,
            )
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            self.as_ref().getLeaderPart(
                arg_req,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            self.as_ref().createCheckpoint(
                arg_req,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            self.as_ref().dropCheckpoint(
                arg_req,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            self.as_ref().blockingWrites(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            self.as_ref().put(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            self.as_ref().getUUID(
                arg_req,
            )
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            self.as_ref().lookUpIndex(
                arg_req,
            )
        }
    }

    impl<'a, S, T> StorageServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn StorageService + 'a>,
        S: ::std::convert::AsRef<dyn StorageServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn getBound_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).getBound_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn boundStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).boundStats_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::VertexPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).getProps_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::EdgePropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).getEdgeProps_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).addVertices_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).addEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).deleteEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).deleteVertices_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).updateVertex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).updateEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).scanEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).scanVertex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).transLeader_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).addPart_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).addLearner_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).waitingForCatchUpData_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).removePart_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).memberChange_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).checkPeers_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).getLeaderPart_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).createCheckpoint_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).dropCheckpoint_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).blockingWrites_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).rebuildTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).rebuildEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::PutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).put_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).get_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).remove_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).removeRange_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).getUUID_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn lookUpIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            <Self as ::std::convert::AsRef<dyn StorageServiceExt<T>>>::as_ref(self).lookUpIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_StorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn StorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl StorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(StorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn StorageServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl StorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(StorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type StorageServiceDynClient = <make_StorageService as ::fbthrift::ClientFactory>::Api;
    pub type StorageServiceClient = ::std::sync::Arc<StorageServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_StorageService {
        type Api = dyn StorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn StorageService>::with_spawner(protocol, transport, spawner)
        }
    }

}

/// Server definitions for `storage`.
pub mod server {
    #[::async_trait::async_trait]
    pub trait StorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn getBound(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetBoundExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetBoundExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getBound",
                ),
            ))
        }
        async fn boundStats(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryStatsResponse, crate::services::storage_service::BoundStatsExn> {
            ::std::result::Result::Err(crate::services::storage_service::BoundStatsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "boundStats",
                ),
            ))
        }
        async fn getProps(
            &self,
            _req: crate::types::VertexPropRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetPropsExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetPropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getProps",
                ),
            ))
        }
        async fn getEdgeProps(
            &self,
            _req: crate::types::EdgePropRequest,
        ) -> ::std::result::Result<crate::types::EdgePropResponse, crate::services::storage_service::GetEdgePropsExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetEdgePropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getEdgeProps",
                ),
            ))
        }
        async fn addVertices(
            &self,
            _req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddVerticesExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addVertices",
                ),
            ))
        }
        async fn addEdges(
            &self,
            _req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddEdgesExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addEdges",
                ),
            ))
        }
        async fn deleteEdges(
            &self,
            _req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteEdgesExn> {
            ::std::result::Result::Err(crate::services::storage_service::DeleteEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "deleteEdges",
                ),
            ))
        }
        async fn deleteVertices(
            &self,
            _req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteVerticesExn> {
            ::std::result::Result::Err(crate::services::storage_service::DeleteVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "deleteVertices",
                ),
            ))
        }
        async fn updateVertex(
            &self,
            _req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateVertexExn> {
            ::std::result::Result::Err(crate::services::storage_service::UpdateVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "updateVertex",
                ),
            ))
        }
        async fn updateEdge(
            &self,
            _req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::storage_service::UpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "updateEdge",
                ),
            ))
        }
        async fn scanEdge(
            &self,
            _req: crate::types::ScanEdgeRequest,
        ) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::services::storage_service::ScanEdgeExn> {
            ::std::result::Result::Err(crate::services::storage_service::ScanEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "scanEdge",
                ),
            ))
        }
        async fn scanVertex(
            &self,
            _req: crate::types::ScanVertexRequest,
        ) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::services::storage_service::ScanVertexExn> {
            ::std::result::Result::Err(crate::services::storage_service::ScanVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "scanVertex",
                ),
            ))
        }
        async fn transLeader(
            &self,
            _req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::TransLeaderExn> {
            ::std::result::Result::Err(crate::services::storage_service::TransLeaderExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "transLeader",
                ),
            ))
        }
        async fn addPart(
            &self,
            _req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddPartExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addPart",
                ),
            ))
        }
        async fn addLearner(
            &self,
            _req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddLearnerExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddLearnerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addLearner",
                ),
            ))
        }
        async fn waitingForCatchUpData(
            &self,
            _req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::WaitingForCatchUpDataExn> {
            ::std::result::Result::Err(crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "waitingForCatchUpData",
                ),
            ))
        }
        async fn removePart(
            &self,
            _req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RemovePartExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemovePartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "removePart",
                ),
            ))
        }
        async fn memberChange(
            &self,
            _req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::MemberChangeExn> {
            ::std::result::Result::Err(crate::services::storage_service::MemberChangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "memberChange",
                ),
            ))
        }
        async fn checkPeers(
            &self,
            _req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CheckPeersExn> {
            ::std::result::Result::Err(crate::services::storage_service::CheckPeersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "checkPeers",
                ),
            ))
        }
        async fn getLeaderPart(
            &self,
            _req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderResp, crate::services::storage_service::GetLeaderPartExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetLeaderPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getLeaderPart",
                ),
            ))
        }
        async fn createCheckpoint(
            &self,
            _req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CreateCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_service::CreateCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "createCheckpoint",
                ),
            ))
        }
        async fn dropCheckpoint(
            &self,
            _req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::DropCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_service::DropCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "dropCheckpoint",
                ),
            ))
        }
        async fn blockingWrites(
            &self,
            _req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::BlockingWritesExn> {
            ::std::result::Result::Err(crate::services::storage_service::BlockingWritesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "blockingWrites",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn put(
            &self,
            _req: crate::types::PutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::PutExn> {
            ::std::result::Result::Err(crate::services::storage_service::PutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "put",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetRequest,
        ) -> ::std::result::Result<crate::types::GeneralResponse, crate::services::storage_service::GetExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "get",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "removeRange",
                ),
            ))
        }
        async fn getUUID(
            &self,
            _req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::storage_service::GetUUIDExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetUUIDExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getUUID",
                ),
            ))
        }
        async fn lookUpIndex(
            &self,
            _req: crate::types::LookUpIndexRequest,
        ) -> ::std::result::Result<crate::types::LookUpIndexResp, crate::services::storage_service::LookUpIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::LookUpIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "lookUpIndex",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> StorageService for ::std::boxed::Box<T>
    where
        T: StorageService + Send + Sync + ?Sized,
    {
        async fn getBound(
            &self,
            req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetBoundExn> {
            (**self).getBound(
                req,
            ).await
        }
        async fn boundStats(
            &self,
            req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryStatsResponse, crate::services::storage_service::BoundStatsExn> {
            (**self).boundStats(
                req,
            ).await
        }
        async fn getProps(
            &self,
            req: crate::types::VertexPropRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetPropsExn> {
            (**self).getProps(
                req,
            ).await
        }
        async fn getEdgeProps(
            &self,
            req: crate::types::EdgePropRequest,
        ) -> ::std::result::Result<crate::types::EdgePropResponse, crate::services::storage_service::GetEdgePropsExn> {
            (**self).getEdgeProps(
                req,
            ).await
        }
        async fn addVertices(
            &self,
            req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddVerticesExn> {
            (**self).addVertices(
                req,
            ).await
        }
        async fn addEdges(
            &self,
            req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddEdgesExn> {
            (**self).addEdges(
                req,
            ).await
        }
        async fn deleteEdges(
            &self,
            req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteEdgesExn> {
            (**self).deleteEdges(
                req,
            ).await
        }
        async fn deleteVertices(
            &self,
            req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteVerticesExn> {
            (**self).deleteVertices(
                req,
            ).await
        }
        async fn updateVertex(
            &self,
            req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateVertexExn> {
            (**self).updateVertex(
                req,
            ).await
        }
        async fn updateEdge(
            &self,
            req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateEdgeExn> {
            (**self).updateEdge(
                req,
            ).await
        }
        async fn scanEdge(
            &self,
            req: crate::types::ScanEdgeRequest,
        ) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::services::storage_service::ScanEdgeExn> {
            (**self).scanEdge(
                req,
            ).await
        }
        async fn scanVertex(
            &self,
            req: crate::types::ScanVertexRequest,
        ) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::services::storage_service::ScanVertexExn> {
            (**self).scanVertex(
                req,
            ).await
        }
        async fn transLeader(
            &self,
            req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::TransLeaderExn> {
            (**self).transLeader(
                req,
            ).await
        }
        async fn addPart(
            &self,
            req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddPartExn> {
            (**self).addPart(
                req,
            ).await
        }
        async fn addLearner(
            &self,
            req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddLearnerExn> {
            (**self).addLearner(
                req,
            ).await
        }
        async fn waitingForCatchUpData(
            &self,
            req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::WaitingForCatchUpDataExn> {
            (**self).waitingForCatchUpData(
                req,
            ).await
        }
        async fn removePart(
            &self,
            req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RemovePartExn> {
            (**self).removePart(
                req,
            ).await
        }
        async fn memberChange(
            &self,
            req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::MemberChangeExn> {
            (**self).memberChange(
                req,
            ).await
        }
        async fn checkPeers(
            &self,
            req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CheckPeersExn> {
            (**self).checkPeers(
                req,
            ).await
        }
        async fn getLeaderPart(
            &self,
            req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderResp, crate::services::storage_service::GetLeaderPartExn> {
            (**self).getLeaderPart(
                req,
            ).await
        }
        async fn createCheckpoint(
            &self,
            req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CreateCheckpointExn> {
            (**self).createCheckpoint(
                req,
            ).await
        }
        async fn dropCheckpoint(
            &self,
            req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::DropCheckpointExn> {
            (**self).dropCheckpoint(
                req,
            ).await
        }
        async fn blockingWrites(
            &self,
            req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::BlockingWritesExn> {
            (**self).blockingWrites(
                req,
            ).await
        }
        async fn rebuildTagIndex(
            &self,
            req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildTagIndexExn> {
            (**self).rebuildTagIndex(
                req,
            ).await
        }
        async fn rebuildEdgeIndex(
            &self,
            req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildEdgeIndexExn> {
            (**self).rebuildEdgeIndex(
                req,
            ).await
        }
        async fn put(
            &self,
            req: crate::types::PutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::PutExn> {
            (**self).put(
                req,
            ).await
        }
        async fn get(
            &self,
            req: crate::types::GetRequest,
        ) -> ::std::result::Result<crate::types::GeneralResponse, crate::services::storage_service::GetExn> {
            (**self).get(
                req,
            ).await
        }
        async fn remove(
            &self,
            req: crate::types::RemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveExn> {
            (**self).remove(
                req,
            ).await
        }
        async fn removeRange(
            &self,
            req: crate::types::RemoveRangeRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveRangeExn> {
            (**self).removeRange(
                req,
            ).await
        }
        async fn getUUID(
            &self,
            req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::storage_service::GetUUIDExn> {
            (**self).getUUID(
                req,
            ).await
        }
        async fn lookUpIndex(
            &self,
            req: crate::types::LookUpIndexRequest,
        ) -> ::std::result::Result<crate::types::LookUpIndexResp, crate::services::storage_service::LookUpIndexExn> {
            (**self).lookUpIndex(
                req,
            ).await
        }
    }

    /// Processor for StorageService's methods.
    #[derive(Clone, Debug)]
    pub struct StorageServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_StorageService_getBound {
        req: crate::types::GetNeighborsRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_getBound {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.getBound"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.getBound", "req"))?,
            })
        }
    }

    struct Args_StorageService_boundStats {
        req: crate::types::GetNeighborsRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_boundStats {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.boundStats"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.boundStats", "req"))?,
            })
        }
    }

    struct Args_StorageService_getProps {
        req: crate::types::VertexPropRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_getProps {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.getProps"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.getProps", "req"))?,
            })
        }
    }

    struct Args_StorageService_getEdgeProps {
        req: crate::types::EdgePropRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_getEdgeProps {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.getEdgeProps"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.getEdgeProps", "req"))?,
            })
        }
    }

    struct Args_StorageService_addVertices {
        req: crate::types::AddVerticesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_addVertices {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.addVertices"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.addVertices", "req"))?,
            })
        }
    }

    struct Args_StorageService_addEdges {
        req: crate::types::AddEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_addEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.addEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.addEdges", "req"))?,
            })
        }
    }

    struct Args_StorageService_deleteEdges {
        req: crate::types::DeleteEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_deleteEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.deleteEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.deleteEdges", "req"))?,
            })
        }
    }

    struct Args_StorageService_deleteVertices {
        req: crate::types::DeleteVerticesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_deleteVertices {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.deleteVertices"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.deleteVertices", "req"))?,
            })
        }
    }

    struct Args_StorageService_updateVertex {
        req: crate::types::UpdateVertexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_updateVertex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.updateVertex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.updateVertex", "req"))?,
            })
        }
    }

    struct Args_StorageService_updateEdge {
        req: crate::types::UpdateEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_updateEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.updateEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.updateEdge", "req"))?,
            })
        }
    }

    struct Args_StorageService_scanEdge {
        req: crate::types::ScanEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_scanEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.scanEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.scanEdge", "req"))?,
            })
        }
    }

    struct Args_StorageService_scanVertex {
        req: crate::types::ScanVertexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_scanVertex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.scanVertex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.scanVertex", "req"))?,
            })
        }
    }

    struct Args_StorageService_transLeader {
        req: crate::types::TransLeaderReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_transLeader {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.transLeader"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.transLeader", "req"))?,
            })
        }
    }

    struct Args_StorageService_addPart {
        req: crate::types::AddPartReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_addPart {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.addPart"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.addPart", "req"))?,
            })
        }
    }

    struct Args_StorageService_addLearner {
        req: crate::types::AddLearnerReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_addLearner {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.addLearner"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.addLearner", "req"))?,
            })
        }
    }

    struct Args_StorageService_waitingForCatchUpData {
        req: crate::types::CatchUpDataReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_waitingForCatchUpData {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.waitingForCatchUpData"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.waitingForCatchUpData", "req"))?,
            })
        }
    }

    struct Args_StorageService_removePart {
        req: crate::types::RemovePartReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_removePart {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.removePart"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.removePart", "req"))?,
            })
        }
    }

    struct Args_StorageService_memberChange {
        req: crate::types::MemberChangeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_memberChange {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.memberChange"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.memberChange", "req"))?,
            })
        }
    }

    struct Args_StorageService_checkPeers {
        req: crate::types::CheckPeersReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_checkPeers {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.checkPeers"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.checkPeers", "req"))?,
            })
        }
    }

    struct Args_StorageService_getLeaderPart {
        req: crate::types::GetLeaderReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_getLeaderPart {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.getLeaderPart"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.getLeaderPart", "req"))?,
            })
        }
    }

    struct Args_StorageService_createCheckpoint {
        req: crate::types::CreateCPRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_createCheckpoint {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.createCheckpoint"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.createCheckpoint", "req"))?,
            })
        }
    }

    struct Args_StorageService_dropCheckpoint {
        req: crate::types::DropCPRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_dropCheckpoint {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.dropCheckpoint"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.dropCheckpoint", "req"))?,
            })
        }
    }

    struct Args_StorageService_blockingWrites {
        req: crate::types::BlockingSignRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_blockingWrites {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.blockingWrites"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.blockingWrites", "req"))?,
            })
        }
    }

    struct Args_StorageService_rebuildTagIndex {
        req: crate::types::RebuildIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_rebuildTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.rebuildTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.rebuildTagIndex", "req"))?,
            })
        }
    }

    struct Args_StorageService_rebuildEdgeIndex {
        req: crate::types::RebuildIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_rebuildEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.rebuildEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.rebuildEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_StorageService_put {
        req: crate::types::PutRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_put {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.put"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.put", "req"))?,
            })
        }
    }

    struct Args_StorageService_get {
        req: crate::types::GetRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_get {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.get"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.get", "req"))?,
            })
        }
    }

    struct Args_StorageService_remove {
        req: crate::types::RemoveRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_remove {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.remove"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.remove", "req"))?,
            })
        }
    }

    struct Args_StorageService_removeRange {
        req: crate::types::RemoveRangeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_removeRange {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.removeRange"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.removeRange", "req"))?,
            })
        }
    }

    struct Args_StorageService_getUUID {
        req: crate::types::GetUUIDReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_getUUID {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.getUUID"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.getUUID", "req"))?,
            })
        }
    }

    struct Args_StorageService_lookUpIndex {
        req: crate::types::LookUpIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageService_lookUpIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageService.lookUpIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageService.lookUpIndex", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> StorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.getBound"))]
        async fn handle_getBound<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getBound";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_getBound = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getBound(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetBoundExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetBoundExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getBound",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.getBound", exn);
                    crate::services::storage_service::GetBoundExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getBound",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.boundStats"))]
        async fn handle_boundStats<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.boundStats";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_boundStats = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.boundStats(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::BoundStatsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::BoundStatsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "boundStats",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.boundStats", exn);
                    crate::services::storage_service::BoundStatsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "boundStats",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.getProps"))]
        async fn handle_getProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getProps";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_getProps = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getProps(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetPropsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetPropsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getProps",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.getProps", exn);
                    crate::services::storage_service::GetPropsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getProps",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.getEdgeProps"))]
        async fn handle_getEdgeProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getEdgeProps";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_getEdgeProps = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdgeProps(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetEdgePropsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetEdgePropsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeProps",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.getEdgeProps", exn);
                    crate::services::storage_service::GetEdgePropsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdgeProps",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.addVertices"))]
        async fn handle_addVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addVertices";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_addVertices = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addVertices(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::AddVerticesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::AddVerticesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addVertices",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.addVertices", exn);
                    crate::services::storage_service::AddVerticesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addVertices",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.addEdges"))]
        async fn handle_addEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_addEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::AddEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::AddEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.addEdges", exn);
                    crate::services::storage_service::AddEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.deleteEdges"))]
        async fn handle_deleteEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.deleteEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_deleteEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.deleteEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::DeleteEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::DeleteEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.deleteEdges", exn);
                    crate::services::storage_service::DeleteEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "deleteEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.deleteVertices"))]
        async fn handle_deleteVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.deleteVertices";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_deleteVertices = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.deleteVertices(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::DeleteVerticesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::DeleteVerticesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteVertices",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.deleteVertices", exn);
                    crate::services::storage_service::DeleteVerticesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "deleteVertices",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.updateVertex"))]
        async fn handle_updateVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.updateVertex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_updateVertex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateVertex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::UpdateVertexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::UpdateVertexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateVertex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.updateVertex", exn);
                    crate::services::storage_service::UpdateVertexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateVertex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.updateEdge"))]
        async fn handle_updateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.updateEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_updateEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::UpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::UpdateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.updateEdge", exn);
                    crate::services::storage_service::UpdateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.scanEdge"))]
        async fn handle_scanEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.scanEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_scanEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scanEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::ScanEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::ScanEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.scanEdge", exn);
                    crate::services::storage_service::ScanEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scanEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.scanVertex"))]
        async fn handle_scanVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.scanVertex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_scanVertex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scanVertex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::ScanVertexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::ScanVertexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanVertex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.scanVertex", exn);
                    crate::services::storage_service::ScanVertexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scanVertex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.transLeader"))]
        async fn handle_transLeader<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.transLeader";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_transLeader = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.transLeader(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::TransLeaderExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::TransLeaderExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "transLeader",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.transLeader", exn);
                    crate::services::storage_service::TransLeaderExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "transLeader",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.addPart"))]
        async fn handle_addPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addPart";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_addPart = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addPart(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::AddPartExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::AddPartExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addPart",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.addPart", exn);
                    crate::services::storage_service::AddPartExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addPart",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.addLearner"))]
        async fn handle_addLearner<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.addLearner";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_addLearner = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addLearner(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::AddLearnerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::AddLearnerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addLearner",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.addLearner", exn);
                    crate::services::storage_service::AddLearnerExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addLearner",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.waitingForCatchUpData"))]
        async fn handle_waitingForCatchUpData<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.waitingForCatchUpData";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_waitingForCatchUpData = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.waitingForCatchUpData(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::WaitingForCatchUpDataExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::WaitingForCatchUpDataExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "waitingForCatchUpData",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.waitingForCatchUpData", exn);
                    crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "waitingForCatchUpData",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.removePart"))]
        async fn handle_removePart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.removePart";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_removePart = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removePart(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::RemovePartExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::RemovePartExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removePart",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.removePart", exn);
                    crate::services::storage_service::RemovePartExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removePart",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.memberChange"))]
        async fn handle_memberChange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.memberChange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_memberChange = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.memberChange(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::MemberChangeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::MemberChangeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "memberChange",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.memberChange", exn);
                    crate::services::storage_service::MemberChangeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "memberChange",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.checkPeers"))]
        async fn handle_checkPeers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.checkPeers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_checkPeers = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.checkPeers(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::CheckPeersExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::CheckPeersExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkPeers",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.checkPeers", exn);
                    crate::services::storage_service::CheckPeersExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "checkPeers",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.getLeaderPart"))]
        async fn handle_getLeaderPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getLeaderPart";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_getLeaderPart = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getLeaderPart(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetLeaderPartExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetLeaderPartExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getLeaderPart",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.getLeaderPart", exn);
                    crate::services::storage_service::GetLeaderPartExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getLeaderPart",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.createCheckpoint"))]
        async fn handle_createCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.createCheckpoint";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_createCheckpoint = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createCheckpoint(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::CreateCheckpointExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::CreateCheckpointExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createCheckpoint",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.createCheckpoint", exn);
                    crate::services::storage_service::CreateCheckpointExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createCheckpoint",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.dropCheckpoint"))]
        async fn handle_dropCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.dropCheckpoint";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_dropCheckpoint = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropCheckpoint(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::DropCheckpointExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::DropCheckpointExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropCheckpoint",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.dropCheckpoint", exn);
                    crate::services::storage_service::DropCheckpointExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropCheckpoint",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.blockingWrites"))]
        async fn handle_blockingWrites<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.blockingWrites";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_blockingWrites = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.blockingWrites(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::BlockingWritesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::BlockingWritesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "blockingWrites",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.blockingWrites", exn);
                    crate::services::storage_service::BlockingWritesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "blockingWrites",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.rebuildTagIndex"))]
        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_rebuildTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::RebuildTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.rebuildTagIndex", exn);
                    crate::services::storage_service::RebuildTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.rebuildEdgeIndex"))]
        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_rebuildEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::RebuildEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.rebuildEdgeIndex", exn);
                    crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.put"))]
        async fn handle_put<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.put";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_put = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.put(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::PutExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::PutExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "put",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.put", exn);
                    crate::services::storage_service::PutExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "put",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.get"))]
        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_get = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.get(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.get", exn);
                    crate::services::storage_service::GetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "get",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.remove"))]
        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_remove = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.remove(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::RemoveExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.remove", exn);
                    crate::services::storage_service::RemoveExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "remove",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.removeRange"))]
        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.removeRange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_removeRange = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeRange(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::RemoveRangeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.removeRange", exn);
                    crate::services::storage_service::RemoveRangeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeRange",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.getUUID"))]
        async fn handle_getUUID<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.getUUID";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_getUUID = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getUUID(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::GetUUIDExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::GetUUIDExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUUID",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.getUUID", exn);
                    crate::services::storage_service::GetUUIDExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getUUID",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageService.lookUpIndex"))]
        async fn handle_lookUpIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageService";
                METHOD_NAME = "StorageService.lookUpIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageService_lookUpIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.lookUpIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_service::LookUpIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_service::LookUpIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookUpIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageService.lookUpIndex", exn);
                    crate::services::storage_service::LookUpIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "lookUpIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for StorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"getBound" => ::std::result::Result::Ok(0usize),
                b"boundStats" => ::std::result::Result::Ok(1usize),
                b"getProps" => ::std::result::Result::Ok(2usize),
                b"getEdgeProps" => ::std::result::Result::Ok(3usize),
                b"addVertices" => ::std::result::Result::Ok(4usize),
                b"addEdges" => ::std::result::Result::Ok(5usize),
                b"deleteEdges" => ::std::result::Result::Ok(6usize),
                b"deleteVertices" => ::std::result::Result::Ok(7usize),
                b"updateVertex" => ::std::result::Result::Ok(8usize),
                b"updateEdge" => ::std::result::Result::Ok(9usize),
                b"scanEdge" => ::std::result::Result::Ok(10usize),
                b"scanVertex" => ::std::result::Result::Ok(11usize),
                b"transLeader" => ::std::result::Result::Ok(12usize),
                b"addPart" => ::std::result::Result::Ok(13usize),
                b"addLearner" => ::std::result::Result::Ok(14usize),
                b"waitingForCatchUpData" => ::std::result::Result::Ok(15usize),
                b"removePart" => ::std::result::Result::Ok(16usize),
                b"memberChange" => ::std::result::Result::Ok(17usize),
                b"checkPeers" => ::std::result::Result::Ok(18usize),
                b"getLeaderPart" => ::std::result::Result::Ok(19usize),
                b"createCheckpoint" => ::std::result::Result::Ok(20usize),
                b"dropCheckpoint" => ::std::result::Result::Ok(21usize),
                b"blockingWrites" => ::std::result::Result::Ok(22usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(23usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(24usize),
                b"put" => ::std::result::Result::Ok(25usize),
                b"get" => ::std::result::Result::Ok(26usize),
                b"remove" => ::std::result::Result::Ok(27usize),
                b"removeRange" => ::std::result::Result::Ok(28usize),
                b"getUUID" => ::std::result::Result::Ok(29usize),
                b"lookUpIndex" => ::std::result::Result::Ok(30usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_getBound(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_boundStats(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_getProps(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_getEdgeProps(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_addVertices(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_addEdges(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_deleteEdges(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_deleteVertices(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_updateVertex(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_updateEdge(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_scanEdge(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_scanVertex(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_transLeader(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_addPart(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_addLearner(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_waitingForCatchUpData(_p, _r, _reply_state, _seqid).await
                }
                16usize => {
                    self.handle_removePart(_p, _r, _reply_state, _seqid).await
                }
                17usize => {
                    self.handle_memberChange(_p, _r, _reply_state, _seqid).await
                }
                18usize => {
                    self.handle_checkPeers(_p, _r, _reply_state, _seqid).await
                }
                19usize => {
                    self.handle_getLeaderPart(_p, _r, _reply_state, _seqid).await
                }
                20usize => {
                    self.handle_createCheckpoint(_p, _r, _reply_state, _seqid).await
                }
                21usize => {
                    self.handle_dropCheckpoint(_p, _r, _reply_state, _seqid).await
                }
                22usize => {
                    self.handle_blockingWrites(_p, _r, _reply_state, _seqid).await
                }
                23usize => {
                    self.handle_rebuildTagIndex(_p, _r, _reply_state, _seqid).await
                }
                24usize => {
                    self.handle_rebuildEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                25usize => {
                    self.handle_put(_p, _r, _reply_state, _seqid).await
                }
                26usize => {
                    self.handle_get(_p, _r, _reply_state, _seqid).await
                }
                27usize => {
                    self.handle_remove(_p, _r, _reply_state, _seqid).await
                }
                28usize => {
                    self.handle_removeRange(_p, _r, _reply_state, _seqid).await
                }
                29usize => {
                    self.handle_getUUID(_p, _r, _reply_state, _seqid).await
                }
                30usize => {
                    self.handle_lookUpIndex(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for StorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: StorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "StorageService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from StorageService
                "getBound",
                "boundStats",
                "getProps",
                "getEdgeProps",
                "addVertices",
                "addEdges",
                "deleteEdges",
                "deleteVertices",
                "updateVertex",
                "updateEdge",
                "scanEdge",
                "scanVertex",
                "transLeader",
                "addPart",
                "addLearner",
                "waitingForCatchUpData",
                "removePart",
                "memberChange",
                "checkPeers",
                "getLeaderPart",
                "createCheckpoint",
                "dropCheckpoint",
                "blockingWrites",
                "rebuildTagIndex",
                "rebuildEdgeIndex",
                "put",
                "get",
                "remove",
                "removeRange",
                "getUUID",
                "lookUpIndex",
            ]
        }
    }

    /// Construct a new instance of a StorageService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_StorageService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: StorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "StorageService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct StorageService<'mock> {
        pub getBound: r#impl::storage_service::getBound<'mock>,
        pub boundStats: r#impl::storage_service::boundStats<'mock>,
        pub getProps: r#impl::storage_service::getProps<'mock>,
        pub getEdgeProps: r#impl::storage_service::getEdgeProps<'mock>,
        pub addVertices: r#impl::storage_service::addVertices<'mock>,
        pub addEdges: r#impl::storage_service::addEdges<'mock>,
        pub deleteEdges: r#impl::storage_service::deleteEdges<'mock>,
        pub deleteVertices: r#impl::storage_service::deleteVertices<'mock>,
        pub updateVertex: r#impl::storage_service::updateVertex<'mock>,
        pub updateEdge: r#impl::storage_service::updateEdge<'mock>,
        pub scanEdge: r#impl::storage_service::scanEdge<'mock>,
        pub scanVertex: r#impl::storage_service::scanVertex<'mock>,
        pub transLeader: r#impl::storage_service::transLeader<'mock>,
        pub addPart: r#impl::storage_service::addPart<'mock>,
        pub addLearner: r#impl::storage_service::addLearner<'mock>,
        pub waitingForCatchUpData: r#impl::storage_service::waitingForCatchUpData<'mock>,
        pub removePart: r#impl::storage_service::removePart<'mock>,
        pub memberChange: r#impl::storage_service::memberChange<'mock>,
        pub checkPeers: r#impl::storage_service::checkPeers<'mock>,
        pub getLeaderPart: r#impl::storage_service::getLeaderPart<'mock>,
        pub createCheckpoint: r#impl::storage_service::createCheckpoint<'mock>,
        pub dropCheckpoint: r#impl::storage_service::dropCheckpoint<'mock>,
        pub blockingWrites: r#impl::storage_service::blockingWrites<'mock>,
        pub rebuildTagIndex: r#impl::storage_service::rebuildTagIndex<'mock>,
        pub rebuildEdgeIndex: r#impl::storage_service::rebuildEdgeIndex<'mock>,
        pub put: r#impl::storage_service::put<'mock>,
        pub get: r#impl::storage_service::get<'mock>,
        pub remove: r#impl::storage_service::remove<'mock>,
        pub removeRange: r#impl::storage_service::removeRange<'mock>,
        pub getUUID: r#impl::storage_service::getUUID<'mock>,
        pub lookUpIndex: r#impl::storage_service::lookUpIndex<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::StorageService {
        pub fn mock<'mock>() -> StorageService<'mock> {
            StorageService {
                getBound: r#impl::storage_service::getBound::unimplemented(),
                boundStats: r#impl::storage_service::boundStats::unimplemented(),
                getProps: r#impl::storage_service::getProps::unimplemented(),
                getEdgeProps: r#impl::storage_service::getEdgeProps::unimplemented(),
                addVertices: r#impl::storage_service::addVertices::unimplemented(),
                addEdges: r#impl::storage_service::addEdges::unimplemented(),
                deleteEdges: r#impl::storage_service::deleteEdges::unimplemented(),
                deleteVertices: r#impl::storage_service::deleteVertices::unimplemented(),
                updateVertex: r#impl::storage_service::updateVertex::unimplemented(),
                updateEdge: r#impl::storage_service::updateEdge::unimplemented(),
                scanEdge: r#impl::storage_service::scanEdge::unimplemented(),
                scanVertex: r#impl::storage_service::scanVertex::unimplemented(),
                transLeader: r#impl::storage_service::transLeader::unimplemented(),
                addPart: r#impl::storage_service::addPart::unimplemented(),
                addLearner: r#impl::storage_service::addLearner::unimplemented(),
                waitingForCatchUpData: r#impl::storage_service::waitingForCatchUpData::unimplemented(),
                removePart: r#impl::storage_service::removePart::unimplemented(),
                memberChange: r#impl::storage_service::memberChange::unimplemented(),
                checkPeers: r#impl::storage_service::checkPeers::unimplemented(),
                getLeaderPart: r#impl::storage_service::getLeaderPart::unimplemented(),
                createCheckpoint: r#impl::storage_service::createCheckpoint::unimplemented(),
                dropCheckpoint: r#impl::storage_service::dropCheckpoint::unimplemented(),
                blockingWrites: r#impl::storage_service::blockingWrites::unimplemented(),
                rebuildTagIndex: r#impl::storage_service::rebuildTagIndex::unimplemented(),
                rebuildEdgeIndex: r#impl::storage_service::rebuildEdgeIndex::unimplemented(),
                put: r#impl::storage_service::put::unimplemented(),
                get: r#impl::storage_service::get::unimplemented(),
                remove: r#impl::storage_service::remove::unimplemented(),
                removeRange: r#impl::storage_service::removeRange::unimplemented(),
                getUUID: r#impl::storage_service::getUUID::unimplemented(),
                lookUpIndex: r#impl::storage_service::lookUpIndex::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::StorageService for StorageService<'mock> {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> {
            let mut closure = self.getBound.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> {
            let mut closure = self.boundStats.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> {
            let mut closure = self.getProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::VertexPropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> {
            let mut closure = self.getEdgeProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::EdgePropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> {
            let mut closure = self.addVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> {
            let mut closure = self.addEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> {
            let mut closure = self.deleteEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> {
            let mut closure = self.deleteVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> {
            let mut closure = self.updateVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> {
            let mut closure = self.updateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> {
            let mut closure = self.scanEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> {
            let mut closure = self.scanVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> {
            let mut closure = self.transLeader.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> {
            let mut closure = self.addPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddPartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> {
            let mut closure = self.addLearner.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> {
            let mut closure = self.waitingForCatchUpData.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> {
            let mut closure = self.removePart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> {
            let mut closure = self.memberChange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> {
            let mut closure = self.checkPeers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> {
            let mut closure = self.getLeaderPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> {
            let mut closure = self.createCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> {
            let mut closure = self.dropCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> {
            let mut closure = self.blockingWrites.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> {
            let mut closure = self.put.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PutRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> {
            let mut closure = self.getUUID.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> {
            let mut closure = self.lookUpIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod storage_service {

            pub struct getBound<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::QueryResponse,
                        crate::errors::storage_service::GetBoundError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getBound<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getBound",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::QueryResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetBoundError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct boundStats<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::QueryStatsResponse,
                        crate::errors::storage_service::BoundStatsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> boundStats<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "boundStats",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryStatsResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::QueryStatsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::BoundStatsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::VertexPropRequest) -> ::std::result::Result<
                        crate::types::QueryResponse,
                        crate::errors::storage_service::GetPropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getProps<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::VertexPropRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryResponse) {
                    self.mock(move |_: crate::types::VertexPropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::VertexPropRequest) -> crate::types::QueryResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::VertexPropRequest) -> ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetPropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::VertexPropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::EdgePropRequest) -> ::std::result::Result<
                        crate::types::EdgePropResponse,
                        crate::errors::storage_service::GetEdgePropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdgeProps<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::EdgePropRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getEdgeProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::EdgePropResponse) {
                    self.mock(move |_: crate::types::EdgePropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::EdgePropRequest) -> crate::types::EdgePropResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::EdgePropRequest) -> ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetEdgePropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::EdgePropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::AddVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addVertices<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::AddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::DeleteEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> deleteEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "deleteEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DeleteEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::DeleteVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> deleteVertices<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "deleteVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DeleteVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::storage_service::UpdateVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateVertex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "updateVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::UpdateVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::storage_service::UpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "updateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::UpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> ::std::result::Result<
                        crate::types::ScanEdgeResponse,
                        crate::errors::storage_service::ScanEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scanEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "scanEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanEdgeResponse) {
                    self.mock(move |_: crate::types::ScanEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> crate::types::ScanEdgeResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::ScanEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> ::std::result::Result<
                        crate::types::ScanVertexResponse,
                        crate::errors::storage_service::ScanVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scanVertex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "scanVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanVertexResponse) {
                    self.mock(move |_: crate::types::ScanVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanVertexRequest) -> crate::types::ScanVertexResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanVertexRequest) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::ScanVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct transLeader<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::TransLeaderError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> transLeader<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::TransLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "transLeader",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::TransLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::TransLeaderError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::TransLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::AddPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addPart<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddPartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddPartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddPartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addLearner<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::AddLearnerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addLearner<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddLearnerReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addLearner",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddLearnerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddLearnerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddLearnerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct waitingForCatchUpData<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::WaitingForCatchUpDataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> waitingForCatchUpData<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CatchUpDataReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "waitingForCatchUpData",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CatchUpDataReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::WaitingForCatchUpDataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CatchUpDataReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removePart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RemovePartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removePart<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemovePartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "removePart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RemovePartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemovePartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemovePartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct memberChange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::MemberChangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> memberChange<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MemberChangeReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "memberChange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::MemberChangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::MemberChangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MemberChangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkPeers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::CheckPeersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> checkPeers<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CheckPeersReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "checkPeers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CheckPeersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::CheckPeersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CheckPeersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getLeaderPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<
                        crate::types::GetLeaderResp,
                        crate::errors::storage_service::GetLeaderPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getLeaderPart<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getLeaderPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetLeaderResp) {
                    self.mock(move |_: crate::types::GetLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> crate::types::GetLeaderResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetLeaderPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::CreateCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "createCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CreateCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::CreateCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::DropCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "dropCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::DropCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DropCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct blockingWrites<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::BlockingWritesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> blockingWrites<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BlockingSignRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "blockingWrites",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::BlockingSignRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::BlockingWritesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BlockingSignRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct put<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PutRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::PutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> put<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PutRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "put",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::PutRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PutRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PutRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::PutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PutRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetRequest) -> ::std::result::Result<
                        crate::types::GeneralResponse,
                        crate::errors::storage_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GeneralResponse) {
                    self.mock(move |_: crate::types::GetRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetRequest) -> crate::types::GeneralResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetRequest) -> ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::RemoveRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::RemoveRangeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUUID<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<
                        crate::types::GetUUIDResp,
                        crate::errors::storage_service::GetUUIDError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getUUID<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUUIDReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getUUID",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetUUIDResp) {
                    self.mock(move |_: crate::types::GetUUIDReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> crate::types::GetUUIDResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetUUIDError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUUIDReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookUpIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> ::std::result::Result<
                        crate::types::LookUpIndexResp,
                        crate::errors::storage_service::LookUpIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> lookUpIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookUpIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "lookUpIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::LookUpIndexResp) {
                    self.mock(move |_: crate::types::LookUpIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> crate::types::LookUpIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::LookUpIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookUpIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for StorageService functions.
    pub mod storage_service {

        pub type GetBoundError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetBoundExn> for
            ::std::result::Result<crate::types::QueryResponse, GetBoundError>
        {
            fn from(e: crate::services::storage_service::GetBoundExn) -> Self {
                match e {
                    crate::services::storage_service::GetBoundExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetBoundExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetBoundError::ApplicationException(aexn)),
                }
            }
        }

        pub type BoundStatsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::BoundStatsExn> for
            ::std::result::Result<crate::types::QueryStatsResponse, BoundStatsError>
        {
            fn from(e: crate::services::storage_service::BoundStatsExn) -> Self {
                match e {
                    crate::services::storage_service::BoundStatsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::BoundStatsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(BoundStatsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetPropsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetPropsExn> for
            ::std::result::Result<crate::types::QueryResponse, GetPropsError>
        {
            fn from(e: crate::services::storage_service::GetPropsExn) -> Self {
                match e {
                    crate::services::storage_service::GetPropsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetPropsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPropsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgePropsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetEdgePropsExn> for
            ::std::result::Result<crate::types::EdgePropResponse, GetEdgePropsError>
        {
            fn from(e: crate::services::storage_service::GetEdgePropsExn) -> Self {
                match e {
                    crate::services::storage_service::GetEdgePropsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetEdgePropsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgePropsError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddVerticesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::AddVerticesExn> for
            ::std::result::Result<crate::types::ExecResponse, AddVerticesError>
        {
            fn from(e: crate::services::storage_service::AddVerticesExn) -> Self {
                match e {
                    crate::services::storage_service::AddVerticesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::AddVerticesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddVerticesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::AddEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, AddEdgesError>
        {
            fn from(e: crate::services::storage_service::AddEdgesExn) -> Self {
                match e {
                    crate::services::storage_service::AddEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::AddEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type DeleteEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::DeleteEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, DeleteEdgesError>
        {
            fn from(e: crate::services::storage_service::DeleteEdgesExn) -> Self {
                match e {
                    crate::services::storage_service::DeleteEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::DeleteEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DeleteEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type DeleteVerticesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::DeleteVerticesExn> for
            ::std::result::Result<crate::types::ExecResponse, DeleteVerticesError>
        {
            fn from(e: crate::services::storage_service::DeleteVerticesExn) -> Self {
                match e {
                    crate::services::storage_service::DeleteVerticesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::DeleteVerticesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DeleteVerticesError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateVertexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::UpdateVertexExn> for
            ::std::result::Result<crate::types::UpdateResponse, UpdateVertexError>
        {
            fn from(e: crate::services::storage_service::UpdateVertexExn) -> Self {
                match e {
                    crate::services::storage_service::UpdateVertexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::UpdateVertexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateVertexError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::UpdateEdgeExn> for
            ::std::result::Result<crate::types::UpdateResponse, UpdateEdgeError>
        {
            fn from(e: crate::services::storage_service::UpdateEdgeExn) -> Self {
                match e {
                    crate::services::storage_service::UpdateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::UpdateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::ScanEdgeExn> for
            ::std::result::Result<crate::types::ScanEdgeResponse, ScanEdgeError>
        {
            fn from(e: crate::services::storage_service::ScanEdgeExn) -> Self {
                match e {
                    crate::services::storage_service::ScanEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::ScanEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanVertexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::ScanVertexExn> for
            ::std::result::Result<crate::types::ScanVertexResponse, ScanVertexError>
        {
            fn from(e: crate::services::storage_service::ScanVertexExn) -> Self {
                match e {
                    crate::services::storage_service::ScanVertexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::ScanVertexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanVertexError::ApplicationException(aexn)),
                }
            }
        }

        pub type TransLeaderError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::TransLeaderExn> for
            ::std::result::Result<crate::types::AdminExecResp, TransLeaderError>
        {
            fn from(e: crate::services::storage_service::TransLeaderExn) -> Self {
                match e {
                    crate::services::storage_service::TransLeaderExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::TransLeaderExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(TransLeaderError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddPartError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::AddPartExn> for
            ::std::result::Result<crate::types::AdminExecResp, AddPartError>
        {
            fn from(e: crate::services::storage_service::AddPartExn) -> Self {
                match e {
                    crate::services::storage_service::AddPartExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::AddPartExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddPartError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddLearnerError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::AddLearnerExn> for
            ::std::result::Result<crate::types::AdminExecResp, AddLearnerError>
        {
            fn from(e: crate::services::storage_service::AddLearnerExn) -> Self {
                match e {
                    crate::services::storage_service::AddLearnerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::AddLearnerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddLearnerError::ApplicationException(aexn)),
                }
            }
        }

        pub type WaitingForCatchUpDataError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::WaitingForCatchUpDataExn> for
            ::std::result::Result<crate::types::AdminExecResp, WaitingForCatchUpDataError>
        {
            fn from(e: crate::services::storage_service::WaitingForCatchUpDataExn) -> Self {
                match e {
                    crate::services::storage_service::WaitingForCatchUpDataExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(WaitingForCatchUpDataError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemovePartError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::RemovePartExn> for
            ::std::result::Result<crate::types::AdminExecResp, RemovePartError>
        {
            fn from(e: crate::services::storage_service::RemovePartExn) -> Self {
                match e {
                    crate::services::storage_service::RemovePartExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::RemovePartExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemovePartError::ApplicationException(aexn)),
                }
            }
        }

        pub type MemberChangeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::MemberChangeExn> for
            ::std::result::Result<crate::types::AdminExecResp, MemberChangeError>
        {
            fn from(e: crate::services::storage_service::MemberChangeExn) -> Self {
                match e {
                    crate::services::storage_service::MemberChangeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::MemberChangeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MemberChangeError::ApplicationException(aexn)),
                }
            }
        }

        pub type CheckPeersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::CheckPeersExn> for
            ::std::result::Result<crate::types::AdminExecResp, CheckPeersError>
        {
            fn from(e: crate::services::storage_service::CheckPeersExn) -> Self {
                match e {
                    crate::services::storage_service::CheckPeersExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::CheckPeersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CheckPeersError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetLeaderPartError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetLeaderPartExn> for
            ::std::result::Result<crate::types::GetLeaderResp, GetLeaderPartError>
        {
            fn from(e: crate::services::storage_service::GetLeaderPartExn) -> Self {
                match e {
                    crate::services::storage_service::GetLeaderPartExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetLeaderPartExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetLeaderPartError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateCheckpointError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::CreateCheckpointExn> for
            ::std::result::Result<crate::types::AdminExecResp, CreateCheckpointError>
        {
            fn from(e: crate::services::storage_service::CreateCheckpointExn) -> Self {
                match e {
                    crate::services::storage_service::CreateCheckpointExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::CreateCheckpointExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateCheckpointError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropCheckpointError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::DropCheckpointExn> for
            ::std::result::Result<crate::types::AdminExecResp, DropCheckpointError>
        {
            fn from(e: crate::services::storage_service::DropCheckpointExn) -> Self {
                match e {
                    crate::services::storage_service::DropCheckpointExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::DropCheckpointExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropCheckpointError::ApplicationException(aexn)),
                }
            }
        }

        pub type BlockingWritesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::BlockingWritesExn> for
            ::std::result::Result<crate::types::AdminExecResp, BlockingWritesError>
        {
            fn from(e: crate::services::storage_service::BlockingWritesExn) -> Self {
                match e {
                    crate::services::storage_service::BlockingWritesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::BlockingWritesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(BlockingWritesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::RebuildTagIndexExn> for
            ::std::result::Result<crate::types::AdminExecResp, RebuildTagIndexError>
        {
            fn from(e: crate::services::storage_service::RebuildTagIndexExn) -> Self {
                match e {
                    crate::services::storage_service::RebuildTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::RebuildTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::RebuildEdgeIndexExn> for
            ::std::result::Result<crate::types::AdminExecResp, RebuildEdgeIndexError>
        {
            fn from(e: crate::services::storage_service::RebuildEdgeIndexExn) -> Self {
                match e {
                    crate::services::storage_service::RebuildEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type PutError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::PutExn> for
            ::std::result::Result<crate::types::ExecResponse, PutError>
        {
            fn from(e: crate::services::storage_service::PutExn) -> Self {
                match e {
                    crate::services::storage_service::PutExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::PutExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(PutError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetExn> for
            ::std::result::Result<crate::types::GeneralResponse, GetError>
        {
            fn from(e: crate::services::storage_service::GetExn) -> Self {
                match e {
                    crate::services::storage_service::GetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::RemoveExn> for
            ::std::result::Result<crate::types::ExecResponse, RemoveError>
        {
            fn from(e: crate::services::storage_service::RemoveExn) -> Self {
                match e {
                    crate::services::storage_service::RemoveExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::RemoveExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::RemoveRangeExn> for
            ::std::result::Result<crate::types::ExecResponse, RemoveRangeError>
        {
            fn from(e: crate::services::storage_service::RemoveRangeExn) -> Self {
                match e {
                    crate::services::storage_service::RemoveRangeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::RemoveRangeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveRangeError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetUUIDError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::GetUUIDExn> for
            ::std::result::Result<crate::types::GetUUIDResp, GetUUIDError>
        {
            fn from(e: crate::services::storage_service::GetUUIDExn) -> Self {
                match e {
                    crate::services::storage_service::GetUUIDExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::GetUUIDExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetUUIDError::ApplicationException(aexn)),
                }
            }
        }

        pub type LookUpIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_service::LookUpIndexExn> for
            ::std::result::Result<crate::types::LookUpIndexResp, LookUpIndexError>
        {
            fn from(e: crate::services::storage_service::LookUpIndexExn) -> Self {
                match e {
                    crate::services::storage_service::LookUpIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_service::LookUpIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(LookUpIndexError::ApplicationException(aexn)),
                }
            }
        }

    }

}
