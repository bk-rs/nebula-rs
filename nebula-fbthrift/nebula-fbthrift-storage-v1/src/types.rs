// @generated by Thrift for src/interface/storage.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `storage`.

#![allow(clippy::redundant_closure)]


#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum EntryId {
    tag_id(common::types::TagID),
    edge_type(common::types::EdgeType),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq)]
pub struct PropDef {
    pub owner: crate::types::PropOwner,
    pub id: crate::types::EntryId,
    pub name: ::std::string::String,
    pub stat: crate::types::StatType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ResultCode {
    pub code: crate::types::ErrorCode,
    pub part_id: common::types::PartitionID,
    pub leader: ::std::option::Option<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EdgeKey {
    pub src: common::types::VertexID,
    pub edge_type: common::types::EdgeType,
    pub ranking: common::types::EdgeRanking,
    pub dst: common::types::VertexID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Edge {
    pub key: crate::types::EdgeKey,
    pub props: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IdAndProp {
    pub dst: common::types::VertexID,
    pub props: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgeData {
    pub r#type: common::types::EdgeType,
    pub edges: ::std::vec::Vec<crate::types::IdAndProp>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TagData {
    pub tag_id: common::types::TagID,
    pub data: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct VertexData {
    pub vertex_id: common::types::VertexID,
    pub tag_data: ::std::vec::Vec<crate::types::TagData>,
    pub edge_data: ::std::vec::Vec<crate::types::EdgeData>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VertexIndexData {
    pub vertex_id: common::types::VertexID,
    pub props: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ResponseCommon {
    pub failed_codes: ::std::vec::Vec<crate::types::ResultCode>,
    pub latency_in_us: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct QueryResponse {
    pub result: crate::types::ResponseCommon,
    pub vertex_schema: ::std::option::Option<::std::collections::BTreeMap<common::types::TagID, common::types::Schema>>,
    pub edge_schema: ::std::option::Option<::std::collections::BTreeMap<common::types::EdgeType, common::types::Schema>>,
    pub vertices: ::std::option::Option<::std::vec::Vec<crate::types::VertexData>>,
    pub total_edges: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecResponse {
    pub result: crate::types::ResponseCommon,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgePropResponse {
    pub result: crate::types::ResponseCommon,
    pub schema: ::std::option::Option<common::types::Schema>,
    pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct QueryStatsResponse {
    pub result: crate::types::ResponseCommon,
    pub schema: ::std::option::Option<common::types::Schema>,
    pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Tag {
    pub tag_id: common::types::TagID,
    pub props: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Vertex {
    pub id: common::types::VertexID,
    pub tags: ::std::vec::Vec<crate::types::Tag>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetNeighborsRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
    pub edge_types: ::std::vec::Vec<common::types::EdgeType>,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct VertexPropRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
    pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgePropRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    pub edge_type: common::types::EdgeType,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddVerticesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Vertex>>,
    pub overwritable: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Edge>>,
    pub overwritable: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DeleteVerticesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DeleteEdgesRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminExecResp {
    pub result: crate::types::ResponseCommon,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddPartReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub as_learner: ::std::primitive::bool,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemovePartReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MemberChangeReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub peer: common::types::HostAddr,
    pub add: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TransLeaderReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub new_leader: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddLearnerReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub learner: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CatchUpDataReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub target: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CheckPeersReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetLeaderReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetLeaderResp {
    pub result: crate::types::ResponseCommon,
    pub leader_parts: ::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateResponse {
    pub result: crate::types::ResponseCommon,
    pub schema: ::std::option::Option<common::types::Schema>,
    pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub upsert: ::std::option::Option<::std::primitive::bool>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UpdateItem {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub prop: ::std::vec::Vec<::std::primitive::u8>,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateVertexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub vertex_id: common::types::VertexID,
    pub part_id: common::types::PartitionID,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub update_items: ::std::vec::Vec<crate::types::UpdateItem>,
    pub return_columns: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub insertable: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateEdgeRequest {
    pub space_id: common::types::GraphSpaceID,
    pub edge_key: crate::types::EdgeKey,
    pub part_id: common::types::PartitionID,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub update_items: ::std::vec::Vec<crate::types::UpdateItem>,
    pub return_columns: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub insertable: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanEdgeRequest {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub cursor: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub return_columns: ::std::collections::BTreeMap<common::types::EdgeType, ::std::vec::Vec<crate::types::PropDef>>,
    pub all_columns: ::std::primitive::bool,
    pub limit: ::std::primitive::i32,
    pub start_time: ::std::primitive::i64,
    pub end_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanEdgeResponse {
    pub result: crate::types::ResponseCommon,
    pub edge_schema: ::std::collections::BTreeMap<common::types::EdgeType, common::types::Schema>,
    pub edge_data: ::std::vec::Vec<crate::types::ScanEdge>,
    pub has_next: ::std::primitive::bool,
    pub next_cursor: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScanEdge {
    pub src: common::types::VertexID,
    pub r#type: common::types::EdgeType,
    pub dst: common::types::VertexID,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanVertexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub cursor: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub return_columns: ::std::collections::BTreeMap<common::types::TagID, ::std::vec::Vec<crate::types::PropDef>>,
    pub all_columns: ::std::primitive::bool,
    pub limit: ::std::primitive::i32,
    pub start_time: ::std::primitive::i64,
    pub end_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScanVertex {
    pub vertexId: common::types::VertexID,
    pub tagId: common::types::TagID,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanVertexResponse {
    pub result: crate::types::ResponseCommon,
    pub vertex_schema: ::std::collections::BTreeMap<common::types::TagID, common::types::Schema>,
    pub vertex_data: ::std::vec::Vec<crate::types::ScanVertex>,
    pub has_next: ::std::primitive::bool,
    pub next_cursor: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PutRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Pair>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RemoveRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::string::String>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RemoveRangeRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Pair>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::string::String>>,
    pub return_partly: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PrefixRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, common::types::Pair>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GeneralResponse {
    pub result: crate::types::ResponseCommon,
    pub values: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetUUIDReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_id: common::types::PartitionID,
    pub name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetUUIDResp {
    pub result: crate::types::ResponseCommon,
    pub id: common::types::VertexID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BlockingSignRequest {
    pub space_id: common::types::GraphSpaceID,
    pub sign: crate::types::EngineSignType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateCPRequest {
    pub space_id: common::types::GraphSpaceID,
    pub name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropCPRequest {
    pub space_id: common::types::GraphSpaceID,
    pub name: ::std::string::String,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RebuildIndexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    pub index_id: common::types::IndexID,
    pub is_offline: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LookUpIndexRequest {
    pub space_id: common::types::GraphSpaceID,
    pub parts: ::std::vec::Vec<common::types::PartitionID>,
    pub index_id: common::types::IndexID,
    pub filter: ::std::vec::Vec<::std::primitive::u8>,
    pub return_columns: ::std::vec::Vec<::std::string::String>,
    pub is_edge: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LookUpIndexResp {
    pub result: crate::types::ResponseCommon,
    pub schema: ::std::option::Option<common::types::Schema>,
    pub vertices: ::std::option::Option<::std::vec::Vec<crate::types::VertexIndexData>>,
    pub edges: ::std::option::Option<::std::vec::Vec<crate::types::Edge>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ErrorCode(pub ::std::primitive::i32);

impl ErrorCode {
    pub const SUCCEEDED: Self = ErrorCode(0i32);
    pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
    pub const E_FAILED_TO_CONNECT: Self = ErrorCode(-2i32);
    pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
    pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
    pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-12i32);
    pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-13i32);
    pub const E_PART_NOT_FOUND: Self = ErrorCode(-14i32);
    pub const E_KEY_NOT_FOUND: Self = ErrorCode(-15i32);
    pub const E_CONSENSUS_ERROR: Self = ErrorCode(-16i32);
    pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-21i32);
    pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-22i32);
    pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-23i32);
    pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-24i32);
    pub const E_TAG_NOT_FOUND: Self = ErrorCode(-25i32);
    pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-26i32);
    pub const E_INVALID_FILTER: Self = ErrorCode(-31i32);
    pub const E_INVALID_UPDATER: Self = ErrorCode(-32i32);
    pub const E_INVALID_STORE: Self = ErrorCode(-33i32);
    pub const E_INVALID_PEER: Self = ErrorCode(-34i32);
    pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-35i32);
    pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-36i32);
    pub const E_LOAD_META_FAILED: Self = ErrorCode(-41i32);
    pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-50i32);
    pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-51i32);
    pub const E_FILTER_OUT: Self = ErrorCode(-60i32);
    pub const E_PARTIAL_RESULT: Self = ErrorCode(-99i32);
    pub const E_UNKNOWN: Self = ErrorCode(-100i32);
}

impl ::fbthrift::ThriftEnum for ErrorCode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::E_DISCONNECTED, "E_DISCONNECTED"),
            (Self::E_FAILED_TO_CONNECT, "E_FAILED_TO_CONNECT"),
            (Self::E_RPC_FAILURE, "E_RPC_FAILURE"),
            (Self::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
            (Self::E_KEY_HAS_EXISTS, "E_KEY_HAS_EXISTS"),
            (Self::E_SPACE_NOT_FOUND, "E_SPACE_NOT_FOUND"),
            (Self::E_PART_NOT_FOUND, "E_PART_NOT_FOUND"),
            (Self::E_KEY_NOT_FOUND, "E_KEY_NOT_FOUND"),
            (Self::E_CONSENSUS_ERROR, "E_CONSENSUS_ERROR"),
            (Self::E_EDGE_PROP_NOT_FOUND, "E_EDGE_PROP_NOT_FOUND"),
            (Self::E_TAG_PROP_NOT_FOUND, "E_TAG_PROP_NOT_FOUND"),
            (Self::E_IMPROPER_DATA_TYPE, "E_IMPROPER_DATA_TYPE"),
            (Self::E_EDGE_NOT_FOUND, "E_EDGE_NOT_FOUND"),
            (Self::E_TAG_NOT_FOUND, "E_TAG_NOT_FOUND"),
            (Self::E_INDEX_NOT_FOUND, "E_INDEX_NOT_FOUND"),
            (Self::E_INVALID_FILTER, "E_INVALID_FILTER"),
            (Self::E_INVALID_UPDATER, "E_INVALID_UPDATER"),
            (Self::E_INVALID_STORE, "E_INVALID_STORE"),
            (Self::E_INVALID_PEER, "E_INVALID_PEER"),
            (Self::E_RETRY_EXHAUSTED, "E_RETRY_EXHAUSTED"),
            (Self::E_TRANSFER_LEADER_FAILED, "E_TRANSFER_LEADER_FAILED"),
            (Self::E_LOAD_META_FAILED, "E_LOAD_META_FAILED"),
            (Self::E_FAILED_TO_CHECKPOINT, "E_FAILED_TO_CHECKPOINT"),
            (Self::E_CHECKPOINT_BLOCKED, "E_CHECKPOINT_BLOCKED"),
            (Self::E_FILTER_OUT, "E_FILTER_OUT"),
            (Self::E_PARTIAL_RESULT, "E_PARTIAL_RESULT"),
            (Self::E_UNKNOWN, "E_UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "E_DISCONNECTED",
            "E_FAILED_TO_CONNECT",
            "E_RPC_FAILURE",
            "E_LEADER_CHANGED",
            "E_KEY_HAS_EXISTS",
            "E_SPACE_NOT_FOUND",
            "E_PART_NOT_FOUND",
            "E_KEY_NOT_FOUND",
            "E_CONSENSUS_ERROR",
            "E_EDGE_PROP_NOT_FOUND",
            "E_TAG_PROP_NOT_FOUND",
            "E_IMPROPER_DATA_TYPE",
            "E_EDGE_NOT_FOUND",
            "E_TAG_NOT_FOUND",
            "E_INDEX_NOT_FOUND",
            "E_INVALID_FILTER",
            "E_INVALID_UPDATER",
            "E_INVALID_STORE",
            "E_INVALID_PEER",
            "E_RETRY_EXHAUSTED",
            "E_TRANSFER_LEADER_FAILED",
            "E_LOAD_META_FAILED",
            "E_FAILED_TO_CHECKPOINT",
            "E_CHECKPOINT_BLOCKED",
            "E_FILTER_OUT",
            "E_PARTIAL_RESULT",
            "E_UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::E_DISCONNECTED,
            Self::E_FAILED_TO_CONNECT,
            Self::E_RPC_FAILURE,
            Self::E_LEADER_CHANGED,
            Self::E_KEY_HAS_EXISTS,
            Self::E_SPACE_NOT_FOUND,
            Self::E_PART_NOT_FOUND,
            Self::E_KEY_NOT_FOUND,
            Self::E_CONSENSUS_ERROR,
            Self::E_EDGE_PROP_NOT_FOUND,
            Self::E_TAG_PROP_NOT_FOUND,
            Self::E_IMPROPER_DATA_TYPE,
            Self::E_EDGE_NOT_FOUND,
            Self::E_TAG_NOT_FOUND,
            Self::E_INDEX_NOT_FOUND,
            Self::E_INVALID_FILTER,
            Self::E_INVALID_UPDATER,
            Self::E_INVALID_STORE,
            Self::E_INVALID_PEER,
            Self::E_RETRY_EXHAUSTED,
            Self::E_TRANSFER_LEADER_FAILED,
            Self::E_LOAD_META_FAILED,
            Self::E_FAILED_TO_CHECKPOINT,
            Self::E_CHECKPOINT_BLOCKED,
            Self::E_FILTER_OUT,
            Self::E_PARTIAL_RESULT,
            Self::E_UNKNOWN,
        ]
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_UNKNOWN", -100),
            ("E_PARTIAL_RESULT", -99),
            ("E_FILTER_OUT", -60),
            ("E_CHECKPOINT_BLOCKED", -51),
            ("E_FAILED_TO_CHECKPOINT", -50),
            ("E_LOAD_META_FAILED", -41),
            ("E_TRANSFER_LEADER_FAILED", -36),
            ("E_RETRY_EXHAUSTED", -35),
            ("E_INVALID_PEER", -34),
            ("E_INVALID_STORE", -33),
            ("E_INVALID_UPDATER", -32),
            ("E_INVALID_FILTER", -31),
            ("E_INDEX_NOT_FOUND", -26),
            ("E_TAG_NOT_FOUND", -25),
            ("E_EDGE_NOT_FOUND", -24),
            ("E_IMPROPER_DATA_TYPE", -23),
            ("E_TAG_PROP_NOT_FOUND", -22),
            ("E_EDGE_PROP_NOT_FOUND", -21),
            ("E_CONSENSUS_ERROR", -16),
            ("E_KEY_NOT_FOUND", -15),
            ("E_PART_NOT_FOUND", -14),
            ("E_SPACE_NOT_FOUND", -13),
            ("E_KEY_HAS_EXISTS", -12),
            ("E_LEADER_CHANGED", -11),
            ("E_RPC_FAILURE", -3),
            ("E_FAILED_TO_CONNECT", -2),
            ("E_DISCONNECTED", -1),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ErrorCode::{}", self)
    }
}

impl ::std::str::FromStr for ErrorCode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_CHECKPOINT_BLOCKED", -51),
            ("E_CONSENSUS_ERROR", -16),
            ("E_DISCONNECTED", -1),
            ("E_EDGE_NOT_FOUND", -24),
            ("E_EDGE_PROP_NOT_FOUND", -21),
            ("E_FAILED_TO_CHECKPOINT", -50),
            ("E_FAILED_TO_CONNECT", -2),
            ("E_FILTER_OUT", -60),
            ("E_IMPROPER_DATA_TYPE", -23),
            ("E_INDEX_NOT_FOUND", -26),
            ("E_INVALID_FILTER", -31),
            ("E_INVALID_PEER", -34),
            ("E_INVALID_STORE", -33),
            ("E_INVALID_UPDATER", -32),
            ("E_KEY_HAS_EXISTS", -12),
            ("E_KEY_NOT_FOUND", -15),
            ("E_LEADER_CHANGED", -11),
            ("E_LOAD_META_FAILED", -41),
            ("E_PARTIAL_RESULT", -99),
            ("E_PART_NOT_FOUND", -14),
            ("E_RETRY_EXHAUSTED", -35),
            ("E_RPC_FAILURE", -3),
            ("E_SPACE_NOT_FOUND", -13),
            ("E_TAG_NOT_FOUND", -25),
            ("E_TAG_PROP_NOT_FOUND", -22),
            ("E_TRANSFER_LEADER_FAILED", -36),
            ("E_UNKNOWN", -100),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(Self)
    }
}

impl ::fbthrift::GetTType for ErrorCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PropOwner(pub ::std::primitive::i32);

impl PropOwner {
    pub const SOURCE: Self = PropOwner(1i32);
    pub const DEST: Self = PropOwner(2i32);
    pub const EDGE: Self = PropOwner(3i32);
}

impl ::fbthrift::ThriftEnum for PropOwner {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SOURCE, "SOURCE"),
            (Self::DEST, "DEST"),
            (Self::EDGE, "EDGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SOURCE",
            "DEST",
            "EDGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SOURCE,
            Self::DEST,
            Self::EDGE,
        ]
    }
}

impl ::std::default::Default for PropOwner {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a PropOwner> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a PropOwner) -> Self {
        x.0
    }
}

impl ::std::convert::From<PropOwner> for ::std::primitive::i32 {
    #[inline]
    fn from(x: PropOwner) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for PropOwner {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for PropOwner {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SOURCE", 1),
            ("DEST", 2),
            ("EDGE", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for PropOwner {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "PropOwner::{}", self)
    }
}

impl ::std::str::FromStr for PropOwner {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DEST", 2),
            ("EDGE", 3),
            ("SOURCE", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "PropOwner").map(Self)
    }
}

impl ::fbthrift::GetTType for PropOwner {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for PropOwner
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for PropOwner
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct EngineSignType(pub ::std::primitive::i32);

impl EngineSignType {
    pub const BLOCK_ON: Self = EngineSignType(1i32);
    pub const BLOCK_OFF: Self = EngineSignType(2i32);
}

impl ::fbthrift::ThriftEnum for EngineSignType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::BLOCK_ON, "BLOCK_ON"),
            (Self::BLOCK_OFF, "BLOCK_OFF"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "BLOCK_ON",
            "BLOCK_OFF",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::BLOCK_ON,
            Self::BLOCK_OFF,
        ]
    }
}

impl ::std::default::Default for EngineSignType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a EngineSignType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a EngineSignType) -> Self {
        x.0
    }
}

impl ::std::convert::From<EngineSignType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: EngineSignType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for EngineSignType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for EngineSignType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BLOCK_ON", 1),
            ("BLOCK_OFF", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for EngineSignType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "EngineSignType::{}", self)
    }
}

impl ::std::str::FromStr for EngineSignType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BLOCK_OFF", 2),
            ("BLOCK_ON", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "EngineSignType").map(Self)
    }
}

impl ::fbthrift::GetTType for EngineSignType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for EngineSignType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for EngineSignType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct StatType(pub ::std::primitive::i32);

impl StatType {
    pub const SUM: Self = StatType(1i32);
    pub const COUNT: Self = StatType(2i32);
    pub const AVG: Self = StatType(3i32);
}

impl ::fbthrift::ThriftEnum for StatType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUM, "SUM"),
            (Self::COUNT, "COUNT"),
            (Self::AVG, "AVG"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUM",
            "COUNT",
            "AVG",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUM,
            Self::COUNT,
            Self::AVG,
        ]
    }
}

impl ::std::default::Default for StatType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a StatType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a StatType) -> Self {
        x.0
    }
}

impl ::std::convert::From<StatType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: StatType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for StatType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for StatType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SUM", 1),
            ("COUNT", 2),
            ("AVG", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for StatType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "StatType::{}", self)
    }
}

impl ::std::str::FromStr for StatType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("AVG", 3),
            ("COUNT", 2),
            ("SUM", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "StatType").map(Self)
    }
}

impl ::fbthrift::GetTType for StatType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for StatType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for StatType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}


impl ::std::default::Default for EntryId {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for EntryId {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for EntryId
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EntryId");
        match self {
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for EntryId
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "EntryId",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PropDef {
    fn default() -> Self {
        Self {
            owner: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            stat: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PropDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PropDef")
            .field("owner", &self.owner)
            .field("id", &self.id)
            .field("name", &self.name)
            .field("stat", &self.stat)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PropDef {}
unsafe impl ::std::marker::Sync for self::PropDef {}

impl ::fbthrift::GetTType for self::PropDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PropDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PropDef");
        p.write_field_begin("owner", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.owner, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("stat", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.stat, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PropDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("owner", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("stat", ::fbthrift::TType::I32, 4),
        ];
        let mut field_owner = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_stat = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_owner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_stat = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            owner: field_owner.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            stat: field_stat.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ResultCode {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            leader: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ResultCode {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ResultCode")
            .field("code", &self.code)
            .field("part_id", &self.part_id)
            .field("leader", &self.leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ResultCode {}
unsafe impl ::std::marker::Sync for self::ResultCode {}

impl ::fbthrift::GetTType for self::ResultCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ResultCode
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ResultCode");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader {
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ResultCode
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            leader: field_leader,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeKey {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            edge_type: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            dst: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeKey {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeKey")
            .field("src", &self.src)
            .field("edge_type", &self.edge_type)
            .field("ranking", &self.ranking)
            .field("dst", &self.dst)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeKey {}
unsafe impl ::std::marker::Sync for self::EdgeKey {}

impl ::fbthrift::GetTType for self::EdgeKey {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeKey
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeKey");
        p.write_field_begin("src", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("dst", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeKey
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("src", ::fbthrift::TType::I64, 1),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_dst = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            edge_type: field_edge_type.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            dst: field_dst.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Edge {
    fn default() -> Self {
        Self {
            key: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Edge {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Edge")
            .field("key", &self.key)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Edge {}
unsafe impl ::std::marker::Sync for self::Edge {}

impl ::fbthrift::GetTType for self::Edge {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Edge");
        p.write_field_begin("key", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("props", ::fbthrift::TType::String, 2),
        ];
        let mut field_key = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            key: field_key.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IdAndProp {
    fn default() -> Self {
        Self {
            dst: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IdAndProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IdAndProp")
            .field("dst", &self.dst)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IdAndProp {}
unsafe impl ::std::marker::Sync for self::IdAndProp {}

impl ::fbthrift::GetTType for self::IdAndProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IdAndProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IdAndProp");
        p.write_field_begin("dst", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IdAndProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("props", ::fbthrift::TType::String, 2),
        ];
        let mut field_dst = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            dst: field_dst.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeData {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeData")
            .field("r#type", &self.r#type)
            .field("edges", &self.edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeData {}
unsafe impl ::std::marker::Sync for self::EdgeData {}

impl ::fbthrift::GetTType for self::EdgeData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeData");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TagData {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            data: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TagData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TagData")
            .field("tag_id", &self.tag_id)
            .field("data", &self.data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TagData {}
unsafe impl ::std::marker::Sync for self::TagData {}

impl ::fbthrift::GetTType for self::TagData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TagData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TagData");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("data", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.data, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TagData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            data: field_data.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VertexData {
    fn default() -> Self {
        Self {
            vertex_id: ::std::default::Default::default(),
            tag_data: ::std::default::Default::default(),
            edge_data: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VertexData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VertexData")
            .field("vertex_id", &self.vertex_id)
            .field("tag_data", &self.tag_data)
            .field("edge_data", &self.edge_data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VertexData {}
unsafe impl ::std::marker::Sync for self::VertexData {}

impl ::fbthrift::GetTType for self::VertexData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VertexData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VertexData");
        p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.vertex_id, p);
        p.write_field_end();
        p.write_field_begin("tag_data", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tag_data, p);
        p.write_field_end();
        p.write_field_begin("edge_data", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_data, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VertexData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_data", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("tag_data", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("vertex_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_vertex_id = ::std::option::Option::None;
        let mut field_tag_data = ::std::option::Option::None;
        let mut field_edge_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tag_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            vertex_id: field_vertex_id.unwrap_or_default(),
            tag_data: field_tag_data.unwrap_or_default(),
            edge_data: field_edge_data.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VertexIndexData {
    fn default() -> Self {
        Self {
            vertex_id: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VertexIndexData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VertexIndexData")
            .field("vertex_id", &self.vertex_id)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VertexIndexData {}
unsafe impl ::std::marker::Sync for self::VertexIndexData {}

impl ::fbthrift::GetTType for self::VertexIndexData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VertexIndexData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VertexIndexData");
        p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.vertex_id, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VertexIndexData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("vertex_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_vertex_id = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            vertex_id: field_vertex_id.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ResponseCommon {
    fn default() -> Self {
        Self {
            failed_codes: ::std::default::Default::default(),
            latency_in_us: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ResponseCommon {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ResponseCommon")
            .field("failed_codes", &self.failed_codes)
            .field("latency_in_us", &self.latency_in_us)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ResponseCommon {}
unsafe impl ::std::marker::Sync for self::ResponseCommon {}

impl ::fbthrift::GetTType for self::ResponseCommon {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ResponseCommon
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ResponseCommon");
        p.write_field_begin("failed_codes", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.failed_codes, p);
        p.write_field_end();
        p.write_field_begin("latency_in_us", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.latency_in_us, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ResponseCommon
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("failed_codes", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("latency_in_us", ::fbthrift::TType::I32, 2),
        ];
        let mut field_failed_codes = ::std::option::Option::None;
        let mut field_latency_in_us = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_failed_codes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_latency_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            failed_codes: field_failed_codes.unwrap_or_default(),
            latency_in_us: field_latency_in_us.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::QueryResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            vertex_schema: ::std::option::Option::None,
            edge_schema: ::std::option::Option::None,
            vertices: ::std::option::Option::None,
            total_edges: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::QueryResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("QueryResponse")
            .field("result", &self.result)
            .field("vertex_schema", &self.vertex_schema)
            .field("edge_schema", &self.edge_schema)
            .field("vertices", &self.vertices)
            .field("total_edges", &self.total_edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::QueryResponse {}
unsafe impl ::std::marker::Sync for self::QueryResponse {}

impl ::fbthrift::GetTType for self::QueryResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::QueryResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("QueryResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.vertex_schema {
            p.write_field_begin("vertex_schema", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.edge_schema {
            p.write_field_begin("edge_schema", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.vertices {
            p.write_field_begin("vertices", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.total_edges {
            p.write_field_begin("total_edges", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::QueryResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_schema", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("total_edges", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("vertex_schema", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("vertices", ::fbthrift::TType::List, 4),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_vertex_schema = ::std::option::Option::None;
        let mut field_edge_schema = ::std::option::Option::None;
        let mut field_vertices = ::std::option::Option::None;
        let mut field_total_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_vertex_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_edge_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_total_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            vertex_schema: field_vertex_schema,
            edge_schema: field_edge_schema,
            vertices: field_vertices,
            total_edges: field_total_edges,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecResponse")
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecResponse {}
unsafe impl ::std::marker::Sync for self::ExecResponse {}

impl ::fbthrift::GetTType for self::ExecResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgePropResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            schema: ::std::option::Option::None,
            data: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgePropResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgePropResponse")
            .field("result", &self.result)
            .field("schema", &self.schema)
            .field("data", &self.data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgePropResponse {}
unsafe impl ::std::marker::Sync for self::EdgePropResponse {}

impl ::fbthrift::GetTType for self::EdgePropResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgePropResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgePropResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.schema {
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.data {
            p.write_field_begin("data", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgePropResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            schema: field_schema,
            data: field_data,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::QueryStatsResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            schema: ::std::option::Option::None,
            data: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::QueryStatsResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("QueryStatsResponse")
            .field("result", &self.result)
            .field("schema", &self.schema)
            .field("data", &self.data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::QueryStatsResponse {}
unsafe impl ::std::marker::Sync for self::QueryStatsResponse {}

impl ::fbthrift::GetTType for self::QueryStatsResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::QueryStatsResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("QueryStatsResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.schema {
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.data {
            p.write_field_begin("data", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::QueryStatsResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            schema: field_schema,
            data: field_data,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Tag {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Tag {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Tag")
            .field("tag_id", &self.tag_id)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Tag {}
unsafe impl ::std::marker::Sync for self::Tag {}

impl ::fbthrift::GetTType for self::Tag {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Tag");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("props", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Vertex {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Vertex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Vertex")
            .field("id", &self.id)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Vertex {}
unsafe impl ::std::marker::Sync for self::Vertex {}

impl ::fbthrift::GetTType for self::Vertex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Vertex");
        p.write_field_begin("id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetNeighborsRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            edge_types: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetNeighborsRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetNeighborsRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("edge_types", &self.edge_types)
            .field("filter", &self.filter)
            .field("return_columns", &self.return_columns)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetNeighborsRequest {}
unsafe impl ::std::marker::Sync for self::GetNeighborsRequest {}

impl ::fbthrift::GetTType for self::GetNeighborsRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetNeighborsRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("edge_types", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_types, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_types", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_edge_types = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_types = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            edge_types: field_edge_types.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VertexPropRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VertexPropRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VertexPropRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("return_columns", &self.return_columns)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VertexPropRequest {}
unsafe impl ::std::marker::Sync for self::VertexPropRequest {}

impl ::fbthrift::GetTType for self::VertexPropRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VertexPropRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VertexPropRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VertexPropRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgePropRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            edge_type: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgePropRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgePropRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("edge_type", &self.edge_type)
            .field("filter", &self.filter)
            .field("return_columns", &self.return_columns)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgePropRequest {}
unsafe impl ::std::marker::Sync for self::EdgePropRequest {}

impl ::fbthrift::GetTType for self::EdgePropRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgePropRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgePropRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgePropRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            edge_type: field_edge_type.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddVerticesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            overwritable: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddVerticesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddVerticesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("overwritable", &self.overwritable)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddVerticesRequest {}
unsafe impl ::std::marker::Sync for self::AddVerticesRequest {}

impl ::fbthrift::GetTType for self::AddVerticesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddVerticesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddVerticesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.overwritable, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddVerticesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("overwritable", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_overwritable = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            overwritable: field_overwritable.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            overwritable: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("overwritable", &self.overwritable)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddEdgesRequest {}
unsafe impl ::std::marker::Sync for self::AddEdgesRequest {}

impl ::fbthrift::GetTType for self::AddEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.overwritable, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("overwritable", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_overwritable = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            overwritable: field_overwritable.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DeleteVerticesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DeleteVerticesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DeleteVerticesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DeleteVerticesRequest {}
unsafe impl ::std::marker::Sync for self::DeleteVerticesRequest {}

impl ::fbthrift::GetTType for self::DeleteVerticesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DeleteVerticesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DeleteVerticesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DeleteVerticesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DeleteEdgesRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DeleteEdgesRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DeleteEdgesRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DeleteEdgesRequest {}
unsafe impl ::std::marker::Sync for self::DeleteEdgesRequest {}

impl ::fbthrift::GetTType for self::DeleteEdgesRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DeleteEdgesRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DeleteEdgesRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DeleteEdgesRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminExecResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminExecResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminExecResp")
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminExecResp {}
unsafe impl ::std::marker::Sync for self::AdminExecResp {}

impl ::fbthrift::GetTType for self::AdminExecResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminExecResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminExecResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminExecResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddPartReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            as_learner: ::std::default::Default::default(),
            peers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddPartReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddPartReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("as_learner", &self.as_learner)
            .field("peers", &self.peers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddPartReq {}
unsafe impl ::std::marker::Sync for self::AddPartReq {}

impl ::fbthrift::GetTType for self::AddPartReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddPartReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddPartReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("as_learner", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.as_learner, p);
        p.write_field_end();
        p.write_field_begin("peers", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddPartReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("as_learner", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_as_learner = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_as_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            as_learner: field_as_learner.unwrap_or_default(),
            peers: field_peers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemovePartReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemovePartReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemovePartReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemovePartReq {}
unsafe impl ::std::marker::Sync for self::RemovePartReq {}

impl ::fbthrift::GetTType for self::RemovePartReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemovePartReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemovePartReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemovePartReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MemberChangeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            peer: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MemberChangeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MemberChangeReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("peer", &self.peer)
            .field("add", &self.add)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MemberChangeReq {}
unsafe impl ::std::marker::Sync for self::MemberChangeReq {}

impl ::fbthrift::GetTType for self::MemberChangeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MemberChangeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MemberChangeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("peer", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.peer, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MemberChangeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peer", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_peer = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_peer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            peer: field_peer.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TransLeaderReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            new_leader: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TransLeaderReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TransLeaderReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("new_leader", &self.new_leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TransLeaderReq {}
unsafe impl ::std::marker::Sync for self::TransLeaderReq {}

impl ::fbthrift::GetTType for self::TransLeaderReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TransLeaderReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TransLeaderReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("new_leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.new_leader, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TransLeaderReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("new_leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_new_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_new_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            new_leader: field_new_leader.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddLearnerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            learner: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddLearnerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddLearnerReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("learner", &self.learner)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddLearnerReq {}
unsafe impl ::std::marker::Sync for self::AddLearnerReq {}

impl ::fbthrift::GetTType for self::AddLearnerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddLearnerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddLearnerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("learner", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.learner, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddLearnerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("learner", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_learner = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            learner: field_learner.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CatchUpDataReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            target: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CatchUpDataReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CatchUpDataReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("target", &self.target)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CatchUpDataReq {}
unsafe impl ::std::marker::Sync for self::CatchUpDataReq {}

impl ::fbthrift::GetTType for self::CatchUpDataReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CatchUpDataReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CatchUpDataReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("target", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.target, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CatchUpDataReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("target", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_target = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_target = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            target: field_target.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CheckPeersReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            peers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CheckPeersReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CheckPeersReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("peers", &self.peers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CheckPeersReq {}
unsafe impl ::std::marker::Sync for self::CheckPeersReq {}

impl ::fbthrift::GetTType for self::CheckPeersReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CheckPeersReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CheckPeersReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("peers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CheckPeersReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            peers: field_peers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetLeaderReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetLeaderReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetLeaderReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetLeaderReq {}
unsafe impl ::std::marker::Sync for self::GetLeaderReq {}

impl ::fbthrift::GetTType for self::GetLeaderReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetLeaderReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetLeaderReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetLeaderResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            leader_parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetLeaderResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetLeaderResp")
            .field("result", &self.result)
            .field("leader_parts", &self.leader_parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetLeaderResp {}
unsafe impl ::std::marker::Sync for self::GetLeaderResp {}

impl ::fbthrift::GetTType for self::GetLeaderResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetLeaderResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetLeaderResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.leader_parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_leader_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            leader_parts: field_leader_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            schema: ::std::option::Option::None,
            data: ::std::option::Option::None,
            upsert: ::std::option::Option::Some(false),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateResponse")
            .field("result", &self.result)
            .field("schema", &self.schema)
            .field("data", &self.data)
            .field("upsert", &self.upsert)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateResponse {}
unsafe impl ::std::marker::Sync for self::UpdateResponse {}

impl ::fbthrift::GetTType for self::UpdateResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.schema {
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.data {
            p.write_field_begin("data", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.upsert {
            p.write_field_begin("upsert", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("upsert", ::fbthrift::TType::Bool, 4),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let mut field_upsert = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_upsert = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            schema: field_schema,
            data: field_data,
            upsert: field_upsert,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateItem {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            prop: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateItem")
            .field("name", &self.name)
            .field("prop", &self.prop)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateItem {}
unsafe impl ::std::marker::Sync for self::UpdateItem {}

impl ::fbthrift::GetTType for self::UpdateItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateItem");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("prop", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.prop, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("prop", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_prop = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            prop: field_prop.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateVertexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            vertex_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            update_items: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            insertable: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateVertexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateVertexRequest")
            .field("space_id", &self.space_id)
            .field("vertex_id", &self.vertex_id)
            .field("part_id", &self.part_id)
            .field("filter", &self.filter)
            .field("update_items", &self.update_items)
            .field("return_columns", &self.return_columns)
            .field("insertable", &self.insertable)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateVertexRequest {}
unsafe impl ::std::marker::Sync for self::UpdateVertexRequest {}

impl ::fbthrift::GetTType for self::UpdateVertexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateVertexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateVertexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.vertex_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("update_items", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.update_items, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 6);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("insertable", ::fbthrift::TType::Bool, 7);
        ::fbthrift::Serialize::write(&self.insertable, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateVertexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("insertable", ::fbthrift::TType::Bool, 7),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("update_items", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("vertex_id", ::fbthrift::TType::I64, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_vertex_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_update_items = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_insertable = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_update_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 7) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            vertex_id: field_vertex_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            update_items: field_update_items.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            insertable: field_insertable.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateEdgeRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_key: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            update_items: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            insertable: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateEdgeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateEdgeRequest")
            .field("space_id", &self.space_id)
            .field("edge_key", &self.edge_key)
            .field("part_id", &self.part_id)
            .field("filter", &self.filter)
            .field("update_items", &self.update_items)
            .field("return_columns", &self.return_columns)
            .field("insertable", &self.insertable)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateEdgeRequest {}
unsafe impl ::std::marker::Sync for self::UpdateEdgeRequest {}

impl ::fbthrift::GetTType for self::UpdateEdgeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateEdgeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateEdgeRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_key", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.edge_key, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("update_items", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.update_items, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 6);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("insertable", ::fbthrift::TType::Bool, 7);
        ::fbthrift::Serialize::write(&self.insertable, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateEdgeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_key", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("insertable", ::fbthrift::TType::Bool, 7),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("update_items", ::fbthrift::TType::List, 5),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_key = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_update_items = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_insertable = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_edge_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_update_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 7) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_key: field_edge_key.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            update_items: field_update_items.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            insertable: field_insertable.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanEdgeRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            cursor: ::std::option::Option::None,
            return_columns: ::std::default::Default::default(),
            all_columns: ::std::default::Default::default(),
            limit: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            end_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanEdgeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanEdgeRequest")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("cursor", &self.cursor)
            .field("return_columns", &self.return_columns)
            .field("all_columns", &self.all_columns)
            .field("limit", &self.limit)
            .field("start_time", &self.start_time)
            .field("end_time", &self.end_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanEdgeRequest {}
unsafe impl ::std::marker::Sync for self::ScanEdgeRequest {}

impl ::fbthrift::GetTType for self::ScanEdgeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanEdgeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanEdgeRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.cursor {
            p.write_field_begin("cursor", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("return_columns", ::fbthrift::TType::Map, 4);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("all_columns", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.all_columns, p);
        p.write_field_end();
        p.write_field_begin("limit", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.limit, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("end_time", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.end_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanEdgeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_columns", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("cursor", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("end_time", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I32, 6),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 7),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_cursor = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_all_columns = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_end_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_all_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            cursor: field_cursor,
            return_columns: field_return_columns.unwrap_or_default(),
            all_columns: field_all_columns.unwrap_or_default(),
            limit: field_limit.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            end_time: field_end_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanEdgeResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            edge_schema: ::std::default::Default::default(),
            edge_data: ::std::default::Default::default(),
            has_next: ::std::default::Default::default(),
            next_cursor: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanEdgeResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanEdgeResponse")
            .field("result", &self.result)
            .field("edge_schema", &self.edge_schema)
            .field("edge_data", &self.edge_data)
            .field("has_next", &self.has_next)
            .field("next_cursor", &self.next_cursor)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanEdgeResponse {}
unsafe impl ::std::marker::Sync for self::ScanEdgeResponse {}

impl ::fbthrift::GetTType for self::ScanEdgeResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanEdgeResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanEdgeResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("edge_schema", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.edge_schema, p);
        p.write_field_end();
        p.write_field_begin("edge_data", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_data, p);
        p.write_field_end();
        p.write_field_begin("has_next", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.has_next, p);
        p.write_field_end();
        p.write_field_begin("next_cursor", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.next_cursor, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanEdgeResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_data", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("edge_schema", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("has_next", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("next_cursor", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_edge_schema = ::std::option::Option::None;
        let mut field_edge_data = ::std::option::Option::None;
        let mut field_has_next = ::std::option::Option::None;
        let mut field_next_cursor = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_edge_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_has_next = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_next_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            edge_schema: field_edge_schema.unwrap_or_default(),
            edge_data: field_edge_data.unwrap_or_default(),
            has_next: field_has_next.unwrap_or_default(),
            next_cursor: field_next_cursor.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanEdge {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            dst: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanEdge {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanEdge")
            .field("src", &self.src)
            .field("r#type", &self.r#type)
            .field("dst", &self.dst)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanEdge {}
unsafe impl ::std::marker::Sync for self::ScanEdge {}

impl ::fbthrift::GetTType for self::ScanEdge {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanEdge
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanEdge");
        p.write_field_begin("src", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("dst", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanEdge
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("src", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 4),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_dst = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            dst: field_dst.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanVertexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            cursor: ::std::option::Option::None,
            return_columns: ::std::default::Default::default(),
            all_columns: ::std::default::Default::default(),
            limit: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            end_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanVertexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanVertexRequest")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("cursor", &self.cursor)
            .field("return_columns", &self.return_columns)
            .field("all_columns", &self.all_columns)
            .field("limit", &self.limit)
            .field("start_time", &self.start_time)
            .field("end_time", &self.end_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanVertexRequest {}
unsafe impl ::std::marker::Sync for self::ScanVertexRequest {}

impl ::fbthrift::GetTType for self::ScanVertexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanVertexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanVertexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.cursor {
            p.write_field_begin("cursor", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("return_columns", ::fbthrift::TType::Map, 4);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("all_columns", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.all_columns, p);
        p.write_field_end();
        p.write_field_begin("limit", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.limit, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("end_time", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.end_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanVertexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_columns", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("cursor", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("end_time", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("limit", ::fbthrift::TType::I32, 6),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 7),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_cursor = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_all_columns = ::std::option::Option::None;
        let mut field_limit = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_end_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_all_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            cursor: field_cursor,
            return_columns: field_return_columns.unwrap_or_default(),
            all_columns: field_all_columns.unwrap_or_default(),
            limit: field_limit.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            end_time: field_end_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanVertex {
    fn default() -> Self {
        Self {
            vertexId: ::std::default::Default::default(),
            tagId: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanVertex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanVertex")
            .field("vertexId", &self.vertexId)
            .field("tagId", &self.tagId)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanVertex {}
unsafe impl ::std::marker::Sync for self::ScanVertex {}

impl ::fbthrift::GetTType for self::ScanVertex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanVertex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanVertex");
        p.write_field_begin("vertexId", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.vertexId, p);
        p.write_field_end();
        p.write_field_begin("tagId", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.tagId, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanVertex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("tagId", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("vertexId", ::fbthrift::TType::I64, 1),
        ];
        let mut field_vertexId = ::std::option::Option::None;
        let mut field_tagId = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_vertexId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_tagId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            vertexId: field_vertexId.unwrap_or_default(),
            tagId: field_tagId.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanVertexResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            vertex_schema: ::std::default::Default::default(),
            vertex_data: ::std::default::Default::default(),
            has_next: ::std::default::Default::default(),
            next_cursor: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanVertexResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanVertexResponse")
            .field("result", &self.result)
            .field("vertex_schema", &self.vertex_schema)
            .field("vertex_data", &self.vertex_data)
            .field("has_next", &self.has_next)
            .field("next_cursor", &self.next_cursor)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanVertexResponse {}
unsafe impl ::std::marker::Sync for self::ScanVertexResponse {}

impl ::fbthrift::GetTType for self::ScanVertexResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanVertexResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanVertexResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("vertex_schema", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.vertex_schema, p);
        p.write_field_end();
        p.write_field_begin("vertex_data", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.vertex_data, p);
        p.write_field_end();
        p.write_field_begin("has_next", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.has_next, p);
        p.write_field_end();
        p.write_field_begin("next_cursor", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.next_cursor, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanVertexResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("has_next", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("next_cursor", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("vertex_data", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("vertex_schema", ::fbthrift::TType::Map, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_vertex_schema = ::std::option::Option::None;
        let mut field_vertex_data = ::std::option::Option::None;
        let mut field_has_next = ::std::option::Option::None;
        let mut field_next_cursor = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_vertex_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_vertex_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_has_next = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_next_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            vertex_schema: field_vertex_schema.unwrap_or_default(),
            vertex_data: field_vertex_data.unwrap_or_default(),
            has_next: field_has_next.unwrap_or_default(),
            next_cursor: field_next_cursor.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PutRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PutRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PutRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PutRequest {}
unsafe impl ::std::marker::Sync for self::PutRequest {}

impl ::fbthrift::GetTType for self::PutRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PutRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PutRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PutRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveRequest {}
unsafe impl ::std::marker::Sync for self::RemoveRequest {}

impl ::fbthrift::GetTType for self::RemoveRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveRangeRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveRangeRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveRangeRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveRangeRequest {}
unsafe impl ::std::marker::Sync for self::RemoveRangeRequest {}

impl ::fbthrift::GetTType for self::RemoveRangeRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveRangeRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            return_partly: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("return_partly", &self.return_partly)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetRequest {}
unsafe impl ::std::marker::Sync for self::GetRequest {}

impl ::fbthrift::GetTType for self::GetRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("return_partly", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.return_partly, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("return_partly", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_return_partly = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_return_partly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            return_partly: field_return_partly.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PrefixRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PrefixRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PrefixRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PrefixRequest {}
unsafe impl ::std::marker::Sync for self::PrefixRequest {}

impl ::fbthrift::GetTType for self::PrefixRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PrefixRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PrefixRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PrefixRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanRequest {}
unsafe impl ::std::marker::Sync for self::ScanRequest {}

impl ::fbthrift::GetTType for self::ScanRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GeneralResponse {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GeneralResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GeneralResponse")
            .field("result", &self.result)
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GeneralResponse {}
unsafe impl ::std::marker::Sync for self::GeneralResponse {}

impl ::fbthrift::GetTType for self::GeneralResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GeneralResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GeneralResponse");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("values", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GeneralResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("values", ::fbthrift::TType::Map, 2),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUUIDReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUUIDReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUUIDReq")
            .field("space_id", &self.space_id)
            .field("part_id", &self.part_id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUUIDReq {}
unsafe impl ::std::marker::Sync for self::GetUUIDReq {}

impl ::fbthrift::GetTType for self::GetUUIDReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUUIDReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUUIDReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUUIDResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUUIDResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUUIDResp")
            .field("result", &self.result)
            .field("id", &self.id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUUIDResp {}
unsafe impl ::std::marker::Sync for self::GetUUIDResp {}

impl ::fbthrift::GetTType for self::GetUUIDResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUUIDResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUUIDResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BlockingSignRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            sign: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BlockingSignRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BlockingSignRequest")
            .field("space_id", &self.space_id)
            .field("sign", &self.sign)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BlockingSignRequest {}
unsafe impl ::std::marker::Sync for self::BlockingSignRequest {}

impl ::fbthrift::GetTType for self::BlockingSignRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BlockingSignRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BlockingSignRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("sign", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.sign, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BlockingSignRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("sign", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_sign = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_sign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            sign: field_sign.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateCPRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateCPRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateCPRequest")
            .field("space_id", &self.space_id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateCPRequest {}
unsafe impl ::std::marker::Sync for self::CreateCPRequest {}

impl ::fbthrift::GetTType for self::CreateCPRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateCPRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateCPRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateCPRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropCPRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropCPRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropCPRequest")
            .field("space_id", &self.space_id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropCPRequest {}
unsafe impl ::std::marker::Sync for self::DropCPRequest {}

impl ::fbthrift::GetTType for self::DropCPRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropCPRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropCPRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropCPRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RebuildIndexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            index_id: ::std::default::Default::default(),
            is_offline: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RebuildIndexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RebuildIndexRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("index_id", &self.index_id)
            .field("is_offline", &self.is_offline)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RebuildIndexRequest {}
unsafe impl ::std::marker::Sync for self::RebuildIndexRequest {}

impl ::fbthrift::GetTType for self::RebuildIndexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RebuildIndexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_begin("is_offline", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.is_offline, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("is_offline", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_index_id = ::std::option::Option::None;
        let mut field_is_offline = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_is_offline = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            index_id: field_index_id.unwrap_or_default(),
            is_offline: field_is_offline.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LookUpIndexRequest {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            index_id: ::std::default::Default::default(),
            filter: ::std::default::Default::default(),
            return_columns: ::std::default::Default::default(),
            is_edge: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LookUpIndexRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LookUpIndexRequest")
            .field("space_id", &self.space_id)
            .field("parts", &self.parts)
            .field("index_id", &self.index_id)
            .field("filter", &self.filter)
            .field("return_columns", &self.return_columns)
            .field("is_edge", &self.is_edge)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LookUpIndexRequest {}
unsafe impl ::std::marker::Sync for self::LookUpIndexRequest {}

impl ::fbthrift::GetTType for self::LookUpIndexRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LookUpIndexRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LookUpIndexRequest");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_begin("filter", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.filter, p);
        p.write_field_end();
        p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.return_columns, p);
        p.write_field_end();
        p.write_field_begin("is_edge", ::fbthrift::TType::Bool, 6);
        ::fbthrift::Serialize::write(&self.is_edge, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LookUpIndexRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("filter", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("is_edge", ::fbthrift::TType::Bool, 6),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("return_columns", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_index_id = ::std::option::Option::None;
        let mut field_filter = ::std::option::Option::None;
        let mut field_return_columns = ::std::option::Option::None;
        let mut field_is_edge = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 6) => field_is_edge = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            index_id: field_index_id.unwrap_or_default(),
            filter: field_filter.unwrap_or_default(),
            return_columns: field_return_columns.unwrap_or_default(),
            is_edge: field_is_edge.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LookUpIndexResp {
    fn default() -> Self {
        Self {
            result: ::std::default::Default::default(),
            schema: ::std::option::Option::None,
            vertices: ::std::option::Option::None,
            edges: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LookUpIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LookUpIndexResp")
            .field("result", &self.result)
            .field("schema", &self.schema)
            .field("vertices", &self.vertices)
            .field("edges", &self.edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LookUpIndexResp {}
unsafe impl ::std::marker::Sync for self::LookUpIndexResp {}

impl ::fbthrift::GetTType for self::LookUpIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LookUpIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LookUpIndexResp");
        p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.schema {
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.vertices {
            p.write_field_begin("vertices", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.edges {
            p.write_field_begin("edges", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LookUpIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("vertices", ::fbthrift::TType::List, 3),
        ];
        let mut field_result = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_vertices = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            result: field_result.unwrap_or_default(),
            schema: field_schema,
            vertices: field_vertices,
            edges: field_edges,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
