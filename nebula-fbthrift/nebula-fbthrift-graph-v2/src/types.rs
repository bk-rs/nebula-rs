// @generated by Thrift for src/interface/graph.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `graph`.

#![allow(clippy::redundant_closure)]


#[derive(Clone, PartialEq)]
pub struct ProfilingStats {
    pub rows: ::std::primitive::i64,
    pub exec_duration_in_us: ::std::primitive::i64,
    pub total_duration_in_us: ::std::primitive::i64,
    pub other_stats: ::std::option::Option<::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct PlanNodeBranchInfo {
    pub is_do_branch: ::std::primitive::bool,
    pub condition_node_id: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Pair {
    pub key: ::std::vec::Vec<::std::primitive::u8>,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PlanNodeDescription {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub id: ::std::primitive::i64,
    pub output_var: ::std::vec::Vec<::std::primitive::u8>,
    pub description: ::std::option::Option<::std::vec::Vec<crate::types::Pair>>,
    pub profiles: ::std::option::Option<::std::vec::Vec<crate::types::ProfilingStats>>,
    pub branch_info: ::std::option::Option<crate::types::PlanNodeBranchInfo>,
    pub dependencies: ::std::option::Option<::std::vec::Vec<::std::primitive::i64>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PlanDescription {
    pub plan_node_descs: ::std::vec::Vec<crate::types::PlanNodeDescription>,
    pub node_index_map: ::std::collections::BTreeMap<::std::primitive::i64, ::std::primitive::i64>,
    pub format: ::std::vec::Vec<::std::primitive::u8>,
    pub optimize_time_in_us: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecutionResponse {
    pub error_code: common::types::ErrorCode,
    pub latency_in_us: ::std::primitive::i32,
    pub data: ::std::option::Option<common::types::DataSet>,
    pub space_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub plan_desc: ::std::option::Option<crate::types::PlanDescription>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AuthResponse {
    pub error_code: common::types::ErrorCode,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub session_id: ::std::option::Option<::std::primitive::i64>,
    pub time_zone_offset_seconds: ::std::option::Option<::std::primitive::i32>,
    pub time_zone_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VerifyClientVersionResp {
    pub error_code: common::types::ErrorCode,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VerifyClientVersionReq {
    pub version: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ProfilingStats {
    fn default() -> Self {
        Self {
            rows: ::std::default::Default::default(),
            exec_duration_in_us: ::std::default::Default::default(),
            total_duration_in_us: ::std::default::Default::default(),
            other_stats: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ProfilingStats {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ProfilingStats")
            .field("rows", &self.rows)
            .field("exec_duration_in_us", &self.exec_duration_in_us)
            .field("total_duration_in_us", &self.total_duration_in_us)
            .field("other_stats", &self.other_stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ProfilingStats {}
unsafe impl ::std::marker::Sync for self::ProfilingStats {}

impl ::fbthrift::GetTType for self::ProfilingStats {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ProfilingStats
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ProfilingStats");
        p.write_field_begin("rows", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.rows, p);
        p.write_field_end();
        p.write_field_begin("exec_duration_in_us", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.exec_duration_in_us, p);
        p.write_field_end();
        p.write_field_begin("total_duration_in_us", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.total_duration_in_us, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.other_stats {
            p.write_field_begin("other_stats", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ProfilingStats
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("exec_duration_in_us", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("other_stats", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("rows", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("total_duration_in_us", ::fbthrift::TType::I64, 3),
        ];
        let mut field_rows = ::std::option::Option::None;
        let mut field_exec_duration_in_us = ::std::option::Option::None;
        let mut field_total_duration_in_us = ::std::option::Option::None;
        let mut field_other_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_exec_duration_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_total_duration_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_other_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            rows: field_rows.unwrap_or_default(),
            exec_duration_in_us: field_exec_duration_in_us.unwrap_or_default(),
            total_duration_in_us: field_total_duration_in_us.unwrap_or_default(),
            other_stats: field_other_stats,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PlanNodeBranchInfo {
    fn default() -> Self {
        Self {
            is_do_branch: ::std::default::Default::default(),
            condition_node_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PlanNodeBranchInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PlanNodeBranchInfo")
            .field("is_do_branch", &self.is_do_branch)
            .field("condition_node_id", &self.condition_node_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PlanNodeBranchInfo {}
unsafe impl ::std::marker::Sync for self::PlanNodeBranchInfo {}

impl ::fbthrift::GetTType for self::PlanNodeBranchInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PlanNodeBranchInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PlanNodeBranchInfo");
        p.write_field_begin("is_do_branch", ::fbthrift::TType::Bool, 1);
        ::fbthrift::Serialize::write(&self.is_do_branch, p);
        p.write_field_end();
        p.write_field_begin("condition_node_id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.condition_node_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PlanNodeBranchInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("condition_node_id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("is_do_branch", ::fbthrift::TType::Bool, 1),
        ];
        let mut field_is_do_branch = ::std::option::Option::None;
        let mut field_condition_node_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 1) => field_is_do_branch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_condition_node_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            is_do_branch: field_is_do_branch.unwrap_or_default(),
            condition_node_id: field_condition_node_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Pair {
    fn default() -> Self {
        Self {
            key: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Pair {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Pair")
            .field("key", &self.key)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Pair {}
unsafe impl ::std::marker::Sync for self::Pair {}

impl ::fbthrift::GetTType for self::Pair {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Pair
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Pair");
        p.write_field_begin("key", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Pair
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
        ];
        let mut field_key = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            key: field_key.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PlanNodeDescription {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            output_var: ::std::default::Default::default(),
            description: ::std::option::Option::None,
            profiles: ::std::option::Option::None,
            branch_info: ::std::option::Option::None,
            dependencies: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PlanNodeDescription {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PlanNodeDescription")
            .field("name", &self.name)
            .field("id", &self.id)
            .field("output_var", &self.output_var)
            .field("description", &self.description)
            .field("profiles", &self.profiles)
            .field("branch_info", &self.branch_info)
            .field("dependencies", &self.dependencies)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PlanNodeDescription {}
unsafe impl ::std::marker::Sync for self::PlanNodeDescription {}

impl ::fbthrift::GetTType for self::PlanNodeDescription {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PlanNodeDescription
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PlanNodeDescription");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("output_var", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.output_var, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.description {
            p.write_field_begin("description", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.profiles {
            p.write_field_begin("profiles", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.branch_info {
            p.write_field_begin("branch_info", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.dependencies {
            p.write_field_begin("dependencies", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PlanNodeDescription
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("branch_info", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("dependencies", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("description", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("output_var", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("profiles", ::fbthrift::TType::List, 5),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_output_var = ::std::option::Option::None;
        let mut field_description = ::std::option::Option::None;
        let mut field_profiles = ::std::option::Option::None;
        let mut field_branch_info = ::std::option::Option::None;
        let mut field_dependencies = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_output_var = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_description = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_profiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_branch_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_dependencies = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            output_var: field_output_var.unwrap_or_default(),
            description: field_description,
            profiles: field_profiles,
            branch_info: field_branch_info,
            dependencies: field_dependencies,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PlanDescription {
    fn default() -> Self {
        Self {
            plan_node_descs: ::std::default::Default::default(),
            node_index_map: ::std::default::Default::default(),
            format: ::std::default::Default::default(),
            optimize_time_in_us: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PlanDescription {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PlanDescription")
            .field("plan_node_descs", &self.plan_node_descs)
            .field("node_index_map", &self.node_index_map)
            .field("format", &self.format)
            .field("optimize_time_in_us", &self.optimize_time_in_us)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PlanDescription {}
unsafe impl ::std::marker::Sync for self::PlanDescription {}

impl ::fbthrift::GetTType for self::PlanDescription {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PlanDescription
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PlanDescription");
        p.write_field_begin("plan_node_descs", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.plan_node_descs, p);
        p.write_field_end();
        p.write_field_begin("node_index_map", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.node_index_map, p);
        p.write_field_end();
        p.write_field_begin("format", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.format, p);
        p.write_field_end();
        p.write_field_begin("optimize_time_in_us", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.optimize_time_in_us, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PlanDescription
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("format", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("node_index_map", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("optimize_time_in_us", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("plan_node_descs", ::fbthrift::TType::List, 1),
        ];
        let mut field_plan_node_descs = ::std::option::Option::None;
        let mut field_node_index_map = ::std::option::Option::None;
        let mut field_format = ::std::option::Option::None;
        let mut field_optimize_time_in_us = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_plan_node_descs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_node_index_map = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_format = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_optimize_time_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            plan_node_descs: field_plan_node_descs.unwrap_or_default(),
            node_index_map: field_node_index_map.unwrap_or_default(),
            format: field_format.unwrap_or_default(),
            optimize_time_in_us: field_optimize_time_in_us.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecutionResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            latency_in_us: ::std::default::Default::default(),
            data: ::std::option::Option::None,
            space_name: ::std::option::Option::None,
            error_msg: ::std::option::Option::None,
            plan_desc: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecutionResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecutionResponse")
            .field("error_code", &self.error_code)
            .field("latency_in_us", &self.latency_in_us)
            .field("data", &self.data)
            .field("space_name", &self.space_name)
            .field("error_msg", &self.error_msg)
            .field("plan_desc", &self.plan_desc)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecutionResponse {}
unsafe impl ::std::marker::Sync for self::ExecutionResponse {}

impl ::fbthrift::GetTType for self::ExecutionResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecutionResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecutionResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("latency_in_us", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.latency_in_us, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.data {
            p.write_field_begin("data", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.space_name {
            p.write_field_begin("space_name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.plan_desc {
            p.write_field_begin("plan_desc", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecutionResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("data", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("latency_in_us", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("plan_desc", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_latency_in_us = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let mut field_space_name = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let mut field_plan_desc = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_latency_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_plan_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            latency_in_us: field_latency_in_us.unwrap_or_default(),
            data: field_data,
            space_name: field_space_name,
            error_msg: field_error_msg,
            plan_desc: field_plan_desc,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AuthResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            error_msg: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            time_zone_offset_seconds: ::std::option::Option::None,
            time_zone_name: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AuthResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AuthResponse")
            .field("error_code", &self.error_code)
            .field("error_msg", &self.error_msg)
            .field("session_id", &self.session_id)
            .field("time_zone_offset_seconds", &self.time_zone_offset_seconds)
            .field("time_zone_name", &self.time_zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AuthResponse {}
unsafe impl ::std::marker::Sync for self::AuthResponse {}

impl ::fbthrift::GetTType for self::AuthResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AuthResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AuthResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.session_id {
            p.write_field_begin("session_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.time_zone_offset_seconds {
            p.write_field_begin("time_zone_offset_seconds", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.time_zone_name {
            p.write_field_begin("time_zone_name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AuthResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("time_zone_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("time_zone_offset_seconds", ::fbthrift::TType::I32, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let mut field_session_id = ::std::option::Option::None;
        let mut field_time_zone_offset_seconds = ::std::option::Option::None;
        let mut field_time_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_time_zone_offset_seconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_time_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            error_msg: field_error_msg,
            session_id: field_session_id,
            time_zone_offset_seconds: field_time_zone_offset_seconds,
            time_zone_name: field_time_zone_name,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionResp {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            error_msg: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionResp")
            .field("error_code", &self.error_code)
            .field("error_msg", &self.error_msg)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionResp {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionResp {}

impl ::fbthrift::GetTType for self::VerifyClientVersionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionResp");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 2),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            error_msg: field_error_msg,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionReq {
    fn default() -> Self {
        Self {
            version: "2.6.0".as_bytes().into(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionReq")
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionReq {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionReq {}

impl ::fbthrift::GetTType for self::VerifyClientVersionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionReq");
        p.write_field_begin("version", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 1),
        ];
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            version: field_version.unwrap_or_else(|| "2.6.0".as_bytes().into()),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
