// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `meta`.

#![allow(clippy::redundant_closure)]


pub type SchemaVer = ::std::primitive::i64;

pub type ClusterID = ::std::primitive::i64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ID {
    space_id(common::types::GraphSpaceID),
    tag_id(common::types::TagID),
    edge_type(common::types::EdgeType),
    index_id(common::types::IndexID),
    cluster_id(crate::types::ClusterID),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ColumnTypeDef {
    pub r#type: common::types::PropertyType,
    pub type_length: ::std::option::Option<::std::primitive::i16>,
    pub geo_shape: ::std::option::Option<crate::types::GeoShape>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ColumnDef {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub r#type: crate::types::ColumnTypeDef,
    pub default_value: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub nullable: ::std::option::Option<::std::primitive::bool>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SchemaProp {
    pub ttl_duration: ::std::option::Option<::std::primitive::i64>,
    pub ttl_col: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Schema {
    pub columns: ::std::vec::Vec<crate::types::ColumnDef>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IdName {
    pub id: crate::types::ID,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceDesc {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub partition_num: ::std::primitive::i32,
    pub replica_factor: ::std::primitive::i32,
    pub charset_name: ::std::vec::Vec<::std::primitive::u8>,
    pub collate_name: ::std::vec::Vec<::std::primitive::u8>,
    pub vid_type: crate::types::ColumnTypeDef,
    pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub isolation_level: ::std::option::Option<crate::types::IsolationLevel>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceItem {
    pub space_id: common::types::GraphSpaceID,
    pub properties: crate::types::SpaceDesc,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TagItem {
    pub tag_id: common::types::TagID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterSchemaItem {
    pub op: crate::types::AlterSchemaOp,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgeItem {
    pub edge_type: common::types::EdgeType,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexParams {
    pub s2_max_level: ::std::option::Option<::std::primitive::i32>,
    pub s2_max_cells: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IndexItem {
    pub index_id: common::types::IndexID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema_id: common::types::SchemaID,
    pub schema_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::ColumnDef>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub index_params: ::std::option::Option<crate::types::IndexParams>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostItem {
    pub hostAddr: common::types::HostAddr,
    pub status: crate::types::HostStatus,
    pub leader_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
    pub all_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
    pub role: crate::types::HostRole,
    pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub version: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UserItem {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub is_lock: ::std::primitive::bool,
    pub max_queries_per_hour: ::std::primitive::i32,
    pub max_updates_per_hour: ::std::primitive::i32,
    pub max_connections_per_hour: ::std::primitive::i32,
    pub max_user_connections: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RoleItem {
    pub user_id: ::std::vec::Vec<::std::primitive::u8>,
    pub space_id: common::types::GraphSpaceID,
    pub role_type: crate::types::RoleType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecResp {
    pub code: common::types::ErrorCode,
    pub id: crate::types::ID,
    pub leader: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AlterSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub op: crate::types::AlterSpaceOp,
    pub paras: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AdminJobReq {
    pub space_id: common::types::GraphSpaceID,
    pub op: crate::types::JobOp,
    pub r#type: crate::types::JobType,
    pub paras: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct JobDesc {
    pub space_id: common::types::GraphSpaceID,
    pub job_id: ::std::primitive::i32,
    pub r#type: crate::types::JobType,
    pub paras: ::std::vec::Vec<::std::string::String>,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TaskDesc {
    pub space_id: common::types::GraphSpaceID,
    pub job_id: ::std::primitive::i32,
    pub task_id: ::std::primitive::i32,
    pub host: common::types::HostAddr,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    pub code: common::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResult {
    pub job_id: ::std::option::Option<::std::primitive::i32>,
    pub job_desc: ::std::option::Option<::std::vec::Vec<crate::types::JobDesc>>,
    pub task_desc: ::std::option::Option<::std::vec::Vec<crate::types::TaskDesc>>,
    pub recovered_job_num: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub result: crate::types::AdminJobResult,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Correlativity {
    pub part_id: common::types::PartitionID,
    pub proportion: ::std::primitive::f64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct StatsItem {
    pub tag_vertices: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
    pub edges: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
    pub space_vertices: ::std::primitive::i64,
    pub space_edges: ::std::primitive::i64,
    pub positive_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
    pub negative_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
    pub status: crate::types::JobStatus,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSpaceReq {
    pub properties: crate::types::SpaceDesc,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateSpaceAsReq {
    pub old_space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub new_space_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ClearSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSpacesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSpacesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub spaces: ::std::vec::Vec<crate::types::IdName>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSpaceResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::SpaceItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema: crate::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub tag_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagsReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub tags: ::std::vec::Vec<crate::types::TagItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema: crate::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub edge_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub edges: ::std::vec::Vec<crate::types::EdgeItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddHostsReq {
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DropHostsReq {
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListHostsReq {
    pub r#type: crate::types::ListHostType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListHostsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub hosts: ::std::vec::Vec<crate::types::HostItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PartItem {
    pub part_id: common::types::PartitionID,
    pub leader: ::std::option::Option<common::types::HostAddr>,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    pub losts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListPartsReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_ids: ::std::vec::Vec<common::types::PartitionID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListPartsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::vec::Vec<crate::types::PartItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetPartsAllocReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetPartsAllocResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::HostAddr>>,
    pub terms: ::std::option::Option<::std::collections::BTreeMap<common::types::PartitionID, ::std::primitive::i64>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetWorkerIdReq {
    pub host: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetWorkerIdResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub workerid: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSegmentIdReq {
    pub length: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSegmentIdResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub segment_id: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub cluster_id: crate::types::ClusterID,
    pub last_update_time_in_ms: ::std::primitive::i64,
    pub meta_version: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LeaderInfo {
    pub part_id: common::types::PartitionID,
    pub term: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct PartitionList {
    pub part_list: ::std::vec::Vec<common::types::PartitionID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBReq {
    pub role: crate::types::HostRole,
    pub host: common::types::HostAddr,
    pub cluster_id: crate::types::ClusterID,
    pub leader_partIds: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<crate::types::LeaderInfo>>>,
    pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    pub disk_parts: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::PartitionList>>>,
    pub dir: ::std::option::Option<common::types::DirInfo>,
    pub version: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ServiceInfo {
    pub dir: common::types::DirInfo,
    pub addr: common::types::HostAddr,
    pub role: crate::types::HostRole,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AgentHBReq {
    pub host: common::types::HostAddr,
    pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    pub version: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AgentHBResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub service_list: ::std::vec::Vec<crate::types::ServiceInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexFieldDef {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub type_length: ::std::option::Option<::std::primitive::i16>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
    pub if_not_exists: ::std::primitive::bool,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub index_params: ::std::option::Option<crate::types::IndexParams>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagIndexResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
    pub if_not_exists: ::std::primitive::bool,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub index_params: ::std::option::Option<crate::types::IndexParams>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeIndexResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgeIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgeIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RebuildIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AlterUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GrantRoleReq {
    pub role_item: crate::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RevokeRoleReq {
    pub role_item: crate::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListUsersReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListUsersResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub users: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListRolesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListRolesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub roles: ::std::vec::Vec<crate::types::RoleItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetUserRolesReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ChangePasswordReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub new_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    pub old_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BalanceTask {
    pub id: ::std::vec::Vec<::std::primitive::u8>,
    pub command: ::std::vec::Vec<::std::primitive::u8>,
    pub result: crate::types::TaskResult,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ConfigItem {
    pub module: crate::types::ConfigModule,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub mode: crate::types::ConfigMode,
    pub value: common::types::Value,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RegConfigReq {
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigReq {
    pub item: crate::types::ConfigItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SetConfigReq {
    pub item: crate::types::ConfigItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListConfigsReq {
    pub space: ::std::vec::Vec<::std::primitive::u8>,
    pub module: crate::types::ConfigModule,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListConfigsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateSnapshotReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSnapshotReq {
    pub names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSnapshotsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Snapshot {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub status: crate::types::SnapshotStatus,
    pub hosts: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSnapshotsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub snapshots: ::std::vec::Vec<crate::types::Snapshot>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListIndexStatusReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexStatus {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub status: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListIndexStatusResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub statuses: ::std::vec::Vec<crate::types::IndexStatus>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MergeZoneReq {
    pub zones: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DivideZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_items: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::HostAddr>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RenameZoneReq {
    pub original_zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddHostsIntoZoneReq {
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub is_new: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetZoneResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListZonesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Zone {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub nodes: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListZonesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub zones: ::std::vec::Vec<crate::types::Zone>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddListenerReq {
    pub space_id: common::types::GraphSpaceID,
    pub r#type: crate::types::ListenerType,
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveListenerReq {
    pub space_id: common::types::GraphSpaceID,
    pub r#type: crate::types::ListenerType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListListenerReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListenerInfo {
    pub r#type: crate::types::ListenerType,
    pub host: common::types::HostAddr,
    pub part_id: common::types::PartitionID,
    pub status: crate::types::HostStatus,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListListenerResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub listeners: ::std::vec::Vec<crate::types::ListenerInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetStatsReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetStatsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub stats: crate::types::StatsItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostBackupInfo {
    pub host: common::types::HostAddr,
    pub checkpoints: ::std::vec::Vec<common::types::CheckpointInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceBackupInfo {
    pub space: crate::types::SpaceDesc,
    pub host_backups: ::std::vec::Vec<crate::types::HostBackupInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BackupMeta {
    pub space_backups: ::std::collections::BTreeMap<common::types::GraphSpaceID, crate::types::SpaceBackupInfo>,
    pub meta_files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub backup_name: ::std::vec::Vec<::std::primitive::u8>,
    pub full: ::std::primitive::bool,
    pub all_spaces: ::std::primitive::bool,
    pub create_time: ::std::primitive::i64,
    pub base_backup_name: ::std::vec::Vec<::std::primitive::u8>,
    pub storage_hosts: ::std::vec::Vec<common::types::HostAddr>,
    pub cluster_id: crate::types::ClusterID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateBackupReq {
    pub spaces: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    pub base_backup_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub cluster_id: ::std::option::Option<crate::types::ClusterID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateBackupResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub meta: crate::types::BackupMeta,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostPair {
    pub from_host: common::types::HostAddr,
    pub to_host: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RestoreMetaReq {
    pub files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub hosts: ::std::vec::Vec<crate::types::HostPair>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PartInfo {
    pub part_id: common::types::PartitionID,
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RestoreMetaResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub part_hosts: ::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<crate::types::PartInfo>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ServiceClient {
    pub host: common::types::HostAddr,
    pub user: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub pwd: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub conn_type: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SignInServiceReq {
    pub r#type: crate::types::ExternalServiceType,
    pub clients: ::std::vec::Vec<crate::types::ServiceClient>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SignOutServiceReq {
    pub r#type: crate::types::ExternalServiceType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListServiceClientsReq {
    pub r#type: crate::types::ExternalServiceType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListServiceClientsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub clients: ::std::collections::BTreeMap<crate::types::ExternalServiceType, ::std::vec::Vec<crate::types::ServiceClient>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct FTIndex {
    pub space_id: common::types::GraphSpaceID,
    pub depend_schema: common::types::SchemaID,
    pub fields: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateFTIndexReq {
    pub fulltext_index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub index: crate::types::FTIndex,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropFTIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub fulltext_index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListFTIndexesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListFTIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub indexes: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::FTIndex>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct QueryDesc {
    pub start_time: common::types::Timestamp,
    pub status: crate::types::QueryStatus,
    pub duration: ::std::primitive::i64,
    pub query: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Session {
    pub session_id: common::types::SessionID,
    pub create_time: common::types::Timestamp,
    pub update_time: common::types::Timestamp,
    pub user_name: ::std::vec::Vec<::std::primitive::u8>,
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    pub timezone: ::std::primitive::i32,
    pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
    pub configs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, common::types::Value>,
    pub queries: ::std::collections::BTreeMap<common::types::ExecutionPlanID, crate::types::QueryDesc>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSessionReq {
    pub user: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSessionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub session: crate::types::Session,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateSessionsReq {
    pub sessions: ::std::vec::Vec<crate::types::Session>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateSessionsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub killed_queries: ::std::collections::BTreeMap<common::types::SessionID, ::std::collections::BTreeMap<common::types::ExecutionPlanID, crate::types::QueryDesc>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSessionsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSessionsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub sessions: ::std::vec::Vec<crate::types::Session>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSessionReq {
    pub session_id: common::types::SessionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSessionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub session: crate::types::Session,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveSessionReq {
    pub session_id: common::types::SessionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KillQueryReq {
    pub kill_queries: ::std::collections::BTreeMap<common::types::SessionID, ::std::collections::BTreeSet<common::types::ExecutionPlanID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ReportTaskReq {
    pub code: common::types::ErrorCode,
    pub space_id: common::types::GraphSpaceID,
    pub job_id: ::std::primitive::i32,
    pub task_id: ::std::primitive::i32,
    pub stats: ::std::option::Option<crate::types::StatsItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListClusterInfoResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub host_services: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<crate::types::ServiceInfo>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListClusterInfoReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetMetaDirInfoResp {
    pub code: common::types::ErrorCode,
    pub dir: common::types::DirInfo,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetMetaDirInfoReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct VerifyClientVersionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct VerifyClientVersionReq {
    pub client_version: ::std::vec::Vec<::std::primitive::u8>,
    pub host: common::types::HostAddr,
    pub build_version: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SaveGraphVersionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SaveGraphVersionReq {
    pub client_version: ::std::vec::Vec<::std::primitive::u8>,
    pub host: common::types::HostAddr,
    pub build_version: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AlterSchemaOp(pub ::std::primitive::i32);

impl AlterSchemaOp {
    pub const ADD: Self = AlterSchemaOp(1i32);
    pub const CHANGE: Self = AlterSchemaOp(2i32);
    pub const DROP: Self = AlterSchemaOp(3i32);
    pub const UNKNOWN: Self = AlterSchemaOp(4i32);
}

impl ::fbthrift::ThriftEnum for AlterSchemaOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::CHANGE, "CHANGE"),
            (Self::DROP, "DROP"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "CHANGE",
            "DROP",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::CHANGE,
            Self::DROP,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for AlterSchemaOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AlterSchemaOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AlterSchemaOp::{}", self)
    }
}

impl ::std::str::FromStr for AlterSchemaOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSchemaOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AlterSchemaOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct RoleType(pub ::std::primitive::i32);

impl RoleType {
    pub const GOD: Self = RoleType(1i32);
    pub const ADMIN: Self = RoleType(2i32);
    pub const DBA: Self = RoleType(3i32);
    pub const USER: Self = RoleType(4i32);
    pub const GUEST: Self = RoleType(5i32);
}

impl ::fbthrift::ThriftEnum for RoleType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::GOD, "GOD"),
            (Self::ADMIN, "ADMIN"),
            (Self::DBA, "DBA"),
            (Self::USER, "USER"),
            (Self::GUEST, "GUEST"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "GOD",
            "ADMIN",
            "DBA",
            "USER",
            "GUEST",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::GOD,
            Self::ADMIN,
            Self::DBA,
            Self::USER,
            Self::GUEST,
        ]
    }
}

impl ::std::default::Default for RoleType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a RoleType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a RoleType) -> Self {
        x.0
    }
}

impl ::std::convert::From<RoleType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: RoleType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for RoleType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for RoleType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("GOD", 1),
            ("ADMIN", 2),
            ("DBA", 3),
            ("USER", 4),
            ("GUEST", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for RoleType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "RoleType::{}", self)
    }
}

impl ::std::str::FromStr for RoleType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADMIN", 2),
            ("DBA", 3),
            ("GOD", 1),
            ("GUEST", 5),
            ("USER", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "RoleType").map(Self)
    }
}

impl ::fbthrift::GetTType for RoleType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for RoleType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for RoleType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct GeoShape(pub ::std::primitive::i32);

impl GeoShape {
    pub const ANY: Self = GeoShape(0i32);
    pub const POINT: Self = GeoShape(1i32);
    pub const LINESTRING: Self = GeoShape(2i32);
    pub const POLYGON: Self = GeoShape(3i32);
}

impl ::fbthrift::ThriftEnum for GeoShape {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ANY, "ANY"),
            (Self::POINT, "POINT"),
            (Self::LINESTRING, "LINESTRING"),
            (Self::POLYGON, "POLYGON"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ANY",
            "POINT",
            "LINESTRING",
            "POLYGON",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ANY,
            Self::POINT,
            Self::LINESTRING,
            Self::POLYGON,
        ]
    }
}

impl ::std::default::Default for GeoShape {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a GeoShape> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a GeoShape) -> Self {
        x.0
    }
}

impl ::std::convert::From<GeoShape> for ::std::primitive::i32 {
    #[inline]
    fn from(x: GeoShape) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for GeoShape {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for GeoShape {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ANY", 0),
            ("POINT", 1),
            ("LINESTRING", 2),
            ("POLYGON", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for GeoShape {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "GeoShape::{}", self)
    }
}

impl ::std::str::FromStr for GeoShape {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ANY", 0),
            ("LINESTRING", 2),
            ("POINT", 1),
            ("POLYGON", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "GeoShape").map(Self)
    }
}

impl ::fbthrift::GetTType for GeoShape {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for GeoShape
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for GeoShape
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct IsolationLevel(pub ::std::primitive::i32);

impl IsolationLevel {
    pub const DEFAULT: Self = IsolationLevel(0i32);
    pub const TOSS: Self = IsolationLevel(1i32);
}

impl ::fbthrift::ThriftEnum for IsolationLevel {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::DEFAULT, "DEFAULT"),
            (Self::TOSS, "TOSS"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "DEFAULT",
            "TOSS",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::DEFAULT,
            Self::TOSS,
        ]
    }
}

impl ::std::default::Default for IsolationLevel {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a IsolationLevel> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a IsolationLevel) -> Self {
        x.0
    }
}

impl ::std::convert::From<IsolationLevel> for ::std::primitive::i32 {
    #[inline]
    fn from(x: IsolationLevel) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for IsolationLevel {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for IsolationLevel {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DEFAULT", 0),
            ("TOSS", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for IsolationLevel {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "IsolationLevel::{}", self)
    }
}

impl ::std::str::FromStr for IsolationLevel {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DEFAULT", 0),
            ("TOSS", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "IsolationLevel").map(Self)
    }
}

impl ::fbthrift::GetTType for IsolationLevel {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for IsolationLevel
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for IsolationLevel
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct HostStatus(pub ::std::primitive::i32);

impl HostStatus {
    pub const ONLINE: Self = HostStatus(0i32);
    pub const OFFLINE: Self = HostStatus(1i32);
    pub const UNKNOWN: Self = HostStatus(2i32);
}

impl ::fbthrift::ThriftEnum for HostStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ONLINE, "ONLINE"),
            (Self::OFFLINE, "OFFLINE"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ONLINE",
            "OFFLINE",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ONLINE,
            Self::OFFLINE,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for HostStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for HostStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ONLINE", 0),
            ("OFFLINE", 1),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "HostStatus::{}", self)
    }
}

impl ::std::str::FromStr for HostStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("OFFLINE", 1),
            ("ONLINE", 0),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for HostStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SnapshotStatus(pub ::std::primitive::i32);

impl SnapshotStatus {
    pub const VALID: Self = SnapshotStatus(0i32);
    pub const INVALID: Self = SnapshotStatus(1i32);
}

impl ::fbthrift::ThriftEnum for SnapshotStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::VALID, "VALID"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "VALID",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::VALID,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for SnapshotStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for SnapshotStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("VALID", 0),
            ("INVALID", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "SnapshotStatus::{}", self)
    }
}

impl ::std::str::FromStr for SnapshotStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("INVALID", 1),
            ("VALID", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "SnapshotStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for SnapshotStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AlterSpaceOp(pub ::std::primitive::i32);

impl AlterSpaceOp {
    pub const ADD_ZONE: Self = AlterSpaceOp(1i32);
}

impl ::fbthrift::ThriftEnum for AlterSpaceOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD_ZONE, "ADD_ZONE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD_ZONE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD_ZONE,
        ]
    }
}

impl ::std::default::Default for AlterSpaceOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AlterSpaceOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AlterSpaceOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AlterSpaceOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AlterSpaceOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AlterSpaceOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AlterSpaceOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD_ZONE", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AlterSpaceOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AlterSpaceOp::{}", self)
    }
}

impl ::std::str::FromStr for AlterSpaceOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD_ZONE", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSpaceOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AlterSpaceOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AlterSpaceOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AlterSpaceOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct JobOp(pub ::std::primitive::i32);

impl JobOp {
    pub const ADD: Self = JobOp(1i32);
    pub const SHOW_All: Self = JobOp(2i32);
    pub const SHOW: Self = JobOp(3i32);
    pub const STOP: Self = JobOp(4i32);
    pub const RECOVER: Self = JobOp(5i32);
}

impl ::fbthrift::ThriftEnum for JobOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::SHOW_All, "SHOW_All"),
            (Self::SHOW, "SHOW"),
            (Self::STOP, "STOP"),
            (Self::RECOVER, "RECOVER"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "SHOW_All",
            "SHOW",
            "STOP",
            "RECOVER",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::SHOW_All,
            Self::SHOW,
            Self::STOP,
            Self::RECOVER,
        ]
    }
}

impl ::std::default::Default for JobOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a JobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a JobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<JobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: JobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for JobOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for JobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("SHOW_All", 2),
            ("SHOW", 3),
            ("STOP", 4),
            ("RECOVER", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for JobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "JobOp::{}", self)
    }
}

impl ::std::str::FromStr for JobOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("RECOVER", 5),
            ("SHOW", 3),
            ("SHOW_All", 2),
            ("STOP", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobOp").map(Self)
    }
}

impl ::fbthrift::GetTType for JobOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for JobOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for JobOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct JobType(pub ::std::primitive::i32);

impl JobType {
    pub const COMPACT: Self = JobType(0i32);
    pub const FLUSH: Self = JobType(1i32);
    pub const REBUILD_TAG_INDEX: Self = JobType(2i32);
    pub const REBUILD_EDGE_INDEX: Self = JobType(3i32);
    pub const REBUILD_FULLTEXT_INDEX: Self = JobType(4i32);
    pub const STATS: Self = JobType(5i32);
    pub const DATA_BALANCE: Self = JobType(6i32);
    pub const DOWNLOAD: Self = JobType(7i32);
    pub const INGEST: Self = JobType(8i32);
    pub const LEADER_BALANCE: Self = JobType(9i32);
    pub const ZONE_BALANCE: Self = JobType(10i32);
    pub const UNKNOWN: Self = JobType(99i32);
}

impl ::fbthrift::ThriftEnum for JobType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::COMPACT, "COMPACT"),
            (Self::FLUSH, "FLUSH"),
            (Self::REBUILD_TAG_INDEX, "REBUILD_TAG_INDEX"),
            (Self::REBUILD_EDGE_INDEX, "REBUILD_EDGE_INDEX"),
            (Self::REBUILD_FULLTEXT_INDEX, "REBUILD_FULLTEXT_INDEX"),
            (Self::STATS, "STATS"),
            (Self::DATA_BALANCE, "DATA_BALANCE"),
            (Self::DOWNLOAD, "DOWNLOAD"),
            (Self::INGEST, "INGEST"),
            (Self::LEADER_BALANCE, "LEADER_BALANCE"),
            (Self::ZONE_BALANCE, "ZONE_BALANCE"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "COMPACT",
            "FLUSH",
            "REBUILD_TAG_INDEX",
            "REBUILD_EDGE_INDEX",
            "REBUILD_FULLTEXT_INDEX",
            "STATS",
            "DATA_BALANCE",
            "DOWNLOAD",
            "INGEST",
            "LEADER_BALANCE",
            "ZONE_BALANCE",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::COMPACT,
            Self::FLUSH,
            Self::REBUILD_TAG_INDEX,
            Self::REBUILD_EDGE_INDEX,
            Self::REBUILD_FULLTEXT_INDEX,
            Self::STATS,
            Self::DATA_BALANCE,
            Self::DOWNLOAD,
            Self::INGEST,
            Self::LEADER_BALANCE,
            Self::ZONE_BALANCE,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for JobType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a JobType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a JobType) -> Self {
        x.0
    }
}

impl ::std::convert::From<JobType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: JobType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for JobType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for JobType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("COMPACT", 0),
            ("FLUSH", 1),
            ("REBUILD_TAG_INDEX", 2),
            ("REBUILD_EDGE_INDEX", 3),
            ("REBUILD_FULLTEXT_INDEX", 4),
            ("STATS", 5),
            ("DATA_BALANCE", 6),
            ("DOWNLOAD", 7),
            ("INGEST", 8),
            ("LEADER_BALANCE", 9),
            ("ZONE_BALANCE", 10),
            ("UNKNOWN", 99),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for JobType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "JobType::{}", self)
    }
}

impl ::std::str::FromStr for JobType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("COMPACT", 0),
            ("DATA_BALANCE", 6),
            ("DOWNLOAD", 7),
            ("FLUSH", 1),
            ("INGEST", 8),
            ("LEADER_BALANCE", 9),
            ("REBUILD_EDGE_INDEX", 3),
            ("REBUILD_FULLTEXT_INDEX", 4),
            ("REBUILD_TAG_INDEX", 2),
            ("STATS", 5),
            ("UNKNOWN", 99),
            ("ZONE_BALANCE", 10),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobType").map(Self)
    }
}

impl ::fbthrift::GetTType for JobType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for JobType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for JobType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct JobStatus(pub ::std::primitive::i32);

impl JobStatus {
    pub const QUEUE: Self = JobStatus(1i32);
    pub const RUNNING: Self = JobStatus(2i32);
    pub const FINISHED: Self = JobStatus(3i32);
    pub const FAILED: Self = JobStatus(4i32);
    pub const STOPPED: Self = JobStatus(5i32);
    pub const INVALID: Self = JobStatus(255i32);
}

impl ::fbthrift::ThriftEnum for JobStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::QUEUE, "QUEUE"),
            (Self::RUNNING, "RUNNING"),
            (Self::FINISHED, "FINISHED"),
            (Self::FAILED, "FAILED"),
            (Self::STOPPED, "STOPPED"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "QUEUE",
            "RUNNING",
            "FINISHED",
            "FAILED",
            "STOPPED",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::QUEUE,
            Self::RUNNING,
            Self::FINISHED,
            Self::FAILED,
            Self::STOPPED,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for JobStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for JobStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("FINISHED", 3),
            ("FAILED", 4),
            ("STOPPED", 5),
            ("INVALID", 255),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "JobStatus::{}", self)
    }
}

impl ::std::str::FromStr for JobStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 4),
            ("FINISHED", 3),
            ("INVALID", 255),
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("STOPPED", 5),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for JobStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ListHostType(pub ::std::primitive::i32);

impl ListHostType {
    pub const ALLOC: Self = ListHostType(0i32);
    pub const GRAPH: Self = ListHostType(1i32);
    pub const META: Self = ListHostType(2i32);
    pub const STORAGE: Self = ListHostType(3i32);
    pub const AGENT: Self = ListHostType(4i32);
}

impl ::fbthrift::ThriftEnum for ListHostType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ALLOC, "ALLOC"),
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
            (Self::AGENT, "AGENT"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ALLOC",
            "GRAPH",
            "META",
            "STORAGE",
            "AGENT",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ALLOC,
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
            Self::AGENT,
        ]
    }
}

impl ::std::default::Default for ListHostType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ListHostType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ListHostType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ListHostType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ListHostType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ListHostType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ListHostType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALLOC", 0),
            ("GRAPH", 1),
            ("META", 2),
            ("STORAGE", 3),
            ("AGENT", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ListHostType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ListHostType::{}", self)
    }
}

impl ::std::str::FromStr for ListHostType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("AGENT", 4),
            ("ALLOC", 0),
            ("GRAPH", 1),
            ("META", 2),
            ("STORAGE", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListHostType").map(Self)
    }
}

impl ::fbthrift::GetTType for ListHostType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ListHostType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ListHostType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct HostRole(pub ::std::primitive::i32);

impl HostRole {
    pub const GRAPH: Self = HostRole(0i32);
    pub const META: Self = HostRole(1i32);
    pub const STORAGE: Self = HostRole(2i32);
    pub const LISTENER: Self = HostRole(3i32);
    pub const AGENT: Self = HostRole(4i32);
    pub const UNKNOWN: Self = HostRole(5i32);
}

impl ::fbthrift::ThriftEnum for HostRole {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
            (Self::LISTENER, "LISTENER"),
            (Self::AGENT, "AGENT"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "GRAPH",
            "META",
            "STORAGE",
            "LISTENER",
            "AGENT",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
            Self::LISTENER,
            Self::AGENT,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for HostRole {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a HostRole> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a HostRole) -> Self {
        x.0
    }
}

impl ::std::convert::From<HostRole> for ::std::primitive::i32 {
    #[inline]
    fn from(x: HostRole) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for HostRole {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for HostRole {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("GRAPH", 0),
            ("META", 1),
            ("STORAGE", 2),
            ("LISTENER", 3),
            ("AGENT", 4),
            ("UNKNOWN", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for HostRole {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "HostRole::{}", self)
    }
}

impl ::std::str::FromStr for HostRole {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("AGENT", 4),
            ("GRAPH", 0),
            ("LISTENER", 3),
            ("META", 1),
            ("STORAGE", 2),
            ("UNKNOWN", 5),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostRole").map(Self)
    }
}

impl ::fbthrift::GetTType for HostRole {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for HostRole
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for HostRole
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct TaskResult(pub ::std::primitive::i32);

impl TaskResult {
    pub const SUCCEEDED: Self = TaskResult(0i32);
    pub const FAILED: Self = TaskResult(1i32);
    pub const IN_PROGRESS: Self = TaskResult(2i32);
    pub const INVALID: Self = TaskResult(3i32);
}

impl ::fbthrift::ThriftEnum for TaskResult {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::FAILED, "FAILED"),
            (Self::IN_PROGRESS, "IN_PROGRESS"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "FAILED",
            "IN_PROGRESS",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::FAILED,
            Self::IN_PROGRESS,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for TaskResult {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for TaskResult {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SUCCEEDED", 0),
            ("FAILED", 1),
            ("IN_PROGRESS", 2),
            ("INVALID", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "TaskResult::{}", self)
    }
}

impl ::std::str::FromStr for TaskResult {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 1),
            ("INVALID", 3),
            ("IN_PROGRESS", 2),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TaskResult").map(Self)
    }
}

impl ::fbthrift::GetTType for TaskResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigModule(pub ::std::primitive::i32);

impl ConfigModule {
    pub const UNKNOWN: Self = ConfigModule(0i32);
    pub const ALL: Self = ConfigModule(1i32);
    pub const GRAPH: Self = ConfigModule(2i32);
    pub const META: Self = ConfigModule(3i32);
    pub const STORAGE: Self = ConfigModule(4i32);
}

impl ::fbthrift::ThriftEnum for ConfigModule {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::ALL, "ALL"),
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "ALL",
            "GRAPH",
            "META",
            "STORAGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::ALL,
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
        ]
    }
}

impl ::std::default::Default for ConfigModule {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigModule {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigModule::{}", self)
    }
}

impl ::std::str::FromStr for ConfigModule {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
            ("UNKNOWN", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigModule").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigModule {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigMode(pub ::std::primitive::i32);

impl ConfigMode {
    pub const IMMUTABLE: Self = ConfigMode(0i32);
    pub const REBOOT: Self = ConfigMode(1i32);
    pub const MUTABLE: Self = ConfigMode(2i32);
    pub const IGNORED: Self = ConfigMode(3i32);
}

impl ::fbthrift::ThriftEnum for ConfigMode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::IMMUTABLE, "IMMUTABLE"),
            (Self::REBOOT, "REBOOT"),
            (Self::MUTABLE, "MUTABLE"),
            (Self::IGNORED, "IGNORED"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "IMMUTABLE",
            "REBOOT",
            "MUTABLE",
            "IGNORED",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::IMMUTABLE,
            Self::REBOOT,
            Self::MUTABLE,
            Self::IGNORED,
        ]
    }
}

impl ::std::default::Default for ConfigMode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigMode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IMMUTABLE", 0),
            ("REBOOT", 1),
            ("MUTABLE", 2),
            ("IGNORED", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigMode::{}", self)
    }
}

impl ::std::str::FromStr for ConfigMode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IGNORED", 3),
            ("IMMUTABLE", 0),
            ("MUTABLE", 2),
            ("REBOOT", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigMode").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigMode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ListenerType(pub ::std::primitive::i32);

impl ListenerType {
    pub const UNKNOWN: Self = ListenerType(0i32);
    pub const ELASTICSEARCH: Self = ListenerType(1i32);
}

impl ::fbthrift::ThriftEnum for ListenerType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::ELASTICSEARCH, "ELASTICSEARCH"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "ELASTICSEARCH",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::ELASTICSEARCH,
        ]
    }
}

impl ::std::default::Default for ListenerType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ListenerType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ListenerType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ListenerType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ListenerType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ListenerType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ListenerType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ListenerType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ListenerType::{}", self)
    }
}

impl ::std::str::FromStr for ListenerType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
            ("UNKNOWN", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListenerType").map(Self)
    }
}

impl ::fbthrift::GetTType for ListenerType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ListenerType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ListenerType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ExternalServiceType(pub ::std::primitive::i32);

impl ExternalServiceType {
    pub const ELASTICSEARCH: Self = ExternalServiceType(1i32);
}

impl ::fbthrift::ThriftEnum for ExternalServiceType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ELASTICSEARCH, "ELASTICSEARCH"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ELASTICSEARCH",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ELASTICSEARCH,
        ]
    }
}

impl ::std::default::Default for ExternalServiceType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ExternalServiceType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ExternalServiceType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ExternalServiceType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ExternalServiceType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ExternalServiceType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ExternalServiceType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ExternalServiceType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ExternalServiceType::{}", self)
    }
}

impl ::std::str::FromStr for ExternalServiceType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ExternalServiceType").map(Self)
    }
}

impl ::fbthrift::GetTType for ExternalServiceType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ExternalServiceType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ExternalServiceType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct QueryStatus(pub ::std::primitive::i32);

impl QueryStatus {
    pub const RUNNING: Self = QueryStatus(1i32);
    pub const KILLING: Self = QueryStatus(2i32);
}

impl ::fbthrift::ThriftEnum for QueryStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::RUNNING, "RUNNING"),
            (Self::KILLING, "KILLING"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "RUNNING",
            "KILLING",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::RUNNING,
            Self::KILLING,
        ]
    }
}

impl ::std::default::Default for QueryStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a QueryStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a QueryStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<QueryStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: QueryStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for QueryStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for QueryStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("RUNNING", 1),
            ("KILLING", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for QueryStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "QueryStatus::{}", self)
    }
}

impl ::std::str::FromStr for QueryStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("KILLING", 2),
            ("RUNNING", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "QueryStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for QueryStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for QueryStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for QueryStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}




impl ::std::default::Default for ID {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for ID {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for ID
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ID");
        match self {
            Self::space_id(inner) => {
                p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::index_id(inner) => {
                p.write_field_begin("index_id", ::fbthrift::TType::I32, 4);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::cluster_id(inner) => {
                p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 5);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for ID
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 2),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::space_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 4, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::index_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I64, 5, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::cluster_id(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "ID",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ColumnTypeDef {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            type_length: ::std::option::Option::Some(0),
            geo_shape: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ColumnTypeDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ColumnTypeDef")
            .field("r#type", &self.r#type)
            .field("type_length", &self.type_length)
            .field("geo_shape", &self.geo_shape)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ColumnTypeDef {}
unsafe impl ::std::marker::Sync for self::ColumnTypeDef {}

impl ::fbthrift::GetTType for self::ColumnTypeDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ColumnTypeDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ColumnTypeDef");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.type_length {
            p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.geo_shape {
            p.write_field_begin("geo_shape", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ColumnTypeDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("geo_shape", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_type_length = ::std::option::Option::None;
        let mut field_geo_shape = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_geo_shape = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            type_length: field_type_length,
            geo_shape: field_geo_shape,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ColumnDef {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            default_value: ::std::option::Option::None,
            nullable: ::std::option::Option::Some(false),
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ColumnDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ColumnDef")
            .field("name", &self.name)
            .field("r#type", &self.r#type)
            .field("default_value", &self.default_value)
            .field("nullable", &self.nullable)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ColumnDef {}
unsafe impl ::std::marker::Sync for self::ColumnDef {}

impl ::fbthrift::GetTType for self::ColumnDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ColumnDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ColumnDef");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.default_value {
            p.write_field_begin("default_value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.nullable {
            p.write_field_begin("nullable", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ColumnDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("default_value", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("nullable", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_default_value = ::std::option::Option::None;
        let mut field_nullable = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_default_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_nullable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            default_value: field_default_value,
            nullable: field_nullable,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SchemaProp {
    fn default() -> Self {
        Self {
            ttl_duration: ::std::option::Option::None,
            ttl_col: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SchemaProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SchemaProp")
            .field("ttl_duration", &self.ttl_duration)
            .field("ttl_col", &self.ttl_col)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SchemaProp {}
unsafe impl ::std::marker::Sync for self::SchemaProp {}

impl ::fbthrift::GetTType for self::SchemaProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SchemaProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SchemaProp");
        if let ::std::option::Option::Some(some) = &self.ttl_duration {
            p.write_field_begin("ttl_duration", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.ttl_col {
            p.write_field_begin("ttl_col", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SchemaProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("ttl_col", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("ttl_duration", ::fbthrift::TType::I64, 1),
        ];
        let mut field_ttl_duration = ::std::option::Option::None;
        let mut field_ttl_col = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_ttl_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_ttl_col = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            ttl_duration: field_ttl_duration,
            ttl_col: field_ttl_col,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Schema {
    fn default() -> Self {
        Self {
            columns: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Schema {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Schema")
            .field("columns", &self.columns)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Schema {}
unsafe impl ::std::marker::Sync for self::Schema {}

impl ::fbthrift::GetTType for self::Schema {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Schema
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Schema");
        p.write_field_begin("columns", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.columns, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Schema
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("columns", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_columns = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            columns: field_columns.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IdName {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IdName {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IdName")
            .field("id", &self.id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IdName {}
unsafe impl ::std::marker::Sync for self::IdName {}

impl ::fbthrift::GetTType for self::IdName {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IdName");
        p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceDesc {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            partition_num: 0,
            replica_factor: 0,
            charset_name: ::std::default::Default::default(),
            collate_name: ::std::default::Default::default(),
            vid_type: crate::types::ColumnTypeDef {
                    r#type: common::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                    geo_shape: ::std::default::Default::default(),
                    ..::std::default::Default::default()
                },
            zone_names: ::std::default::Default::default(),
            isolation_level: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceDesc")
            .field("space_name", &self.space_name)
            .field("partition_num", &self.partition_num)
            .field("replica_factor", &self.replica_factor)
            .field("charset_name", &self.charset_name)
            .field("collate_name", &self.collate_name)
            .field("vid_type", &self.vid_type)
            .field("zone_names", &self.zone_names)
            .field("isolation_level", &self.isolation_level)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceDesc {}
unsafe impl ::std::marker::Sync for self::SpaceDesc {}

impl ::fbthrift::GetTType for self::SpaceDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceDesc");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("partition_num", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.partition_num, p);
        p.write_field_end();
        p.write_field_begin("replica_factor", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.replica_factor, p);
        p.write_field_end();
        p.write_field_begin("charset_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.charset_name, p);
        p.write_field_end();
        p.write_field_begin("collate_name", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.collate_name, p);
        p.write_field_end();
        p.write_field_begin("vid_type", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.vid_type, p);
        p.write_field_end();
        p.write_field_begin("zone_names", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.zone_names, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.isolation_level {
            p.write_field_begin("isolation_level", ::fbthrift::TType::I32, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("charset_name", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("collate_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 9),
            ::fbthrift::Field::new("isolation_level", ::fbthrift::TType::I32, 8),
            ::fbthrift::Field::new("partition_num", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("replica_factor", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("vid_type", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 7),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_partition_num = ::std::option::Option::None;
        let mut field_replica_factor = ::std::option::Option::None;
        let mut field_charset_name = ::std::option::Option::None;
        let mut field_collate_name = ::std::option::Option::None;
        let mut field_vid_type = ::std::option::Option::None;
        let mut field_zone_names = ::std::option::Option::None;
        let mut field_isolation_level = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_partition_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_replica_factor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_charset_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_collate_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_vid_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 8) => field_isolation_level = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 9) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            partition_num: field_partition_num.unwrap_or(0),
            replica_factor: field_replica_factor.unwrap_or(0),
            charset_name: field_charset_name.unwrap_or_default(),
            collate_name: field_collate_name.unwrap_or_default(),
            vid_type: field_vid_type.unwrap_or_else(|| crate::types::ColumnTypeDef {
                    r#type: common::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                    geo_shape: ::std::default::Default::default(),
                    ..::std::default::Default::default()
                }),
            zone_names: field_zone_names.unwrap_or_default(),
            isolation_level: field_isolation_level,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceItem {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            properties: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceItem")
            .field("space_id", &self.space_id)
            .field("properties", &self.properties)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceItem {}
unsafe impl ::std::marker::Sync for self::SpaceItem {}

impl ::fbthrift::GetTType for self::SpaceItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceItem");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_properties = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            properties: field_properties.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TagItem {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TagItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TagItem")
            .field("tag_id", &self.tag_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TagItem {}
unsafe impl ::std::marker::Sync for self::TagItem {}

impl ::fbthrift::GetTType for self::TagItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TagItem");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterSchemaItem {
    fn default() -> Self {
        Self {
            op: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterSchemaItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterSchemaItem")
            .field("op", &self.op)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterSchemaItem {}
unsafe impl ::std::marker::Sync for self::AlterSchemaItem {}

impl ::fbthrift::GetTType for self::AlterSchemaItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterSchemaItem");
        p.write_field_begin("op", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_op = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            op: field_op.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeItem {
    fn default() -> Self {
        Self {
            edge_type: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeItem")
            .field("edge_type", &self.edge_type)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeItem {}
unsafe impl ::std::marker::Sync for self::EdgeItem {}

impl ::fbthrift::GetTType for self::EdgeItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeItem");
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            edge_type: field_edge_type.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexParams {
    fn default() -> Self {
        Self {
            s2_max_level: ::std::option::Option::None,
            s2_max_cells: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexParams {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexParams")
            .field("s2_max_level", &self.s2_max_level)
            .field("s2_max_cells", &self.s2_max_cells)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexParams {}
unsafe impl ::std::marker::Sync for self::IndexParams {}

impl ::fbthrift::GetTType for self::IndexParams {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexParams
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexParams");
        if let ::std::option::Option::Some(some) = &self.s2_max_level {
            p.write_field_begin("s2_max_level", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.s2_max_cells {
            p.write_field_begin("s2_max_cells", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexParams
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("s2_max_cells", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("s2_max_level", ::fbthrift::TType::I32, 1),
        ];
        let mut field_s2_max_level = ::std::option::Option::None;
        let mut field_s2_max_cells = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_s2_max_level = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_s2_max_cells = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            s2_max_level: field_s2_max_level,
            s2_max_cells: field_s2_max_cells,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexItem {
    fn default() -> Self {
        Self {
            index_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            schema_id: ::std::default::Default::default(),
            schema_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            index_params: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexItem")
            .field("index_id", &self.index_id)
            .field("index_name", &self.index_name)
            .field("schema_id", &self.schema_id)
            .field("schema_name", &self.schema_name)
            .field("fields", &self.fields)
            .field("comment", &self.comment)
            .field("index_params", &self.index_params)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexItem {}
unsafe impl ::std::marker::Sync for self::IndexItem {}

impl ::fbthrift::GetTType for self::IndexItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexItem");
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("schema_id", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema_id, p);
        p.write_field_end();
        p.write_field_begin("schema_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.schema_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.index_params {
            p.write_field_begin("index_params", ::fbthrift::TType::Struct, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("index_params", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("schema_id", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("schema_name", ::fbthrift::TType::String, 4),
        ];
        let mut field_index_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_schema_id = ::std::option::Option::None;
        let mut field_schema_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let mut field_index_params = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_schema_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_index_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            index_id: field_index_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            schema_id: field_schema_id.unwrap_or_default(),
            schema_name: field_schema_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            comment: field_comment,
            index_params: field_index_params,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostItem {
    fn default() -> Self {
        Self {
            hostAddr: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            leader_parts: ::std::default::Default::default(),
            all_parts: ::std::default::Default::default(),
            role: ::std::default::Default::default(),
            git_info_sha: ::std::default::Default::default(),
            zone_name: ::std::option::Option::None,
            version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostItem")
            .field("hostAddr", &self.hostAddr)
            .field("status", &self.status)
            .field("leader_parts", &self.leader_parts)
            .field("all_parts", &self.all_parts)
            .field("role", &self.role)
            .field("git_info_sha", &self.git_info_sha)
            .field("zone_name", &self.zone_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostItem {}
unsafe impl ::std::marker::Sync for self::HostItem {}

impl ::fbthrift::GetTType for self::HostItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostItem");
        p.write_field_begin("hostAddr", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.hostAddr, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.leader_parts, p);
        p.write_field_end();
        p.write_field_begin("all_parts", ::fbthrift::TType::Map, 4);
        ::fbthrift::Serialize::write(&self.all_parts, p);
        p.write_field_end();
        p.write_field_begin("role", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.git_info_sha, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.zone_name {
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.version {
            p.write_field_begin("version", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_parts", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("hostAddr", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 7),
        ];
        let mut field_hostAddr = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_leader_parts = ::std::option::Option::None;
        let mut field_all_parts = ::std::option::Option::None;
        let mut field_role = ::std::option::Option::None;
        let mut field_git_info_sha = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_hostAddr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_all_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hostAddr: field_hostAddr.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            leader_parts: field_leader_parts.unwrap_or_default(),
            all_parts: field_all_parts.unwrap_or_default(),
            role: field_role.unwrap_or_default(),
            git_info_sha: field_git_info_sha.unwrap_or_default(),
            zone_name: field_zone_name,
            version: field_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UserItem {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            is_lock: ::std::default::Default::default(),
            max_queries_per_hour: ::std::default::Default::default(),
            max_updates_per_hour: ::std::default::Default::default(),
            max_connections_per_hour: ::std::default::Default::default(),
            max_user_connections: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UserItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UserItem")
            .field("account", &self.account)
            .field("is_lock", &self.is_lock)
            .field("max_queries_per_hour", &self.max_queries_per_hour)
            .field("max_updates_per_hour", &self.max_updates_per_hour)
            .field("max_connections_per_hour", &self.max_connections_per_hour)
            .field("max_user_connections", &self.max_user_connections)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UserItem {}
unsafe impl ::std::marker::Sync for self::UserItem {}

impl ::fbthrift::GetTType for self::UserItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UserItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UserItem");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("is_lock", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.is_lock, p);
        p.write_field_end();
        p.write_field_begin("max_queries_per_hour", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.max_queries_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_updates_per_hour", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.max_updates_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_connections_per_hour", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.max_connections_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_user_connections", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.max_user_connections, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UserItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("is_lock", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("max_connections_per_hour", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("max_queries_per_hour", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("max_updates_per_hour", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("max_user_connections", ::fbthrift::TType::I32, 6),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_is_lock = ::std::option::Option::None;
        let mut field_max_queries_per_hour = ::std::option::Option::None;
        let mut field_max_updates_per_hour = ::std::option::Option::None;
        let mut field_max_connections_per_hour = ::std::option::Option::None;
        let mut field_max_user_connections = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_is_lock = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_max_queries_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_max_updates_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_max_connections_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_max_user_connections = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            is_lock: field_is_lock.unwrap_or_default(),
            max_queries_per_hour: field_max_queries_per_hour.unwrap_or_default(),
            max_updates_per_hour: field_max_updates_per_hour.unwrap_or_default(),
            max_connections_per_hour: field_max_connections_per_hour.unwrap_or_default(),
            max_user_connections: field_max_user_connections.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RoleItem {
    fn default() -> Self {
        Self {
            user_id: ::std::default::Default::default(),
            space_id: ::std::default::Default::default(),
            role_type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RoleItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RoleItem")
            .field("user_id", &self.user_id)
            .field("space_id", &self.space_id)
            .field("role_type", &self.role_type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RoleItem {}
unsafe impl ::std::marker::Sync for self::RoleItem {}

impl ::fbthrift::GetTType for self::RoleItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RoleItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RoleItem");
        p.write_field_begin("user_id", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.user_id, p);
        p.write_field_end();
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("role_type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.role_type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RoleItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("user_id", ::fbthrift::TType::String, 1),
        ];
        let mut field_user_id = ::std::option::Option::None;
        let mut field_space_id = ::std::option::Option::None;
        let mut field_role_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_user_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_role_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            user_id: field_user_id.unwrap_or_default(),
            space_id: field_space_id.unwrap_or_default(),
            role_type: field_role_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecResp")
            .field("code", &self.code)
            .field("id", &self.id)
            .field("leader", &self.leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecResp {}
unsafe impl ::std::marker::Sync for self::ExecResp {}

impl ::fbthrift::GetTType for self::ExecResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            op: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterSpaceReq")
            .field("space_name", &self.space_name)
            .field("op", &self.op)
            .field("paras", &self.paras)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterSpaceReq {}
unsafe impl ::std::marker::Sync for self::AlterSpaceReq {}

impl ::fbthrift::GetTType for self::AlterSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("op", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_op = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            op: field_op.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            op: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobReq")
            .field("space_id", &self.space_id)
            .field("op", &self.op)
            .field("r#type", &self.r#type)
            .field("paras", &self.paras)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobReq {}
unsafe impl ::std::marker::Sync for self::AdminJobReq {}

impl ::fbthrift::GetTType for self::AdminJobReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("op", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_op = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            op: field_op.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::JobDesc {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::JobDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("JobDesc")
            .field("space_id", &self.space_id)
            .field("job_id", &self.job_id)
            .field("r#type", &self.r#type)
            .field("paras", &self.paras)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::JobDesc {}
unsafe impl ::std::marker::Sync for self::JobDesc {}

impl ::fbthrift::GetTType for self::JobDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("JobDesc");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_begin("code", ::fbthrift::TType::I32, 8);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 8),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 8) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TaskDesc {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            task_id: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TaskDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TaskDesc")
            .field("space_id", &self.space_id)
            .field("job_id", &self.job_id)
            .field("task_id", &self.task_id)
            .field("host", &self.host)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .field("code", &self.code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TaskDesc {}
unsafe impl ::std::marker::Sync for self::TaskDesc {}

impl ::fbthrift::GetTType for self::TaskDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TaskDesc");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_begin("code", ::fbthrift::TType::I32, 8);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 8),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let mut field_task_id = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let mut field_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 8) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            task_id: field_task_id.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            code: field_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResult {
    fn default() -> Self {
        Self {
            job_id: ::std::option::Option::None,
            job_desc: ::std::option::Option::None,
            task_desc: ::std::option::Option::None,
            recovered_job_num: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResult {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResult")
            .field("job_id", &self.job_id)
            .field("job_desc", &self.job_desc)
            .field("task_desc", &self.task_desc)
            .field("recovered_job_num", &self.recovered_job_num)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResult {}
unsafe impl ::std::marker::Sync for self::AdminJobResult {}

impl ::fbthrift::GetTType for self::AdminJobResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResult");
        if let ::std::option::Option::Some(some) = &self.job_id {
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.job_desc {
            p.write_field_begin("job_desc", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.task_desc {
            p.write_field_begin("task_desc", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.recovered_job_num {
            p.write_field_begin("recovered_job_num", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("job_desc", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("recovered_job_num", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("task_desc", ::fbthrift::TType::List, 3),
        ];
        let mut field_job_id = ::std::option::Option::None;
        let mut field_job_desc = ::std::option::Option::None;
        let mut field_task_desc = ::std::option::Option::None;
        let mut field_recovered_job_num = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_job_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_task_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_recovered_job_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            job_id: field_job_id,
            job_desc: field_job_desc,
            task_desc: field_task_desc,
            recovered_job_num: field_recovered_job_num,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResp {}
unsafe impl ::std::marker::Sync for self::AdminJobResp {}

impl ::fbthrift::GetTType for self::AdminJobResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Correlativity {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            proportion: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Correlativity {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Correlativity")
            .field("part_id", &self.part_id)
            .field("proportion", &self.proportion)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Correlativity {}
unsafe impl ::std::marker::Sync for self::Correlativity {}

impl ::fbthrift::GetTType for self::Correlativity {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Correlativity
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Correlativity");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("proportion", ::fbthrift::TType::Double, 2);
        ::fbthrift::Serialize::write(&self.proportion, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Correlativity
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("proportion", ::fbthrift::TType::Double, 2),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_proportion = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 2) => field_proportion = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            proportion: field_proportion.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::StatsItem {
    fn default() -> Self {
        Self {
            tag_vertices: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            space_vertices: ::std::default::Default::default(),
            space_edges: ::std::default::Default::default(),
            positive_part_correlativity: ::std::default::Default::default(),
            negative_part_correlativity: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::StatsItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("StatsItem")
            .field("tag_vertices", &self.tag_vertices)
            .field("edges", &self.edges)
            .field("space_vertices", &self.space_vertices)
            .field("space_edges", &self.space_edges)
            .field("positive_part_correlativity", &self.positive_part_correlativity)
            .field("negative_part_correlativity", &self.negative_part_correlativity)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::StatsItem {}
unsafe impl ::std::marker::Sync for self::StatsItem {}

impl ::fbthrift::GetTType for self::StatsItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::StatsItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("StatsItem");
        p.write_field_begin("tag_vertices", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.tag_vertices, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_begin("space_vertices", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.space_vertices, p);
        p.write_field_end();
        p.write_field_begin("space_edges", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.space_edges, p);
        p.write_field_end();
        p.write_field_begin("positive_part_correlativity", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.positive_part_correlativity, p);
        p.write_field_end();
        p.write_field_begin("negative_part_correlativity", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.negative_part_correlativity, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::StatsItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edges", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("negative_part_correlativity", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("positive_part_correlativity", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("space_edges", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("space_vertices", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("tag_vertices", ::fbthrift::TType::Map, 1),
        ];
        let mut field_tag_vertices = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let mut field_space_vertices = ::std::option::Option::None;
        let mut field_space_edges = ::std::option::Option::None;
        let mut field_positive_part_correlativity = ::std::option::Option::None;
        let mut field_negative_part_correlativity = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_tag_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_space_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_space_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_positive_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_negative_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_vertices: field_tag_vertices.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            space_vertices: field_space_vertices.unwrap_or_default(),
            space_edges: field_space_edges.unwrap_or_default(),
            positive_part_correlativity: field_positive_part_correlativity.unwrap_or_default(),
            negative_part_correlativity: field_negative_part_correlativity.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSpaceReq {
    fn default() -> Self {
        Self {
            properties: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSpaceReq")
            .field("properties", &self.properties)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSpaceReq {}
unsafe impl ::std::marker::Sync for self::CreateSpaceReq {}

impl ::fbthrift::GetTType for self::CreateSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSpaceReq");
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_properties = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            properties: field_properties.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSpaceAsReq {
    fn default() -> Self {
        Self {
            old_space_name: ::std::default::Default::default(),
            new_space_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSpaceAsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSpaceAsReq")
            .field("old_space_name", &self.old_space_name)
            .field("new_space_name", &self.new_space_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSpaceAsReq {}
unsafe impl ::std::marker::Sync for self::CreateSpaceAsReq {}

impl ::fbthrift::GetTType for self::CreateSpaceAsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceAsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSpaceAsReq");
        p.write_field_begin("old_space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.old_space_name, p);
        p.write_field_end();
        p.write_field_begin("new_space_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.new_space_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceAsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("new_space_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("old_space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_old_space_name = ::std::option::Option::None;
        let mut field_new_space_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_old_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_new_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            old_space_name: field_old_space_name.unwrap_or_default(),
            new_space_name: field_new_space_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSpaceReq")
            .field("space_name", &self.space_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSpaceReq {}
unsafe impl ::std::marker::Sync for self::DropSpaceReq {}

impl ::fbthrift::GetTType for self::DropSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ClearSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ClearSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ClearSpaceReq")
            .field("space_name", &self.space_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ClearSpaceReq {}
unsafe impl ::std::marker::Sync for self::ClearSpaceReq {}

impl ::fbthrift::GetTType for self::ClearSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ClearSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ClearSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ClearSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesReq {}
unsafe impl ::std::marker::Sync for self::ListSpacesReq {}

impl ::fbthrift::GetTType for self::ListSpacesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            spaces: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("spaces", &self.spaces)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesResp {}
unsafe impl ::std::marker::Sync for self::ListSpacesResp {}

impl ::fbthrift::GetTType for self::ListSpacesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("spaces", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.spaces, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_spaces = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            spaces: field_spaces.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceReq")
            .field("space_name", &self.space_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceReq {}
unsafe impl ::std::marker::Sync for self::GetSpaceReq {}

impl ::fbthrift::GetTType for self::GetSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceResp {}
unsafe impl ::std::marker::Sync for self::GetSpaceResp {}

impl ::fbthrift::GetTType for self::GetSpaceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagReq {}
unsafe impl ::std::marker::Sync for self::CreateTagReq {}

impl ::fbthrift::GetTType for self::CreateTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            tag_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("tag_items", &self.tag_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterTagReq {}
unsafe impl ::std::marker::Sync for self::AlterTagReq {}

impl ::fbthrift::GetTType for self::AlterTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("tag_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tag_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_tag_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tag_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            tag_items: field_tag_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagReq {}
unsafe impl ::std::marker::Sync for self::DropTagReq {}

impl ::fbthrift::GetTType for self::DropTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsReq {}
unsafe impl ::std::marker::Sync for self::ListTagsReq {}

impl ::fbthrift::GetTType for self::ListTagsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsResp {}
unsafe impl ::std::marker::Sync for self::ListTagsResp {}

impl ::fbthrift::GetTType for self::ListTagsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagReq {}
unsafe impl ::std::marker::Sync for self::GetTagReq {}

impl ::fbthrift::GetTType for self::GetTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagResp {}
unsafe impl ::std::marker::Sync for self::GetTagResp {}

impl ::fbthrift::GetTType for self::GetTagResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeReq {}

impl ::fbthrift::GetTType for self::CreateEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            edge_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("edge_items", &self.edge_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterEdgeReq {}
unsafe impl ::std::marker::Sync for self::AlterEdgeReq {}

impl ::fbthrift::GetTType for self::AlterEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("edge_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_edge_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            edge_items: field_edge_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeReq {}

impl ::fbthrift::GetTType for self::GetEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeResp {}

impl ::fbthrift::GetTType for self::GetEdgeResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeReq {}

impl ::fbthrift::GetTType for self::DropEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgesReq {}

impl ::fbthrift::GetTType for self::ListEdgesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("edges", &self.edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgesResp {}

impl ::fbthrift::GetTType for self::ListEdgesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddHostsReq {
    fn default() -> Self {
        Self {
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddHostsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddHostsReq")
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddHostsReq {}
unsafe impl ::std::marker::Sync for self::AddHostsReq {}

impl ::fbthrift::GetTType for self::AddHostsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddHostsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddHostsReq");
        p.write_field_begin("hosts", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddHostsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 1),
        ];
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropHostsReq {
    fn default() -> Self {
        Self {
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropHostsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropHostsReq")
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropHostsReq {}
unsafe impl ::std::marker::Sync for self::DropHostsReq {}

impl ::fbthrift::GetTType for self::DropHostsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropHostsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropHostsReq");
        p.write_field_begin("hosts", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropHostsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 1),
        ];
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsReq")
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsReq {}
unsafe impl ::std::marker::Sync for self::ListHostsReq {}

impl ::fbthrift::GetTType for self::ListHostsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsResp {}
unsafe impl ::std::marker::Sync for self::ListHostsResp {}

impl ::fbthrift::GetTType for self::ListHostsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartItem {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            leader: ::std::option::Option::None,
            peers: ::std::default::Default::default(),
            losts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartItem")
            .field("part_id", &self.part_id)
            .field("leader", &self.leader)
            .field("peers", &self.peers)
            .field("losts", &self.losts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartItem {}
unsafe impl ::std::marker::Sync for self::PartItem {}

impl ::fbthrift::GetTType for self::PartItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartItem");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader {
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("peers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_begin("losts", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.losts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("losts", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let mut field_losts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_losts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            leader: field_leader,
            peers: field_peers.unwrap_or_default(),
            losts: field_losts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_ids: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsReq")
            .field("space_id", &self.space_id)
            .field("part_ids", &self.part_ids)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsReq {}
unsafe impl ::std::marker::Sync for self::ListPartsReq {}

impl ::fbthrift::GetTType for self::ListPartsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_ids", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.part_ids, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_ids", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_ids = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_part_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_ids: field_part_ids.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsResp {}
unsafe impl ::std::marker::Sync for self::ListPartsResp {}

impl ::fbthrift::GetTType for self::ListPartsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocReq {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocReq {}

impl ::fbthrift::GetTType for self::GetPartsAllocReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            terms: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .field("terms", &self.terms)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocResp {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocResp {}

impl ::fbthrift::GetTType for self::GetPartsAllocResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.terms {
            p.write_field_begin("terms", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("terms", ::fbthrift::TType::Map, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_terms = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_terms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            terms: field_terms,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetWorkerIdReq {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetWorkerIdReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetWorkerIdReq")
            .field("host", &self.host)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetWorkerIdReq {}
unsafe impl ::std::marker::Sync for self::GetWorkerIdReq {}

impl ::fbthrift::GetTType for self::GetWorkerIdReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetWorkerIdReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetWorkerIdReq");
        p.write_field_begin("host", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetWorkerIdReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::String, 1),
        ];
        let mut field_host = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetWorkerIdResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            workerid: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetWorkerIdResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetWorkerIdResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("workerid", &self.workerid)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetWorkerIdResp {}
unsafe impl ::std::marker::Sync for self::GetWorkerIdResp {}

impl ::fbthrift::GetTType for self::GetWorkerIdResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetWorkerIdResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetWorkerIdResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("workerid", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.workerid, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetWorkerIdResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("workerid", ::fbthrift::TType::I64, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_workerid = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_workerid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            workerid: field_workerid.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSegmentIdReq {
    fn default() -> Self {
        Self {
            length: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSegmentIdReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSegmentIdReq")
            .field("length", &self.length)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSegmentIdReq {}
unsafe impl ::std::marker::Sync for self::GetSegmentIdReq {}

impl ::fbthrift::GetTType for self::GetSegmentIdReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSegmentIdReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSegmentIdReq");
        p.write_field_begin("length", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.length, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSegmentIdReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("length", ::fbthrift::TType::I64, 1),
        ];
        let mut field_length = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            length: field_length.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSegmentIdResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            segment_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSegmentIdResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSegmentIdResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("segment_id", &self.segment_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSegmentIdResp {}
unsafe impl ::std::marker::Sync for self::GetSegmentIdResp {}

impl ::fbthrift::GetTType for self::GetSegmentIdResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSegmentIdResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSegmentIdResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("segment_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.segment_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSegmentIdResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("segment_id", ::fbthrift::TType::I64, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_segment_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_segment_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            segment_id: field_segment_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            last_update_time_in_ms: ::std::default::Default::default(),
            meta_version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("cluster_id", &self.cluster_id)
            .field("last_update_time_in_ms", &self.last_update_time_in_ms)
            .field("meta_version", &self.meta_version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBResp {}
unsafe impl ::std::marker::Sync for self::HBResp {}

impl ::fbthrift::GetTType for self::HBResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        p.write_field_begin("last_update_time_in_ms", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.last_update_time_in_ms, p);
        p.write_field_end();
        p.write_field_begin("meta_version", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.meta_version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_update_time_in_ms", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("meta_version", ::fbthrift::TType::I32, 5),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_last_update_time_in_ms = ::std::option::Option::None;
        let mut field_meta_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_last_update_time_in_ms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_meta_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            last_update_time_in_ms: field_last_update_time_in_ms.unwrap_or_default(),
            meta_version: field_meta_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LeaderInfo {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LeaderInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LeaderInfo")
            .field("part_id", &self.part_id)
            .field("term", &self.term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LeaderInfo {}
unsafe impl ::std::marker::Sync for self::LeaderInfo {}

impl ::fbthrift::GetTType for self::LeaderInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LeaderInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LeaderInfo");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LeaderInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 2),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartitionList {
    fn default() -> Self {
        Self {
            part_list: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartitionList {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartitionList")
            .field("part_list", &self.part_list)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartitionList {}
unsafe impl ::std::marker::Sync for self::PartitionList {}

impl ::fbthrift::GetTType for self::PartitionList {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartitionList
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartitionList");
        p.write_field_begin("part_list", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.part_list, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartitionList
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_list", ::fbthrift::TType::List, 1),
        ];
        let mut field_part_list = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_part_list = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_list: field_part_list.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBReq {
    fn default() -> Self {
        Self {
            role: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            leader_partIds: ::std::option::Option::None,
            git_info_sha: ::std::default::Default::default(),
            disk_parts: ::std::option::Option::None,
            dir: ::std::option::Option::None,
            version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBReq")
            .field("role", &self.role)
            .field("host", &self.host)
            .field("cluster_id", &self.cluster_id)
            .field("leader_partIds", &self.leader_partIds)
            .field("git_info_sha", &self.git_info_sha)
            .field("disk_parts", &self.disk_parts)
            .field("dir", &self.dir)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBReq {}
unsafe impl ::std::marker::Sync for self::HBReq {}

impl ::fbthrift::GetTType for self::HBReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBReq");
        p.write_field_begin("role", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader_partIds {
            p.write_field_begin("leader_partIds", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.git_info_sha, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.disk_parts {
            p.write_field_begin("disk_parts", ::fbthrift::TType::Map, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.dir {
            p.write_field_begin("dir", ::fbthrift::TType::Struct, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.version {
            p.write_field_begin("version", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("disk_parts", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("leader_partIds", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 8),
        ];
        let mut field_role = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_leader_partIds = ::std::option::Option::None;
        let mut field_git_info_sha = ::std::option::Option::None;
        let mut field_disk_parts = ::std::option::Option::None;
        let mut field_dir = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_leader_partIds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_disk_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role: field_role.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            leader_partIds: field_leader_partIds,
            git_info_sha: field_git_info_sha.unwrap_or_default(),
            disk_parts: field_disk_parts,
            dir: field_dir,
            version: field_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ServiceInfo {
    fn default() -> Self {
        Self {
            dir: ::std::default::Default::default(),
            addr: ::std::default::Default::default(),
            role: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ServiceInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ServiceInfo")
            .field("dir", &self.dir)
            .field("addr", &self.addr)
            .field("role", &self.role)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ServiceInfo {}
unsafe impl ::std::marker::Sync for self::ServiceInfo {}

impl ::fbthrift::GetTType for self::ServiceInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ServiceInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ServiceInfo");
        p.write_field_begin("dir", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.dir, p);
        p.write_field_end();
        p.write_field_begin("addr", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.addr, p);
        p.write_field_end();
        p.write_field_begin("role", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ServiceInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("addr", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 3),
        ];
        let mut field_dir = ::std::option::Option::None;
        let mut field_addr = ::std::option::Option::None;
        let mut field_role = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            dir: field_dir.unwrap_or_default(),
            addr: field_addr.unwrap_or_default(),
            role: field_role.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AgentHBReq {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            git_info_sha: ::std::default::Default::default(),
            version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AgentHBReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AgentHBReq")
            .field("host", &self.host)
            .field("git_info_sha", &self.git_info_sha)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AgentHBReq {}
unsafe impl ::std::marker::Sync for self::AgentHBReq {}

impl ::fbthrift::GetTType for self::AgentHBReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AgentHBReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AgentHBReq");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.git_info_sha, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.version {
            p.write_field_begin("version", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AgentHBReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 3),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_git_info_sha = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            git_info_sha: field_git_info_sha.unwrap_or_default(),
            version: field_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AgentHBResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            service_list: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AgentHBResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AgentHBResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("service_list", &self.service_list)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AgentHBResp {}
unsafe impl ::std::marker::Sync for self::AgentHBResp {}

impl ::fbthrift::GetTType for self::AgentHBResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AgentHBResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AgentHBResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("service_list", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.service_list, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AgentHBResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("service_list", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_service_list = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_service_list = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            service_list: field_service_list.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexFieldDef {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            type_length: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexFieldDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexFieldDef")
            .field("name", &self.name)
            .field("type_length", &self.type_length)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexFieldDef {}
unsafe impl ::std::marker::Sync for self::IndexFieldDef {}

impl ::fbthrift::GetTType for self::IndexFieldDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexFieldDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexFieldDef");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.type_length {
            p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexFieldDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_type_length = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            type_length: field_type_length,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            index_params: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("tag_name", &self.tag_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .field("comment", &self.comment)
            .field("index_params", &self.index_params)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateTagIndexReq {}

impl ::fbthrift::GetTType for self::CreateTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.index_params {
            p.write_field_begin("index_params", ::fbthrift::TType::Struct, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("index_params", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let mut field_index_params = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_index_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            comment: field_comment,
            index_params: field_index_params,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagIndexReq {}
unsafe impl ::std::marker::Sync for self::DropTagIndexReq {}

impl ::fbthrift::GetTType for self::DropTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexReq {}
unsafe impl ::std::marker::Sync for self::GetTagIndexReq {}

impl ::fbthrift::GetTType for self::GetTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexResp {}
unsafe impl ::std::marker::Sync for self::GetTagIndexResp {}

impl ::fbthrift::GetTType for self::GetTagIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesReq {}

impl ::fbthrift::GetTType for self::ListTagIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesResp {}

impl ::fbthrift::GetTType for self::ListTagIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            index_params: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("edge_name", &self.edge_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .field("comment", &self.comment)
            .field("index_params", &self.index_params)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeIndexReq {}

impl ::fbthrift::GetTType for self::CreateEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.index_params {
            p.write_field_begin("index_params", ::fbthrift::TType::Struct, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("index_params", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let mut field_index_params = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_index_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            comment: field_comment,
            index_params: field_index_params,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeIndexReq {}

impl ::fbthrift::GetTType for self::DropEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexReq {}

impl ::fbthrift::GetTType for self::GetEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexResp {}

impl ::fbthrift::GetTType for self::GetEdgeIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesReq {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesResp {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RebuildIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RebuildIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RebuildIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RebuildIndexReq {}
unsafe impl ::std::marker::Sync for self::RebuildIndexReq {}

impl ::fbthrift::GetTType for self::RebuildIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RebuildIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateUserReq {}
unsafe impl ::std::marker::Sync for self::CreateUserReq {}

impl ::fbthrift::GetTType for self::CreateUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropUserReq")
            .field("account", &self.account)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropUserReq {}
unsafe impl ::std::marker::Sync for self::DropUserReq {}

impl ::fbthrift::GetTType for self::DropUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterUserReq {}
unsafe impl ::std::marker::Sync for self::AlterUserReq {}

impl ::fbthrift::GetTType for self::AlterUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GrantRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GrantRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GrantRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GrantRoleReq {}
unsafe impl ::std::marker::Sync for self::GrantRoleReq {}

impl ::fbthrift::GetTType for self::GrantRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GrantRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RevokeRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RevokeRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RevokeRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RevokeRoleReq {}
unsafe impl ::std::marker::Sync for self::RevokeRoleReq {}

impl ::fbthrift::GetTType for self::RevokeRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RevokeRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersReq {}
unsafe impl ::std::marker::Sync for self::ListUsersReq {}

impl ::fbthrift::GetTType for self::ListUsersReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            users: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("users", &self.users)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersResp {}
unsafe impl ::std::marker::Sync for self::ListUsersResp {}

impl ::fbthrift::GetTType for self::ListUsersResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("users", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.users, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("users", ::fbthrift::TType::Map, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_users = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_users = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            users: field_users.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesReq {}
unsafe impl ::std::marker::Sync for self::ListRolesReq {}

impl ::fbthrift::GetTType for self::ListRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            roles: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("roles", &self.roles)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesResp {}
unsafe impl ::std::marker::Sync for self::ListRolesResp {}

impl ::fbthrift::GetTType for self::ListRolesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("roles", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.roles, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("roles", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_roles = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_roles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            roles: field_roles.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUserRolesReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUserRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUserRolesReq")
            .field("account", &self.account)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUserRolesReq {}
unsafe impl ::std::marker::Sync for self::GetUserRolesReq {}

impl ::fbthrift::GetTType for self::GetUserRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUserRolesReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
        ];
        let mut field_account = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChangePasswordReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            new_encoded_pwd: ::std::default::Default::default(),
            old_encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChangePasswordReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChangePasswordReq")
            .field("account", &self.account)
            .field("new_encoded_pwd", &self.new_encoded_pwd)
            .field("old_encoded_pwd", &self.old_encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChangePasswordReq {}
unsafe impl ::std::marker::Sync for self::ChangePasswordReq {}

impl ::fbthrift::GetTType for self::ChangePasswordReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChangePasswordReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("new_encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.new_encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("old_encoded_pwd", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.old_encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("new_encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("old_encoded_pwd", ::fbthrift::TType::String, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_new_encoded_pwd = ::std::option::Option::None;
        let mut field_old_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_new_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_old_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            new_encoded_pwd: field_new_encoded_pwd.unwrap_or_default(),
            old_encoded_pwd: field_old_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceTask {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            command: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceTask {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceTask")
            .field("id", &self.id)
            .field("command", &self.command)
            .field("result", &self.result)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceTask {}
unsafe impl ::std::marker::Sync for self::BalanceTask {}

impl ::fbthrift::GetTType for self::BalanceTask {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceTask");
        p.write_field_begin("id", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("command", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.command, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("command", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("id", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("result", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 5),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_command = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_command = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            command: field_command.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ConfigItem {
    fn default() -> Self {
        Self {
            module: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            mode: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ConfigItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ConfigItem")
            .field("module", &self.module)
            .field("name", &self.name)
            .field("mode", &self.mode)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ConfigItem {}
unsafe impl ::std::marker::Sync for self::ConfigItem {}

impl ::fbthrift::GetTType for self::ConfigItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ConfigItem");
        p.write_field_begin("module", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.mode, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::Struct, 4),
        ];
        let mut field_module = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_mode = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            module: field_module.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            mode: field_mode.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RegConfigReq {
    fn default() -> Self {
        Self {
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RegConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RegConfigReq")
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RegConfigReq {}
unsafe impl ::std::marker::Sync for self::RegConfigReq {}

impl ::fbthrift::GetTType for self::RegConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RegConfigReq");
        p.write_field_begin("items", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 1),
        ];
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigReq")
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigReq {}
unsafe impl ::std::marker::Sync for self::GetConfigReq {}

impl ::fbthrift::GetTType for self::GetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigResp {}
unsafe impl ::std::marker::Sync for self::GetConfigResp {}

impl ::fbthrift::GetTType for self::GetConfigResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SetConfigReq")
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SetConfigReq {}
unsafe impl ::std::marker::Sync for self::SetConfigReq {}

impl ::fbthrift::GetTType for self::SetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsReq {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            module: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsReq")
            .field("space", &self.space)
            .field("module", &self.module)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsReq {}
unsafe impl ::std::marker::Sync for self::ListConfigsReq {}

impl ::fbthrift::GetTType for self::ListConfigsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsReq");
        p.write_field_begin("space", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("module", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::String, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_module = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            module: field_module.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsResp {}
unsafe impl ::std::marker::Sync for self::ListConfigsResp {}

impl ::fbthrift::GetTType for self::ListConfigsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSnapshotReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSnapshotReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSnapshotReq {}
unsafe impl ::std::marker::Sync for self::CreateSnapshotReq {}

impl ::fbthrift::GetTType for self::CreateSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSnapshotReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSnapshotReq {
    fn default() -> Self {
        Self {
            names: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSnapshotReq")
            .field("names", &self.names)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSnapshotReq {}
unsafe impl ::std::marker::Sync for self::DropSnapshotReq {}

impl ::fbthrift::GetTType for self::DropSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSnapshotReq");
        p.write_field_begin("names", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.names, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("names", ::fbthrift::TType::List, 1),
        ];
        let mut field_names = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            names: field_names.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsReq {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsReq {}

impl ::fbthrift::GetTType for self::ListSnapshotsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Snapshot {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Snapshot {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Snapshot")
            .field("name", &self.name)
            .field("status", &self.status)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Snapshot {}
unsafe impl ::std::marker::Sync for self::Snapshot {}

impl ::fbthrift::GetTType for self::Snapshot {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Snapshot");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            snapshots: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("snapshots", &self.snapshots)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsResp {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsResp {}

impl ::fbthrift::GetTType for self::ListSnapshotsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("snapshots", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.snapshots, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("snapshots", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_snapshots = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_snapshots = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            snapshots: field_snapshots.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusReq {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusReq {}

impl ::fbthrift::GetTType for self::ListIndexStatusReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexStatus {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexStatus {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexStatus")
            .field("name", &self.name)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexStatus {}
unsafe impl ::std::marker::Sync for self::IndexStatus {}

impl ::fbthrift::GetTType for self::IndexStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexStatus");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::String, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            statuses: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("statuses", &self.statuses)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusResp {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusResp {}

impl ::fbthrift::GetTType for self::ListIndexStatusResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("statuses", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.statuses, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("statuses", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_statuses = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_statuses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            statuses: field_statuses.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MergeZoneReq {
    fn default() -> Self {
        Self {
            zones: ::std::default::Default::default(),
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MergeZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MergeZoneReq")
            .field("zones", &self.zones)
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MergeZoneReq {}
unsafe impl ::std::marker::Sync for self::MergeZoneReq {}

impl ::fbthrift::GetTType for self::MergeZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MergeZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MergeZoneReq");
        p.write_field_begin("zones", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.zones, p);
        p.write_field_end();
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MergeZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("zones", ::fbthrift::TType::List, 1),
        ];
        let mut field_zones = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_zones = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zones: field_zones.unwrap_or_default(),
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropZoneReq")
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropZoneReq {}
unsafe impl ::std::marker::Sync for self::DropZoneReq {}

impl ::fbthrift::GetTType for self::DropZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DivideZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            zone_items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DivideZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DivideZoneReq")
            .field("zone_name", &self.zone_name)
            .field("zone_items", &self.zone_items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DivideZoneReq {}
unsafe impl ::std::marker::Sync for self::DivideZoneReq {}

impl ::fbthrift::GetTType for self::DivideZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DivideZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DivideZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("zone_items", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.zone_items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DivideZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_items", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_zone_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_zone_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            zone_items: field_zone_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RenameZoneReq {
    fn default() -> Self {
        Self {
            original_zone_name: ::std::default::Default::default(),
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RenameZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RenameZoneReq")
            .field("original_zone_name", &self.original_zone_name)
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RenameZoneReq {}
unsafe impl ::std::marker::Sync for self::RenameZoneReq {}

impl ::fbthrift::GetTType for self::RenameZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RenameZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RenameZoneReq");
        p.write_field_begin("original_zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.original_zone_name, p);
        p.write_field_end();
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RenameZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("original_zone_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_original_zone_name = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_original_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            original_zone_name: field_original_zone_name.unwrap_or_default(),
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddHostsIntoZoneReq {
    fn default() -> Self {
        Self {
            hosts: ::std::default::Default::default(),
            zone_name: ::std::default::Default::default(),
            is_new: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddHostsIntoZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddHostsIntoZoneReq")
            .field("hosts", &self.hosts)
            .field("zone_name", &self.zone_name)
            .field("is_new", &self.is_new)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddHostsIntoZoneReq {}
unsafe impl ::std::marker::Sync for self::AddHostsIntoZoneReq {}

impl ::fbthrift::GetTType for self::AddHostsIntoZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddHostsIntoZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddHostsIntoZoneReq");
        p.write_field_begin("hosts", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("is_new", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.is_new, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddHostsIntoZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("is_new", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_hosts = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_is_new = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_is_new = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hosts: field_hosts.unwrap_or_default(),
            zone_name: field_zone_name.unwrap_or_default(),
            is_new: field_is_new.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetZoneReq")
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetZoneReq {}
unsafe impl ::std::marker::Sync for self::GetZoneReq {}

impl ::fbthrift::GetTType for self::GetZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetZoneResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetZoneResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetZoneResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetZoneResp {}
unsafe impl ::std::marker::Sync for self::GetZoneResp {}

impl ::fbthrift::GetTType for self::GetZoneResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetZoneResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetZoneResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetZoneResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListZonesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListZonesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListZonesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListZonesReq {}
unsafe impl ::std::marker::Sync for self::ListZonesReq {}

impl ::fbthrift::GetTType for self::ListZonesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListZonesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListZonesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListZonesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Zone {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            nodes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Zone {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Zone")
            .field("zone_name", &self.zone_name)
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Zone {}
unsafe impl ::std::marker::Sync for self::Zone {}

impl ::fbthrift::GetTType for self::Zone {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Zone
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Zone");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("nodes", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.nodes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Zone
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_nodes = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            nodes: field_nodes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListZonesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            zones: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListZonesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListZonesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("zones", &self.zones)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListZonesResp {}
unsafe impl ::std::marker::Sync for self::ListZonesResp {}

impl ::fbthrift::GetTType for self::ListZonesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListZonesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListZonesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("zones", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.zones, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListZonesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("zones", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_zones = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_zones = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            zones: field_zones.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddListenerReq")
            .field("space_id", &self.space_id)
            .field("r#type", &self.r#type)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddListenerReq {}
unsafe impl ::std::marker::Sync for self::AddListenerReq {}

impl ::fbthrift::GetTType for self::AddListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveListenerReq")
            .field("space_id", &self.space_id)
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveListenerReq {}
unsafe impl ::std::marker::Sync for self::RemoveListenerReq {}

impl ::fbthrift::GetTType for self::RemoveListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListListenerReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListListenerReq {}
unsafe impl ::std::marker::Sync for self::ListListenerReq {}

impl ::fbthrift::GetTType for self::ListListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListenerInfo {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListenerInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListenerInfo")
            .field("r#type", &self.r#type)
            .field("host", &self.host)
            .field("part_id", &self.part_id)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListenerInfo {}
unsafe impl ::std::marker::Sync for self::ListenerInfo {}

impl ::fbthrift::GetTType for self::ListenerInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListenerInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListenerInfo");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListenerInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListListenerResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            listeners: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListListenerResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListListenerResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("listeners", &self.listeners)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListListenerResp {}
unsafe impl ::std::marker::Sync for self::ListListenerResp {}

impl ::fbthrift::GetTType for self::ListListenerResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListListenerResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListListenerResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("listeners", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.listeners, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListListenerResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("listeners", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_listeners = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_listeners = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            listeners: field_listeners.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStatsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStatsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStatsReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStatsReq {}
unsafe impl ::std::marker::Sync for self::GetStatsReq {}

impl ::fbthrift::GetTType for self::GetStatsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStatsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStatsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStatsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStatsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            stats: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStatsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStatsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("stats", &self.stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStatsResp {}
unsafe impl ::std::marker::Sync for self::GetStatsResp {}

impl ::fbthrift::GetTType for self::GetStatsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStatsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStatsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("stats", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.stats, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStatsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("stats", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            stats: field_stats.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostBackupInfo {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            checkpoints: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostBackupInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostBackupInfo")
            .field("host", &self.host)
            .field("checkpoints", &self.checkpoints)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostBackupInfo {}
unsafe impl ::std::marker::Sync for self::HostBackupInfo {}

impl ::fbthrift::GetTType for self::HostBackupInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostBackupInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostBackupInfo");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("checkpoints", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.checkpoints, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostBackupInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("checkpoints", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_checkpoints = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_checkpoints = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            checkpoints: field_checkpoints.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceBackupInfo {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            host_backups: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceBackupInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceBackupInfo")
            .field("space", &self.space)
            .field("host_backups", &self.host_backups)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceBackupInfo {}
unsafe impl ::std::marker::Sync for self::SpaceBackupInfo {}

impl ::fbthrift::GetTType for self::SpaceBackupInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceBackupInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceBackupInfo");
        p.write_field_begin("space", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("host_backups", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.host_backups, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceBackupInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host_backups", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_host_backups = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_host_backups = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            host_backups: field_host_backups.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BackupMeta {
    fn default() -> Self {
        Self {
            space_backups: ::std::default::Default::default(),
            meta_files: ::std::default::Default::default(),
            backup_name: ::std::default::Default::default(),
            full: ::std::default::Default::default(),
            all_spaces: ::std::default::Default::default(),
            create_time: ::std::default::Default::default(),
            base_backup_name: ::std::default::Default::default(),
            storage_hosts: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BackupMeta {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BackupMeta")
            .field("space_backups", &self.space_backups)
            .field("meta_files", &self.meta_files)
            .field("backup_name", &self.backup_name)
            .field("full", &self.full)
            .field("all_spaces", &self.all_spaces)
            .field("create_time", &self.create_time)
            .field("base_backup_name", &self.base_backup_name)
            .field("storage_hosts", &self.storage_hosts)
            .field("cluster_id", &self.cluster_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BackupMeta {}
unsafe impl ::std::marker::Sync for self::BackupMeta {}

impl ::fbthrift::GetTType for self::BackupMeta {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BackupMeta
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BackupMeta");
        p.write_field_begin("space_backups", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.space_backups, p);
        p.write_field_end();
        p.write_field_begin("meta_files", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.meta_files, p);
        p.write_field_end();
        p.write_field_begin("backup_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.backup_name, p);
        p.write_field_end();
        p.write_field_begin("full", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.full, p);
        p.write_field_end();
        p.write_field_begin("all_spaces", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.all_spaces, p);
        p.write_field_end();
        p.write_field_begin("create_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.create_time, p);
        p.write_field_end();
        p.write_field_begin("base_backup_name", ::fbthrift::TType::String, 7);
        ::fbthrift::Serialize::write(&self.base_backup_name, p);
        p.write_field_end();
        p.write_field_begin("storage_hosts", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.storage_hosts, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BackupMeta
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_spaces", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("backup_name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("base_backup_name", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 9),
            ::fbthrift::Field::new("create_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("full", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("meta_files", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_backups", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("storage_hosts", ::fbthrift::TType::List, 8),
        ];
        let mut field_space_backups = ::std::option::Option::None;
        let mut field_meta_files = ::std::option::Option::None;
        let mut field_backup_name = ::std::option::Option::None;
        let mut field_full = ::std::option::Option::None;
        let mut field_all_spaces = ::std::option::Option::None;
        let mut field_create_time = ::std::option::Option::None;
        let mut field_base_backup_name = ::std::option::Option::None;
        let mut field_storage_hosts = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_space_backups = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_meta_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_backup_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_full = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_all_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_create_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_base_backup_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_storage_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_backups: field_space_backups.unwrap_or_default(),
            meta_files: field_meta_files.unwrap_or_default(),
            backup_name: field_backup_name.unwrap_or_default(),
            full: field_full.unwrap_or_default(),
            all_spaces: field_all_spaces.unwrap_or_default(),
            create_time: field_create_time.unwrap_or_default(),
            base_backup_name: field_base_backup_name.unwrap_or_default(),
            storage_hosts: field_storage_hosts.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateBackupReq {
    fn default() -> Self {
        Self {
            spaces: ::std::option::Option::None,
            base_backup_name: ::std::option::Option::None,
            cluster_id: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateBackupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateBackupReq")
            .field("spaces", &self.spaces)
            .field("base_backup_name", &self.base_backup_name)
            .field("cluster_id", &self.cluster_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateBackupReq {}
unsafe impl ::std::marker::Sync for self::CreateBackupReq {}

impl ::fbthrift::GetTType for self::CreateBackupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateBackupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateBackupReq");
        if let ::std::option::Option::Some(some) = &self.spaces {
            p.write_field_begin("spaces", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.base_backup_name {
            p.write_field_begin("base_backup_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.cluster_id {
            p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("base_backup_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 1),
        ];
        let mut field_spaces = ::std::option::Option::None;
        let mut field_base_backup_name = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_base_backup_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            spaces: field_spaces,
            base_backup_name: field_base_backup_name,
            cluster_id: field_cluster_id,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateBackupResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            meta: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateBackupResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateBackupResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("meta", &self.meta)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateBackupResp {}
unsafe impl ::std::marker::Sync for self::CreateBackupResp {}

impl ::fbthrift::GetTType for self::CreateBackupResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateBackupResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateBackupResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("meta", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.meta, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("meta", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_meta = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_meta = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            meta: field_meta.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostPair {
    fn default() -> Self {
        Self {
            from_host: ::std::default::Default::default(),
            to_host: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostPair {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostPair")
            .field("from_host", &self.from_host)
            .field("to_host", &self.to_host)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostPair {}
unsafe impl ::std::marker::Sync for self::HostPair {}

impl ::fbthrift::GetTType for self::HostPair {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostPair
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostPair");
        p.write_field_begin("from_host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.from_host, p);
        p.write_field_end();
        p.write_field_begin("to_host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.to_host, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostPair
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("from_host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("to_host", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_from_host = ::std::option::Option::None;
        let mut field_to_host = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_from_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_to_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            from_host: field_from_host.unwrap_or_default(),
            to_host: field_to_host.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RestoreMetaReq {
    fn default() -> Self {
        Self {
            files: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RestoreMetaReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RestoreMetaReq")
            .field("files", &self.files)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RestoreMetaReq {}
unsafe impl ::std::marker::Sync for self::RestoreMetaReq {}

impl ::fbthrift::GetTType for self::RestoreMetaReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RestoreMetaReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RestoreMetaReq");
        p.write_field_begin("files", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.files, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RestoreMetaReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("files", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 2),
        ];
        let mut field_files = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            files: field_files.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartInfo {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartInfo")
            .field("part_id", &self.part_id)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartInfo {}
unsafe impl ::std::marker::Sync for self::PartInfo {}

impl ::fbthrift::GetTType for self::PartInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartInfo");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RestoreMetaResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            part_hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RestoreMetaResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RestoreMetaResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("part_hosts", &self.part_hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RestoreMetaResp {}
unsafe impl ::std::marker::Sync for self::RestoreMetaResp {}

impl ::fbthrift::GetTType for self::RestoreMetaResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RestoreMetaResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RestoreMetaResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("part_hosts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.part_hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RestoreMetaResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("part_hosts", ::fbthrift::TType::Map, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_part_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_part_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            part_hosts: field_part_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ServiceClient {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            user: ::std::option::Option::None,
            pwd: ::std::option::Option::None,
            conn_type: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ServiceClient {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ServiceClient")
            .field("host", &self.host)
            .field("user", &self.user)
            .field("pwd", &self.pwd)
            .field("conn_type", &self.conn_type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ServiceClient {}
unsafe impl ::std::marker::Sync for self::ServiceClient {}

impl ::fbthrift::GetTType for self::ServiceClient {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ServiceClient
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ServiceClient");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.user {
            p.write_field_begin("user", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.pwd {
            p.write_field_begin("pwd", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.conn_type {
            p.write_field_begin("conn_type", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ServiceClient
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("conn_type", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("pwd", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("user", ::fbthrift::TType::String, 2),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_user = ::std::option::Option::None;
        let mut field_pwd = ::std::option::Option::None;
        let mut field_conn_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_conn_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            user: field_user,
            pwd: field_pwd,
            conn_type: field_conn_type,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SignInServiceReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            clients: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SignInServiceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SignInServiceReq")
            .field("r#type", &self.r#type)
            .field("clients", &self.clients)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SignInServiceReq {}
unsafe impl ::std::marker::Sync for self::SignInServiceReq {}

impl ::fbthrift::GetTType for self::SignInServiceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SignInServiceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SignInServiceReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("clients", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.clients, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SignInServiceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clients", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_clients = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            clients: field_clients.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SignOutServiceReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SignOutServiceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SignOutServiceReq")
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SignOutServiceReq {}
unsafe impl ::std::marker::Sync for self::SignOutServiceReq {}

impl ::fbthrift::GetTType for self::SignOutServiceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SignOutServiceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SignOutServiceReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SignOutServiceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListServiceClientsReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListServiceClientsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListServiceClientsReq")
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListServiceClientsReq {}
unsafe impl ::std::marker::Sync for self::ListServiceClientsReq {}

impl ::fbthrift::GetTType for self::ListServiceClientsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListServiceClientsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListServiceClientsReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListServiceClientsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListServiceClientsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            clients: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListServiceClientsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListServiceClientsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("clients", &self.clients)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListServiceClientsResp {}
unsafe impl ::std::marker::Sync for self::ListServiceClientsResp {}

impl ::fbthrift::GetTType for self::ListServiceClientsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListServiceClientsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListServiceClientsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("clients", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.clients, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListServiceClientsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clients", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_clients = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            clients: field_clients.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::FTIndex {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            depend_schema: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::FTIndex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("FTIndex")
            .field("space_id", &self.space_id)
            .field("depend_schema", &self.depend_schema)
            .field("fields", &self.fields)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::FTIndex {}
unsafe impl ::std::marker::Sync for self::FTIndex {}

impl ::fbthrift::GetTType for self::FTIndex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::FTIndex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("FTIndex");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("depend_schema", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.depend_schema, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::FTIndex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("depend_schema", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_depend_schema = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_depend_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            depend_schema: field_depend_schema.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateFTIndexReq {
    fn default() -> Self {
        Self {
            fulltext_index_name: ::std::default::Default::default(),
            index: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateFTIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateFTIndexReq")
            .field("fulltext_index_name", &self.fulltext_index_name)
            .field("index", &self.index)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateFTIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateFTIndexReq {}

impl ::fbthrift::GetTType for self::CreateFTIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateFTIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateFTIndexReq");
        p.write_field_begin("fulltext_index_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.fulltext_index_name, p);
        p.write_field_end();
        p.write_field_begin("index", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.index, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateFTIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("fulltext_index_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("index", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_fulltext_index_name = ::std::option::Option::None;
        let mut field_index = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_fulltext_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_index = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            fulltext_index_name: field_fulltext_index_name.unwrap_or_default(),
            index: field_index.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropFTIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            fulltext_index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropFTIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropFTIndexReq")
            .field("space_id", &self.space_id)
            .field("fulltext_index_name", &self.fulltext_index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropFTIndexReq {}
unsafe impl ::std::marker::Sync for self::DropFTIndexReq {}

impl ::fbthrift::GetTType for self::DropFTIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropFTIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropFTIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("fulltext_index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.fulltext_index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropFTIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("fulltext_index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_fulltext_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_fulltext_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            fulltext_index_name: field_fulltext_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTIndexesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTIndexesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListFTIndexesReq {}

impl ::fbthrift::GetTType for self::ListFTIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTIndexesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            indexes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("indexes", &self.indexes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListFTIndexesResp {}

impl ::fbthrift::GetTType for self::ListFTIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("indexes", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.indexes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("indexes", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_indexes = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_indexes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            indexes: field_indexes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::QueryDesc {
    fn default() -> Self {
        Self {
            start_time: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            duration: ::std::default::Default::default(),
            query: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::QueryDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("QueryDesc")
            .field("start_time", &self.start_time)
            .field("status", &self.status)
            .field("duration", &self.duration)
            .field("query", &self.query)
            .field("graph_addr", &self.graph_addr)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::QueryDesc {}
unsafe impl ::std::marker::Sync for self::QueryDesc {}

impl ::fbthrift::GetTType for self::QueryDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::QueryDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("QueryDesc");
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("duration", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.duration, p);
        p.write_field_end();
        p.write_field_begin("query", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.query, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::QueryDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("duration", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("query", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_start_time = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_duration = ::std::option::Option::None;
        let mut field_query = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_query = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            start_time: field_start_time.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            duration: field_duration.unwrap_or_default(),
            query: field_query.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Session {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            create_time: ::std::default::Default::default(),
            update_time: ::std::default::Default::default(),
            user_name: ::std::default::Default::default(),
            space_name: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            timezone: ::std::default::Default::default(),
            client_ip: ::std::default::Default::default(),
            configs: ::std::default::Default::default(),
            queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Session {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Session")
            .field("session_id", &self.session_id)
            .field("create_time", &self.create_time)
            .field("update_time", &self.update_time)
            .field("user_name", &self.user_name)
            .field("space_name", &self.space_name)
            .field("graph_addr", &self.graph_addr)
            .field("timezone", &self.timezone)
            .field("client_ip", &self.client_ip)
            .field("configs", &self.configs)
            .field("queries", &self.queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Session {}
unsafe impl ::std::marker::Sync for self::Session {}

impl ::fbthrift::GetTType for self::Session {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Session
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Session");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_begin("create_time", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.create_time, p);
        p.write_field_end();
        p.write_field_begin("update_time", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.update_time, p);
        p.write_field_end();
        p.write_field_begin("user_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.user_name, p);
        p.write_field_end();
        p.write_field_begin("space_name", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_begin("timezone", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.timezone, p);
        p.write_field_end();
        p.write_field_begin("client_ip", ::fbthrift::TType::String, 8);
        ::fbthrift::Serialize::write(&self.client_ip, p);
        p.write_field_end();
        p.write_field_begin("configs", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.configs, p);
        p.write_field_end();
        p.write_field_begin("queries", ::fbthrift::TType::Map, 10);
        ::fbthrift::Serialize::write(&self.queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Session
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("configs", ::fbthrift::TType::Map, 9),
            ::fbthrift::Field::new("create_time", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("queries", ::fbthrift::TType::Map, 10),
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("timezone", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("update_time", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("user_name", ::fbthrift::TType::String, 4),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let mut field_create_time = ::std::option::Option::None;
        let mut field_update_time = ::std::option::Option::None;
        let mut field_user_name = ::std::option::Option::None;
        let mut field_space_name = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let mut field_timezone = ::std::option::Option::None;
        let mut field_client_ip = ::std::option::Option::None;
        let mut field_configs = ::std::option::Option::None;
        let mut field_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_create_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_update_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_user_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_timezone = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_configs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 10) => field_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            create_time: field_create_time.unwrap_or_default(),
            update_time: field_update_time.unwrap_or_default(),
            user_name: field_user_name.unwrap_or_default(),
            space_name: field_space_name.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            timezone: field_timezone.unwrap_or_default(),
            client_ip: field_client_ip.unwrap_or_default(),
            configs: field_configs.unwrap_or_default(),
            queries: field_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSessionReq {
    fn default() -> Self {
        Self {
            user: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            client_ip: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSessionReq")
            .field("user", &self.user)
            .field("graph_addr", &self.graph_addr)
            .field("client_ip", &self.client_ip)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSessionReq {}
unsafe impl ::std::marker::Sync for self::CreateSessionReq {}

impl ::fbthrift::GetTType for self::CreateSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSessionReq");
        p.write_field_begin("user", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.user, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_begin("client_ip", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.client_ip, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("user", ::fbthrift::TType::String, 1),
        ];
        let mut field_user = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let mut field_client_ip = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            user: field_user.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            client_ip: field_client_ip.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSessionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            session: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSessionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSessionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("session", &self.session)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSessionResp {}
unsafe impl ::std::marker::Sync for self::CreateSessionResp {}

impl ::fbthrift::GetTType for self::CreateSessionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSessionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSessionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.session, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_session = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            session: field_session.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateSessionsReq {
    fn default() -> Self {
        Self {
            sessions: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateSessionsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateSessionsReq")
            .field("sessions", &self.sessions)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateSessionsReq {}
unsafe impl ::std::marker::Sync for self::UpdateSessionsReq {}

impl ::fbthrift::GetTType for self::UpdateSessionsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateSessionsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateSessionsReq");
        p.write_field_begin("sessions", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.sessions, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateSessionsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 1),
        ];
        let mut field_sessions = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            sessions: field_sessions.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateSessionsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            killed_queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateSessionsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateSessionsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("killed_queries", &self.killed_queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateSessionsResp {}
unsafe impl ::std::marker::Sync for self::UpdateSessionsResp {}

impl ::fbthrift::GetTType for self::UpdateSessionsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateSessionsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateSessionsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("killed_queries", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.killed_queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateSessionsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("killed_queries", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_killed_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_killed_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            killed_queries: field_killed_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSessionsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSessionsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSessionsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSessionsReq {}
unsafe impl ::std::marker::Sync for self::ListSessionsReq {}

impl ::fbthrift::GetTType for self::ListSessionsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSessionsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSessionsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSessionsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            sessions: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSessionsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSessionsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("sessions", &self.sessions)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSessionsResp {}
unsafe impl ::std::marker::Sync for self::ListSessionsResp {}

impl ::fbthrift::GetTType for self::ListSessionsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSessionsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSessionsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("sessions", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.sessions, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_sessions = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            sessions: field_sessions.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSessionReq {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSessionReq")
            .field("session_id", &self.session_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSessionReq {}
unsafe impl ::std::marker::Sync for self::GetSessionReq {}

impl ::fbthrift::GetTType for self::GetSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSessionReq");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSessionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            session: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSessionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSessionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("session", &self.session)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSessionResp {}
unsafe impl ::std::marker::Sync for self::GetSessionResp {}

impl ::fbthrift::GetTType for self::GetSessionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSessionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSessionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.session, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSessionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_session = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            session: field_session.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveSessionReq {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveSessionReq")
            .field("session_id", &self.session_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveSessionReq {}
unsafe impl ::std::marker::Sync for self::RemoveSessionReq {}

impl ::fbthrift::GetTType for self::RemoveSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveSessionReq");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KillQueryReq {
    fn default() -> Self {
        Self {
            kill_queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KillQueryReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KillQueryReq")
            .field("kill_queries", &self.kill_queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KillQueryReq {}
unsafe impl ::std::marker::Sync for self::KillQueryReq {}

impl ::fbthrift::GetTType for self::KillQueryReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KillQueryReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KillQueryReq");
        p.write_field_begin("kill_queries", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.kill_queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KillQueryReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("kill_queries", ::fbthrift::TType::Map, 1),
        ];
        let mut field_kill_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_kill_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            kill_queries: field_kill_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ReportTaskReq {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            space_id: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            task_id: ::std::default::Default::default(),
            stats: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ReportTaskReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ReportTaskReq")
            .field("code", &self.code)
            .field("space_id", &self.space_id)
            .field("job_id", &self.job_id)
            .field("task_id", &self.task_id)
            .field("stats", &self.stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ReportTaskReq {}
unsafe impl ::std::marker::Sync for self::ReportTaskReq {}

impl ::fbthrift::GetTType for self::ReportTaskReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ReportTaskReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ReportTaskReq");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.stats {
            p.write_field_begin("stats", ::fbthrift::TType::Struct, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ReportTaskReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("stats", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_space_id = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let mut field_task_id = ::std::option::Option::None;
        let mut field_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            space_id: field_space_id.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            task_id: field_task_id.unwrap_or_default(),
            stats: field_stats,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            host_services: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("host_services", &self.host_services)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoResp {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoResp {}

impl ::fbthrift::GetTType for self::ListClusterInfoResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("host_services", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.host_services, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("host_services", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_host_services = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_host_services = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            host_services: field_host_services.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoReq {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoReq {}

impl ::fbthrift::GetTType for self::ListClusterInfoReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetMetaDirInfoResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            dir: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetMetaDirInfoResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetMetaDirInfoResp")
            .field("code", &self.code)
            .field("dir", &self.dir)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetMetaDirInfoResp {}
unsafe impl ::std::marker::Sync for self::GetMetaDirInfoResp {}

impl ::fbthrift::GetTType for self::GetMetaDirInfoResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetMetaDirInfoResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetMetaDirInfoResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("dir", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dir, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetMetaDirInfoResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_dir = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            dir: field_dir.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetMetaDirInfoReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetMetaDirInfoReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetMetaDirInfoReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetMetaDirInfoReq {}
unsafe impl ::std::marker::Sync for self::GetMetaDirInfoReq {}

impl ::fbthrift::GetTType for self::GetMetaDirInfoReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetMetaDirInfoReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetMetaDirInfoReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetMetaDirInfoReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            error_msg: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("error_msg", &self.error_msg)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionResp {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionResp {}

impl ::fbthrift::GetTType for self::VerifyClientVersionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            error_msg: field_error_msg,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionReq {
    fn default() -> Self {
        Self {
            client_version: "3.0.0".as_bytes().into(),
            host: ::std::default::Default::default(),
            build_version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionReq")
            .field("client_version", &self.client_version)
            .field("host", &self.host)
            .field("build_version", &self.build_version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionReq {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionReq {}

impl ::fbthrift::GetTType for self::VerifyClientVersionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionReq");
        p.write_field_begin("client_version", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.client_version, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("build_version", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.build_version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("build_version", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("client_version", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_client_version = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_build_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_client_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_build_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            client_version: field_client_version.unwrap_or_else(|| "3.0.0".as_bytes().into()),
            host: field_host.unwrap_or_default(),
            build_version: field_build_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SaveGraphVersionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            error_msg: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SaveGraphVersionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SaveGraphVersionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("error_msg", &self.error_msg)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SaveGraphVersionResp {}
unsafe impl ::std::marker::Sync for self::SaveGraphVersionResp {}

impl ::fbthrift::GetTType for self::SaveGraphVersionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SaveGraphVersionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SaveGraphVersionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SaveGraphVersionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            error_msg: field_error_msg,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SaveGraphVersionReq {
    fn default() -> Self {
        Self {
            client_version: "3.0.0".as_bytes().into(),
            host: ::std::default::Default::default(),
            build_version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SaveGraphVersionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SaveGraphVersionReq")
            .field("client_version", &self.client_version)
            .field("host", &self.host)
            .field("build_version", &self.build_version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SaveGraphVersionReq {}
unsafe impl ::std::marker::Sync for self::SaveGraphVersionReq {}

impl ::fbthrift::GetTType for self::SaveGraphVersionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SaveGraphVersionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SaveGraphVersionReq");
        p.write_field_begin("client_version", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.client_version, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("build_version", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.build_version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SaveGraphVersionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("build_version", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("client_version", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_client_version = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_build_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_client_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_build_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            client_version: field_client_version.unwrap_or_else(|| "3.0.0".as_bytes().into()),
            host: field_host.unwrap_or_default(),
            build_version: field_build_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
