// @generated by Thrift for src/interface/raftex.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `raftex`.

#![allow(clippy::redundant_closure)]


pub type ClusterID = ::std::primitive::i64;

pub type GraphSpaceID = ::std::primitive::i32;

pub type PartitionID = ::std::primitive::i32;

pub type TermID = ::std::primitive::i64;

pub type LogID = ::std::primitive::i64;

pub type Port = ::std::primitive::i32;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AskForVoteRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub candidate_addr: ::std::string::String,
    pub candidate_port: crate::types::Port,
    pub term: crate::types::TermID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AskForVoteResponse {
    pub error_code: crate::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LogEntry {
    pub cluster: crate::types::ClusterID,
    pub log_str: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AppendLogRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub current_term: crate::types::TermID,
    pub last_log_id: crate::types::LogID,
    pub committed_log_id: crate::types::LogID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub last_log_term_sent: crate::types::TermID,
    pub last_log_id_sent: crate::types::LogID,
    pub log_term: crate::types::TermID,
    pub log_str_list: ::std::vec::Vec<crate::types::LogEntry>,
    pub sending_snapshot: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AppendLogResponse {
    pub error_code: crate::types::ErrorCode,
    pub current_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub committed_log_id: crate::types::LogID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SendSnapshotRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub term: crate::types::TermID,
    pub committed_log_id: crate::types::LogID,
    pub committed_log_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub rows: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub total_size: ::std::primitive::i64,
    pub total_count: ::std::primitive::i64,
    pub done: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HeartbeatRequest {
    pub space: crate::types::GraphSpaceID,
    pub part: crate::types::PartitionID,
    pub current_term: crate::types::TermID,
    pub last_log_id: crate::types::LogID,
    pub committed_log_id: crate::types::LogID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub last_log_term_sent: crate::types::TermID,
    pub last_log_id_sent: crate::types::LogID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HeartbeatResponse {
    pub error_code: crate::types::ErrorCode,
    pub current_term: crate::types::TermID,
    pub leader_addr: ::std::string::String,
    pub leader_port: crate::types::Port,
    pub committed_log_id: crate::types::LogID,
    pub last_log_id: crate::types::LogID,
    pub last_log_term: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SendSnapshotResponse {
    pub error_code: crate::types::ErrorCode,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ErrorCode(pub ::std::primitive::i32);

impl ErrorCode {
    pub const SUCCEEDED: Self = ErrorCode(0i32);
    pub const E_LOG_GAP: Self = ErrorCode(-1i32);
    pub const E_LOG_STALE: Self = ErrorCode(-2i32);
    pub const E_MISSING_COMMIT: Self = ErrorCode(-3i32);
    pub const E_WAITING_SNAPSHOT: Self = ErrorCode(-4i32);
    pub const E_UNKNOWN_PART: Self = ErrorCode(-5i32);
    pub const E_TERM_OUT_OF_DATE: Self = ErrorCode(-6i32);
    pub const E_LAST_LOG_TERM_TOO_OLD: Self = ErrorCode(-7i32);
    pub const E_BAD_STATE: Self = ErrorCode(-8i32);
    pub const E_WRONG_LEADER: Self = ErrorCode(-9i32);
    pub const E_WAL_FAIL: Self = ErrorCode(-10i32);
    pub const E_NOT_READY: Self = ErrorCode(-11i32);
    pub const E_HOST_STOPPED: Self = ErrorCode(-12i32);
    pub const E_NOT_A_LEADER: Self = ErrorCode(-13i32);
    pub const E_HOST_DISCONNECTED: Self = ErrorCode(-14i32);
    pub const E_TOO_MANY_REQUESTS: Self = ErrorCode(-15i32);
    pub const E_PERSIST_SNAPSHOT_FAILED: Self = ErrorCode(-16i32);
    pub const E_BAD_ROLE: Self = ErrorCode(-17i32);
    pub const E_EXCEPTION: Self = ErrorCode(-20i32);
}

impl ::fbthrift::ThriftEnum for ErrorCode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::E_LOG_GAP, "E_LOG_GAP"),
            (Self::E_LOG_STALE, "E_LOG_STALE"),
            (Self::E_MISSING_COMMIT, "E_MISSING_COMMIT"),
            (Self::E_WAITING_SNAPSHOT, "E_WAITING_SNAPSHOT"),
            (Self::E_UNKNOWN_PART, "E_UNKNOWN_PART"),
            (Self::E_TERM_OUT_OF_DATE, "E_TERM_OUT_OF_DATE"),
            (Self::E_LAST_LOG_TERM_TOO_OLD, "E_LAST_LOG_TERM_TOO_OLD"),
            (Self::E_BAD_STATE, "E_BAD_STATE"),
            (Self::E_WRONG_LEADER, "E_WRONG_LEADER"),
            (Self::E_WAL_FAIL, "E_WAL_FAIL"),
            (Self::E_NOT_READY, "E_NOT_READY"),
            (Self::E_HOST_STOPPED, "E_HOST_STOPPED"),
            (Self::E_NOT_A_LEADER, "E_NOT_A_LEADER"),
            (Self::E_HOST_DISCONNECTED, "E_HOST_DISCONNECTED"),
            (Self::E_TOO_MANY_REQUESTS, "E_TOO_MANY_REQUESTS"),
            (Self::E_PERSIST_SNAPSHOT_FAILED, "E_PERSIST_SNAPSHOT_FAILED"),
            (Self::E_BAD_ROLE, "E_BAD_ROLE"),
            (Self::E_EXCEPTION, "E_EXCEPTION"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "E_LOG_GAP",
            "E_LOG_STALE",
            "E_MISSING_COMMIT",
            "E_WAITING_SNAPSHOT",
            "E_UNKNOWN_PART",
            "E_TERM_OUT_OF_DATE",
            "E_LAST_LOG_TERM_TOO_OLD",
            "E_BAD_STATE",
            "E_WRONG_LEADER",
            "E_WAL_FAIL",
            "E_NOT_READY",
            "E_HOST_STOPPED",
            "E_NOT_A_LEADER",
            "E_HOST_DISCONNECTED",
            "E_TOO_MANY_REQUESTS",
            "E_PERSIST_SNAPSHOT_FAILED",
            "E_BAD_ROLE",
            "E_EXCEPTION",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::E_LOG_GAP,
            Self::E_LOG_STALE,
            Self::E_MISSING_COMMIT,
            Self::E_WAITING_SNAPSHOT,
            Self::E_UNKNOWN_PART,
            Self::E_TERM_OUT_OF_DATE,
            Self::E_LAST_LOG_TERM_TOO_OLD,
            Self::E_BAD_STATE,
            Self::E_WRONG_LEADER,
            Self::E_WAL_FAIL,
            Self::E_NOT_READY,
            Self::E_HOST_STOPPED,
            Self::E_NOT_A_LEADER,
            Self::E_HOST_DISCONNECTED,
            Self::E_TOO_MANY_REQUESTS,
            Self::E_PERSIST_SNAPSHOT_FAILED,
            Self::E_BAD_ROLE,
            Self::E_EXCEPTION,
        ]
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_EXCEPTION", -20),
            ("E_BAD_ROLE", -17),
            ("E_PERSIST_SNAPSHOT_FAILED", -16),
            ("E_TOO_MANY_REQUESTS", -15),
            ("E_HOST_DISCONNECTED", -14),
            ("E_NOT_A_LEADER", -13),
            ("E_HOST_STOPPED", -12),
            ("E_NOT_READY", -11),
            ("E_WAL_FAIL", -10),
            ("E_WRONG_LEADER", -9),
            ("E_BAD_STATE", -8),
            ("E_LAST_LOG_TERM_TOO_OLD", -7),
            ("E_TERM_OUT_OF_DATE", -6),
            ("E_UNKNOWN_PART", -5),
            ("E_WAITING_SNAPSHOT", -4),
            ("E_MISSING_COMMIT", -3),
            ("E_LOG_STALE", -2),
            ("E_LOG_GAP", -1),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ErrorCode::{}", self)
    }
}

impl ::std::str::FromStr for ErrorCode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_BAD_ROLE", -17),
            ("E_BAD_STATE", -8),
            ("E_EXCEPTION", -20),
            ("E_HOST_DISCONNECTED", -14),
            ("E_HOST_STOPPED", -12),
            ("E_LAST_LOG_TERM_TOO_OLD", -7),
            ("E_LOG_GAP", -1),
            ("E_LOG_STALE", -2),
            ("E_MISSING_COMMIT", -3),
            ("E_NOT_A_LEADER", -13),
            ("E_NOT_READY", -11),
            ("E_PERSIST_SNAPSHOT_FAILED", -16),
            ("E_TERM_OUT_OF_DATE", -6),
            ("E_TOO_MANY_REQUESTS", -15),
            ("E_UNKNOWN_PART", -5),
            ("E_WAITING_SNAPSHOT", -4),
            ("E_WAL_FAIL", -10),
            ("E_WRONG_LEADER", -9),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(Self)
    }
}

impl ::fbthrift::GetTType for ErrorCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}







#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AskForVoteRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            candidate_addr: ::std::default::Default::default(),
            candidate_port: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AskForVoteRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AskForVoteRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("candidate_addr", &self.candidate_addr)
            .field("candidate_port", &self.candidate_port)
            .field("term", &self.term)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AskForVoteRequest {}
unsafe impl ::std::marker::Sync for self::AskForVoteRequest {}

impl ::fbthrift::GetTType for self::AskForVoteRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AskForVoteRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AskForVoteRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("candidate_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.candidate_addr, p);
        p.write_field_end();
        p.write_field_begin("candidate_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.candidate_port, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AskForVoteRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("candidate_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("candidate_port", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 5),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_candidate_addr = ::std::option::Option::None;
        let mut field_candidate_port = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_candidate_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_candidate_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            candidate_addr: field_candidate_addr.unwrap_or_default(),
            candidate_port: field_candidate_port.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AskForVoteResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AskForVoteResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AskForVoteResponse")
            .field("error_code", &self.error_code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AskForVoteResponse {}
unsafe impl ::std::marker::Sync for self::AskForVoteResponse {}

impl ::fbthrift::GetTType for self::AskForVoteResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AskForVoteResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AskForVoteResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AskForVoteResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LogEntry {
    fn default() -> Self {
        Self {
            cluster: ::std::default::Default::default(),
            log_str: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LogEntry {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LogEntry")
            .field("cluster", &self.cluster)
            .field("log_str", &self.log_str)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LogEntry {}
unsafe impl ::std::marker::Sync for self::LogEntry {}

impl ::fbthrift::GetTType for self::LogEntry {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LogEntry
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LogEntry");
        p.write_field_begin("cluster", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.cluster, p);
        p.write_field_end();
        p.write_field_begin("log_str", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.log_str, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LogEntry
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("log_str", ::fbthrift::TType::String, 2),
        ];
        let mut field_cluster = ::std::option::Option::None;
        let mut field_log_str = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_cluster = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_log_str = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            cluster: field_cluster.unwrap_or_default(),
            log_str: field_log_str.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AppendLogRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            last_log_term_sent: ::std::default::Default::default(),
            last_log_id_sent: ::std::default::Default::default(),
            log_term: ::std::default::Default::default(),
            log_str_list: ::std::default::Default::default(),
            sending_snapshot: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AppendLogRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AppendLogRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("current_term", &self.current_term)
            .field("last_log_id", &self.last_log_id)
            .field("committed_log_id", &self.committed_log_id)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("last_log_term_sent", &self.last_log_term_sent)
            .field("last_log_id_sent", &self.last_log_id_sent)
            .field("log_term", &self.log_term)
            .field("log_str_list", &self.log_str_list)
            .field("sending_snapshot", &self.sending_snapshot)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AppendLogRequest {}
unsafe impl ::std::marker::Sync for self::AppendLogRequest {}

impl ::fbthrift::GetTType for self::AppendLogRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AppendLogRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AppendLogRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("last_log_term_sent", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.last_log_term_sent, p);
        p.write_field_end();
        p.write_field_begin("last_log_id_sent", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.last_log_id_sent, p);
        p.write_field_end();
        p.write_field_begin("log_term", ::fbthrift::TType::I64, 10);
        ::fbthrift::Serialize::write(&self.log_term, p);
        p.write_field_end();
        p.write_field_begin("log_str_list", ::fbthrift::TType::List, 11);
        ::fbthrift::Serialize::write(&self.log_str_list, p);
        p.write_field_end();
        p.write_field_begin("sending_snapshot", ::fbthrift::TType::Bool, 12);
        ::fbthrift::Serialize::write(&self.sending_snapshot, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AppendLogRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("last_log_id_sent", ::fbthrift::TType::I64, 9),
            ::fbthrift::Field::new("last_log_term_sent", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("log_str_list", ::fbthrift::TType::List, 11),
            ::fbthrift::Field::new("log_term", ::fbthrift::TType::I64, 10),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("sending_snapshot", ::fbthrift::TType::Bool, 12),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_last_log_term_sent = ::std::option::Option::None;
        let mut field_last_log_id_sent = ::std::option::Option::None;
        let mut field_log_term = ::std::option::Option::None;
        let mut field_log_str_list = ::std::option::Option::None;
        let mut field_sending_snapshot = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_last_log_term_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_last_log_id_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 10) => field_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 11) => field_log_str_list = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 12) => field_sending_snapshot = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            last_log_term_sent: field_last_log_term_sent.unwrap_or_default(),
            last_log_id_sent: field_last_log_id_sent.unwrap_or_default(),
            log_term: field_log_term.unwrap_or_default(),
            log_str_list: field_log_str_list.unwrap_or_default(),
            sending_snapshot: field_sending_snapshot.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AppendLogResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AppendLogResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AppendLogResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("committed_log_id", &self.committed_log_id)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AppendLogResponse {}
unsafe impl ::std::marker::Sync for self::AppendLogResponse {}

impl ::fbthrift::GetTType for self::AppendLogResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AppendLogResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AppendLogResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AppendLogResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SendSnapshotRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            committed_log_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            rows: ::std::default::Default::default(),
            total_size: ::std::default::Default::default(),
            total_count: ::std::default::Default::default(),
            done: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SendSnapshotRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SendSnapshotRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("term", &self.term)
            .field("committed_log_id", &self.committed_log_id)
            .field("committed_log_term", &self.committed_log_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("rows", &self.rows)
            .field("total_size", &self.total_size)
            .field("total_count", &self.total_count)
            .field("done", &self.done)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SendSnapshotRequest {}
unsafe impl ::std::marker::Sync for self::SendSnapshotRequest {}

impl ::fbthrift::GetTType for self::SendSnapshotRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SendSnapshotRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SendSnapshotRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("committed_log_term", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("rows", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.rows, p);
        p.write_field_end();
        p.write_field_begin("total_size", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.total_size, p);
        p.write_field_end();
        p.write_field_begin("total_count", ::fbthrift::TType::I64, 10);
        ::fbthrift::Serialize::write(&self.total_count, p);
        p.write_field_end();
        p.write_field_begin("done", ::fbthrift::TType::Bool, 11);
        ::fbthrift::Serialize::write(&self.done, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SendSnapshotRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("committed_log_term", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("done", ::fbthrift::TType::Bool, 11),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 8),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("total_count", ::fbthrift::TType::I64, 10),
            ::fbthrift::Field::new("total_size", ::fbthrift::TType::I64, 9),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_committed_log_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_rows = ::std::option::Option::None;
        let mut field_total_size = ::std::option::Option::None;
        let mut field_total_count = ::std::option::Option::None;
        let mut field_done = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_total_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 10) => field_total_count = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 11) => field_done = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            committed_log_term: field_committed_log_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            rows: field_rows.unwrap_or_default(),
            total_size: field_total_size.unwrap_or_default(),
            total_count: field_total_count.unwrap_or_default(),
            done: field_done.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HeartbeatRequest {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            part: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            last_log_term_sent: ::std::default::Default::default(),
            last_log_id_sent: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HeartbeatRequest {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HeartbeatRequest")
            .field("space", &self.space)
            .field("part", &self.part)
            .field("current_term", &self.current_term)
            .field("last_log_id", &self.last_log_id)
            .field("committed_log_id", &self.committed_log_id)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("last_log_term_sent", &self.last_log_term_sent)
            .field("last_log_id_sent", &self.last_log_id_sent)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HeartbeatRequest {}
unsafe impl ::std::marker::Sync for self::HeartbeatRequest {}

impl ::fbthrift::GetTType for self::HeartbeatRequest {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HeartbeatRequest
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HeartbeatRequest");
        p.write_field_begin("space", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("part", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.part, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("last_log_term_sent", ::fbthrift::TType::I64, 8);
        ::fbthrift::Serialize::write(&self.last_log_term_sent, p);
        p.write_field_end();
        p.write_field_begin("last_log_id_sent", ::fbthrift::TType::I64, 9);
        ::fbthrift::Serialize::write(&self.last_log_id_sent, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HeartbeatRequest
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("last_log_id_sent", ::fbthrift::TType::I64, 9),
            ::fbthrift::Field::new("last_log_term_sent", ::fbthrift::TType::I64, 8),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("part", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_part = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_last_log_term_sent = ::std::option::Option::None;
        let mut field_last_log_id_sent = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_part = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 8) => field_last_log_term_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 9) => field_last_log_id_sent = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            part: field_part.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            last_log_term_sent: field_last_log_term_sent.unwrap_or_default(),
            last_log_id_sent: field_last_log_id_sent.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HeartbeatResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            current_term: ::std::default::Default::default(),
            leader_addr: ::std::default::Default::default(),
            leader_port: ::std::default::Default::default(),
            committed_log_id: ::std::default::Default::default(),
            last_log_id: ::std::default::Default::default(),
            last_log_term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HeartbeatResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HeartbeatResponse")
            .field("error_code", &self.error_code)
            .field("current_term", &self.current_term)
            .field("leader_addr", &self.leader_addr)
            .field("leader_port", &self.leader_port)
            .field("committed_log_id", &self.committed_log_id)
            .field("last_log_id", &self.last_log_id)
            .field("last_log_term", &self.last_log_term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HeartbeatResponse {}
unsafe impl ::std::marker::Sync for self::HeartbeatResponse {}

impl ::fbthrift::GetTType for self::HeartbeatResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HeartbeatResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HeartbeatResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_begin("current_term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.current_term, p);
        p.write_field_end();
        p.write_field_begin("leader_addr", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.leader_addr, p);
        p.write_field_end();
        p.write_field_begin("leader_port", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.leader_port, p);
        p.write_field_end();
        p.write_field_begin("committed_log_id", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.committed_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_id", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.last_log_id, p);
        p.write_field_end();
        p.write_field_begin("last_log_term", ::fbthrift::TType::I64, 7);
        ::fbthrift::Serialize::write(&self.last_log_term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HeartbeatResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("committed_log_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("current_term", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_log_id", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("last_log_term", ::fbthrift::TType::I64, 7),
            ::fbthrift::Field::new("leader_addr", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader_port", ::fbthrift::TType::I32, 4),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let mut field_current_term = ::std::option::Option::None;
        let mut field_leader_addr = ::std::option::Option::None;
        let mut field_leader_port = ::std::option::Option::None;
        let mut field_committed_log_id = ::std::option::Option::None;
        let mut field_last_log_id = ::std::option::Option::None;
        let mut field_last_log_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_current_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_leader_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_leader_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_committed_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_last_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 7) => field_last_log_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            current_term: field_current_term.unwrap_or_default(),
            leader_addr: field_leader_addr.unwrap_or_default(),
            leader_port: field_leader_port.unwrap_or_default(),
            committed_log_id: field_committed_log_id.unwrap_or_default(),
            last_log_id: field_last_log_id.unwrap_or_default(),
            last_log_term: field_last_log_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SendSnapshotResponse {
    fn default() -> Self {
        Self {
            error_code: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SendSnapshotResponse {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SendSnapshotResponse")
            .field("error_code", &self.error_code)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SendSnapshotResponse {}
unsafe impl ::std::marker::Sync for self::SendSnapshotResponse {}

impl ::fbthrift::GetTType for self::SendSnapshotResponse {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SendSnapshotResponse
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SendSnapshotResponse");
        p.write_field_begin("error_code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.error_code, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SendSnapshotResponse
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("error_code", ::fbthrift::TType::I32, 1),
        ];
        let mut field_error_code = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_error_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            error_code: field_error_code.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
