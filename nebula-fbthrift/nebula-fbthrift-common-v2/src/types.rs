// @generated by Thrift for src/interface/common.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `common`.

#![allow(clippy::redundant_closure)]


pub type GraphSpaceID = ::std::primitive::i32;

pub type PartitionID = ::std::primitive::i32;

pub type TagID = ::std::primitive::i32;

pub type EdgeType = ::std::primitive::i32;

pub type EdgeRanking = ::std::primitive::i64;

pub type LogID = ::std::primitive::i64;

pub type TermID = ::std::primitive::i64;

pub type Timestamp = ::std::primitive::i64;

pub type IndexID = ::std::primitive::i32;

pub type Port = ::std::primitive::i32;

pub type SessionID = ::std::primitive::i64;

pub type ExecutionPlanID = ::std::primitive::i64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SchemaID {
    tag_id(crate::types::TagID),
    edge_type(crate::types::EdgeType),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Date {
    pub year: ::std::primitive::i16,
    pub month: ::std::primitive::i8,
    pub day: ::std::primitive::i8,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Time {
    pub hour: ::std::primitive::i8,
    pub minute: ::std::primitive::i8,
    pub sec: ::std::primitive::i8,
    pub microsec: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DateTime {
    pub year: ::std::primitive::i16,
    pub month: ::std::primitive::i8,
    pub day: ::std::primitive::i8,
    pub hour: ::std::primitive::i8,
    pub minute: ::std::primitive::i8,
    pub sec: ::std::primitive::i8,
    pub microsec: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Debug, Eq, PartialOrd, Ord)]
pub enum Value {
    nVal(crate::types::NullType),
    bVal(::std::primitive::bool),
    iVal(::std::primitive::i64),
    fVal(crate::double::Double),
    sVal(::std::vec::Vec<::std::primitive::u8>),
    dVal(crate::types::Date),
    tVal(crate::types::Time),
    dtVal(crate::types::DateTime),
    vVal(Box<crate::types::Vertex>),
    eVal(crate::types::Edge),
    pVal(crate::types::Path),
    lVal(crate::types::NList),
    mVal(crate::types::NMap),
    uVal(crate::types::NSet),
    gVal(crate::types::DataSet),
    ggVal(crate::types::Geography),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NList {
    pub values: ::std::vec::Vec<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NMap {
    pub kvs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NSet {
    pub values: ::std::collections::BTreeSet<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Row {
    pub values: ::std::vec::Vec<crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct DataSet {
    pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub rows: ::std::vec::Vec<crate::types::Row>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Coordinate {
    pub x: crate::double::Double,
    pub y: crate::double::Double,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Point {
    pub coord: crate::types::Coordinate,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct LineString {
    pub coordList: ::std::vec::Vec<crate::types::Coordinate>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Polygon {
    pub coordListList: ::std::vec::Vec<::std::vec::Vec<crate::types::Coordinate>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Debug, Eq, PartialOrd, Ord)]
pub enum Geography {
    ptVal(crate::types::Point),
    lsVal(crate::types::LineString),
    pgVal(crate::types::Polygon),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Tag {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Vertex {
    pub vid: Box<crate::types::Value>,
    pub tags: ::std::vec::Vec<crate::types::Tag>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Edge {
    pub src: Box<crate::types::Value>,
    pub dst: Box<crate::types::Value>,
    pub r#type: crate::types::EdgeType,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub ranking: crate::types::EdgeRanking,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Step {
    pub dst: crate::types::Vertex,
    pub r#type: crate::types::EdgeType,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub ranking: crate::types::EdgeRanking,
    pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Path {
    pub src: crate::types::Vertex,
    pub steps: ::std::vec::Vec<crate::types::Step>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HostAddr {
    pub host: ::std::string::String,
    pub port: crate::types::Port,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyValue {
    pub key: ::std::vec::Vec<::std::primitive::u8>,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LogInfo {
    pub log_id: crate::types::LogID,
    pub term_id: crate::types::TermID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DirInfo {
    pub root: ::std::vec::Vec<::std::primitive::u8>,
    pub data: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NodeInfo {
    pub host: crate::types::HostAddr,
    pub dir: crate::types::DirInfo,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct PartitionBackupInfo {
    pub info: ::std::collections::BTreeMap<crate::types::PartitionID, crate::types::LogInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct CheckpointInfo {
    pub partition_info: crate::types::PartitionBackupInfo,
    pub path: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct NullType(pub ::std::primitive::i32);

impl NullType {
    pub const __NULL__: Self = NullType(0i32);
    pub const NaN: Self = NullType(1i32);
    pub const BAD_DATA: Self = NullType(2i32);
    pub const BAD_TYPE: Self = NullType(3i32);
    pub const ERR_OVERFLOW: Self = NullType(4i32);
    pub const UNKNOWN_PROP: Self = NullType(5i32);
    pub const DIV_BY_ZERO: Self = NullType(6i32);
    pub const OUT_OF_RANGE: Self = NullType(7i32);
}

impl ::fbthrift::ThriftEnum for NullType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::__NULL__, "__NULL__"),
            (Self::NaN, "NaN"),
            (Self::BAD_DATA, "BAD_DATA"),
            (Self::BAD_TYPE, "BAD_TYPE"),
            (Self::ERR_OVERFLOW, "ERR_OVERFLOW"),
            (Self::UNKNOWN_PROP, "UNKNOWN_PROP"),
            (Self::DIV_BY_ZERO, "DIV_BY_ZERO"),
            (Self::OUT_OF_RANGE, "OUT_OF_RANGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "__NULL__",
            "NaN",
            "BAD_DATA",
            "BAD_TYPE",
            "ERR_OVERFLOW",
            "UNKNOWN_PROP",
            "DIV_BY_ZERO",
            "OUT_OF_RANGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::__NULL__,
            Self::NaN,
            Self::BAD_DATA,
            Self::BAD_TYPE,
            Self::ERR_OVERFLOW,
            Self::UNKNOWN_PROP,
            Self::DIV_BY_ZERO,
            Self::OUT_OF_RANGE,
        ]
    }
}

impl ::std::default::Default for NullType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a NullType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a NullType) -> Self {
        x.0
    }
}

impl ::std::convert::From<NullType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: NullType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for NullType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for NullType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("__NULL__", 0),
            ("NaN", 1),
            ("BAD_DATA", 2),
            ("BAD_TYPE", 3),
            ("ERR_OVERFLOW", 4),
            ("UNKNOWN_PROP", 5),
            ("DIV_BY_ZERO", 6),
            ("OUT_OF_RANGE", 7),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for NullType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "NullType::{}", self)
    }
}

impl ::std::str::FromStr for NullType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BAD_DATA", 2),
            ("BAD_TYPE", 3),
            ("DIV_BY_ZERO", 6),
            ("ERR_OVERFLOW", 4),
            ("NaN", 1),
            ("OUT_OF_RANGE", 7),
            ("UNKNOWN_PROP", 5),
            ("__NULL__", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "NullType").map(Self)
    }
}

impl ::fbthrift::GetTType for NullType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for NullType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for NullType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ErrorCode(pub ::std::primitive::i32);

impl ErrorCode {
    pub const SUCCEEDED: Self = ErrorCode(0i32);
    pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
    pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
    pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
    pub const E_LEADER_CHANGED: Self = ErrorCode(-4i32);
    pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-5i32);
    pub const E_TAG_NOT_FOUND: Self = ErrorCode(-6i32);
    pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-7i32);
    pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-8i32);
    pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-9i32);
    pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-10i32);
    pub const E_ROLE_NOT_FOUND: Self = ErrorCode(-11i32);
    pub const E_CONFIG_NOT_FOUND: Self = ErrorCode(-12i32);
    pub const E_GROUP_NOT_FOUND: Self = ErrorCode(-13i32);
    pub const E_ZONE_NOT_FOUND: Self = ErrorCode(-14i32);
    pub const E_LISTENER_NOT_FOUND: Self = ErrorCode(-15i32);
    pub const E_PART_NOT_FOUND: Self = ErrorCode(-16i32);
    pub const E_KEY_NOT_FOUND: Self = ErrorCode(-17i32);
    pub const E_USER_NOT_FOUND: Self = ErrorCode(-18i32);
    pub const E_STATS_NOT_FOUND: Self = ErrorCode(-19i32);
    pub const E_BACKUP_FAILED: Self = ErrorCode(-24i32);
    pub const E_BACKUP_EMPTY_TABLE: Self = ErrorCode(-25i32);
    pub const E_BACKUP_TABLE_FAILED: Self = ErrorCode(-26i32);
    pub const E_PARTIAL_RESULT: Self = ErrorCode(-27i32);
    pub const E_REBUILD_INDEX_FAILED: Self = ErrorCode(-28i32);
    pub const E_INVALID_PASSWORD: Self = ErrorCode(-29i32);
    pub const E_FAILED_GET_ABS_PATH: Self = ErrorCode(-30i32);
    pub const E_BAD_USERNAME_PASSWORD: Self = ErrorCode(-1001i32);
    pub const E_SESSION_INVALID: Self = ErrorCode(-1002i32);
    pub const E_SESSION_TIMEOUT: Self = ErrorCode(-1003i32);
    pub const E_SYNTAX_ERROR: Self = ErrorCode(-1004i32);
    pub const E_EXECUTION_ERROR: Self = ErrorCode(-1005i32);
    pub const E_STATEMENT_EMPTY: Self = ErrorCode(-1006i32);
    pub const E_BAD_PERMISSION: Self = ErrorCode(-1008i32);
    pub const E_SEMANTIC_ERROR: Self = ErrorCode(-1009i32);
    pub const E_TOO_MANY_CONNECTIONS: Self = ErrorCode(-1010i32);
    pub const E_PARTIAL_SUCCEEDED: Self = ErrorCode(-1011i32);
    pub const E_NO_HOSTS: Self = ErrorCode(-2001i32);
    pub const E_EXISTED: Self = ErrorCode(-2002i32);
    pub const E_INVALID_HOST: Self = ErrorCode(-2003i32);
    pub const E_UNSUPPORTED: Self = ErrorCode(-2004i32);
    pub const E_NOT_DROP: Self = ErrorCode(-2005i32);
    pub const E_BALANCER_RUNNING: Self = ErrorCode(-2006i32);
    pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-2007i32);
    pub const E_CONFLICT: Self = ErrorCode(-2008i32);
    pub const E_INVALID_PARM: Self = ErrorCode(-2009i32);
    pub const E_WRONGCLUSTER: Self = ErrorCode(-2010i32);
    pub const E_STORE_FAILURE: Self = ErrorCode(-2021i32);
    pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-2022i32);
    pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-2023i32);
    pub const E_BALANCED: Self = ErrorCode(-2024i32);
    pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-2025i32);
    pub const E_NO_VALID_HOST: Self = ErrorCode(-2026i32);
    pub const E_CORRUPTTED_BALANCE_PLAN: Self = ErrorCode(-2027i32);
    pub const E_NO_INVALID_BALANCE_PLAN: Self = ErrorCode(-2028i32);
    pub const E_IMPROPER_ROLE: Self = ErrorCode(-2030i32);
    pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-2031i32);
    pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-2032i32);
    pub const E_INVALID_CHARSET: Self = ErrorCode(-2033i32);
    pub const E_INVALID_COLLATE: Self = ErrorCode(-2034i32);
    pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-2035i32);
    pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-2040i32);
    pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-2041i32);
    pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-2042i32);
    pub const E_INDEX_WITH_TTL: Self = ErrorCode(-2043i32);
    pub const E_ADD_JOB_FAILURE: Self = ErrorCode(-2044i32);
    pub const E_STOP_JOB_FAILURE: Self = ErrorCode(-2045i32);
    pub const E_SAVE_JOB_FAILURE: Self = ErrorCode(-2046i32);
    pub const E_BALANCER_FAILURE: Self = ErrorCode(-2047i32);
    pub const E_JOB_NOT_FINISHED: Self = ErrorCode(-2048i32);
    pub const E_TASK_REPORT_OUT_DATE: Self = ErrorCode(-2049i32);
    pub const E_JOB_NOT_IN_SPACE: Self = ErrorCode(-2050i32);
    pub const E_INVALID_JOB: Self = ErrorCode(-2065i32);
    pub const E_BACKUP_BUILDING_INDEX: Self = ErrorCode(-2066i32);
    pub const E_BACKUP_SPACE_NOT_FOUND: Self = ErrorCode(-2067i32);
    pub const E_RESTORE_FAILURE: Self = ErrorCode(-2068i32);
    pub const E_SESSION_NOT_FOUND: Self = ErrorCode(-2069i32);
    pub const E_LIST_CLUSTER_FAILURE: Self = ErrorCode(-2070i32);
    pub const E_LIST_CLUSTER_GET_ABS_PATH_FAILURE: Self = ErrorCode(-2071i32);
    pub const E_GET_META_DIR_FAILURE: Self = ErrorCode(-2072i32);
    pub const E_QUERY_NOT_FOUND: Self = ErrorCode(-2073i32);
    pub const E_CONSENSUS_ERROR: Self = ErrorCode(-3001i32);
    pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-3002i32);
    pub const E_DATA_TYPE_MISMATCH: Self = ErrorCode(-3003i32);
    pub const E_INVALID_FIELD_VALUE: Self = ErrorCode(-3004i32);
    pub const E_INVALID_OPERATION: Self = ErrorCode(-3005i32);
    pub const E_NOT_NULLABLE: Self = ErrorCode(-3006i32);
    pub const E_FIELD_UNSET: Self = ErrorCode(-3007i32);
    pub const E_OUT_OF_RANGE: Self = ErrorCode(-3008i32);
    pub const E_ATOMIC_OP_FAILED: Self = ErrorCode(-3009i32);
    pub const E_DATA_CONFLICT_ERROR: Self = ErrorCode(-3010i32);
    pub const E_WRITE_STALLED: Self = ErrorCode(-3011i32);
    pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-3021i32);
    pub const E_INVALID_SPACEVIDLEN: Self = ErrorCode(-3022i32);
    pub const E_INVALID_FILTER: Self = ErrorCode(-3031i32);
    pub const E_INVALID_UPDATER: Self = ErrorCode(-3032i32);
    pub const E_INVALID_STORE: Self = ErrorCode(-3033i32);
    pub const E_INVALID_PEER: Self = ErrorCode(-3034i32);
    pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-3035i32);
    pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-3036i32);
    pub const E_INVALID_STAT_TYPE: Self = ErrorCode(-3037i32);
    pub const E_INVALID_VID: Self = ErrorCode(-3038i32);
    pub const E_NO_TRANSFORMED: Self = ErrorCode(-3039i32);
    pub const E_LOAD_META_FAILED: Self = ErrorCode(-3040i32);
    pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-3041i32);
    pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-3042i32);
    pub const E_FILTER_OUT: Self = ErrorCode(-3043i32);
    pub const E_INVALID_DATA: Self = ErrorCode(-3044i32);
    pub const E_MUTATE_EDGE_CONFLICT: Self = ErrorCode(-3045i32);
    pub const E_MUTATE_TAG_CONFLICT: Self = ErrorCode(-3046i32);
    pub const E_OUTDATED_LOCK: Self = ErrorCode(-3047i32);
    pub const E_INVALID_TASK_PARA: Self = ErrorCode(-3051i32);
    pub const E_USER_CANCEL: Self = ErrorCode(-3052i32);
    pub const E_TASK_EXECUTION_FAILED: Self = ErrorCode(-3053i32);
    pub const E_PLAN_IS_KILLED: Self = ErrorCode(-3060i32);
    pub const E_NO_TERM: Self = ErrorCode(-3070i32);
    pub const E_OUTDATED_TERM: Self = ErrorCode(-3071i32);
    pub const E_OUTDATED_EDGE: Self = ErrorCode(-3072i32);
    pub const E_WRITE_WRITE_CONFLICT: Self = ErrorCode(-3073i32);
    pub const E_CLIENT_SERVER_INCOMPATIBLE: Self = ErrorCode(-3061i32);
    pub const E_UNKNOWN: Self = ErrorCode(-8000i32);
}

impl ::fbthrift::ThriftEnum for ErrorCode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::E_DISCONNECTED, "E_DISCONNECTED"),
            (Self::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
            (Self::E_RPC_FAILURE, "E_RPC_FAILURE"),
            (Self::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
            (Self::E_SPACE_NOT_FOUND, "E_SPACE_NOT_FOUND"),
            (Self::E_TAG_NOT_FOUND, "E_TAG_NOT_FOUND"),
            (Self::E_EDGE_NOT_FOUND, "E_EDGE_NOT_FOUND"),
            (Self::E_INDEX_NOT_FOUND, "E_INDEX_NOT_FOUND"),
            (Self::E_EDGE_PROP_NOT_FOUND, "E_EDGE_PROP_NOT_FOUND"),
            (Self::E_TAG_PROP_NOT_FOUND, "E_TAG_PROP_NOT_FOUND"),
            (Self::E_ROLE_NOT_FOUND, "E_ROLE_NOT_FOUND"),
            (Self::E_CONFIG_NOT_FOUND, "E_CONFIG_NOT_FOUND"),
            (Self::E_GROUP_NOT_FOUND, "E_GROUP_NOT_FOUND"),
            (Self::E_ZONE_NOT_FOUND, "E_ZONE_NOT_FOUND"),
            (Self::E_LISTENER_NOT_FOUND, "E_LISTENER_NOT_FOUND"),
            (Self::E_PART_NOT_FOUND, "E_PART_NOT_FOUND"),
            (Self::E_KEY_NOT_FOUND, "E_KEY_NOT_FOUND"),
            (Self::E_USER_NOT_FOUND, "E_USER_NOT_FOUND"),
            (Self::E_STATS_NOT_FOUND, "E_STATS_NOT_FOUND"),
            (Self::E_BACKUP_FAILED, "E_BACKUP_FAILED"),
            (Self::E_BACKUP_EMPTY_TABLE, "E_BACKUP_EMPTY_TABLE"),
            (Self::E_BACKUP_TABLE_FAILED, "E_BACKUP_TABLE_FAILED"),
            (Self::E_PARTIAL_RESULT, "E_PARTIAL_RESULT"),
            (Self::E_REBUILD_INDEX_FAILED, "E_REBUILD_INDEX_FAILED"),
            (Self::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
            (Self::E_FAILED_GET_ABS_PATH, "E_FAILED_GET_ABS_PATH"),
            (Self::E_BAD_USERNAME_PASSWORD, "E_BAD_USERNAME_PASSWORD"),
            (Self::E_SESSION_INVALID, "E_SESSION_INVALID"),
            (Self::E_SESSION_TIMEOUT, "E_SESSION_TIMEOUT"),
            (Self::E_SYNTAX_ERROR, "E_SYNTAX_ERROR"),
            (Self::E_EXECUTION_ERROR, "E_EXECUTION_ERROR"),
            (Self::E_STATEMENT_EMPTY, "E_STATEMENT_EMPTY"),
            (Self::E_BAD_PERMISSION, "E_BAD_PERMISSION"),
            (Self::E_SEMANTIC_ERROR, "E_SEMANTIC_ERROR"),
            (Self::E_TOO_MANY_CONNECTIONS, "E_TOO_MANY_CONNECTIONS"),
            (Self::E_PARTIAL_SUCCEEDED, "E_PARTIAL_SUCCEEDED"),
            (Self::E_NO_HOSTS, "E_NO_HOSTS"),
            (Self::E_EXISTED, "E_EXISTED"),
            (Self::E_INVALID_HOST, "E_INVALID_HOST"),
            (Self::E_UNSUPPORTED, "E_UNSUPPORTED"),
            (Self::E_NOT_DROP, "E_NOT_DROP"),
            (Self::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
            (Self::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
            (Self::E_CONFLICT, "E_CONFLICT"),
            (Self::E_INVALID_PARM, "E_INVALID_PARM"),
            (Self::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
            (Self::E_STORE_FAILURE, "E_STORE_FAILURE"),
            (Self::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
            (Self::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
            (Self::E_BALANCED, "E_BALANCED"),
            (Self::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
            (Self::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
            (Self::E_CORRUPTTED_BALANCE_PLAN, "E_CORRUPTTED_BALANCE_PLAN"),
            (Self::E_NO_INVALID_BALANCE_PLAN, "E_NO_INVALID_BALANCE_PLAN"),
            (Self::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
            (Self::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
            (Self::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
            (Self::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
            (Self::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
            (Self::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
            (Self::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
            (Self::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
            (Self::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
            (Self::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
            (Self::E_ADD_JOB_FAILURE, "E_ADD_JOB_FAILURE"),
            (Self::E_STOP_JOB_FAILURE, "E_STOP_JOB_FAILURE"),
            (Self::E_SAVE_JOB_FAILURE, "E_SAVE_JOB_FAILURE"),
            (Self::E_BALANCER_FAILURE, "E_BALANCER_FAILURE"),
            (Self::E_JOB_NOT_FINISHED, "E_JOB_NOT_FINISHED"),
            (Self::E_TASK_REPORT_OUT_DATE, "E_TASK_REPORT_OUT_DATE"),
            (Self::E_JOB_NOT_IN_SPACE, "E_JOB_NOT_IN_SPACE"),
            (Self::E_INVALID_JOB, "E_INVALID_JOB"),
            (Self::E_BACKUP_BUILDING_INDEX, "E_BACKUP_BUILDING_INDEX"),
            (Self::E_BACKUP_SPACE_NOT_FOUND, "E_BACKUP_SPACE_NOT_FOUND"),
            (Self::E_RESTORE_FAILURE, "E_RESTORE_FAILURE"),
            (Self::E_SESSION_NOT_FOUND, "E_SESSION_NOT_FOUND"),
            (Self::E_LIST_CLUSTER_FAILURE, "E_LIST_CLUSTER_FAILURE"),
            (Self::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE, "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE"),
            (Self::E_GET_META_DIR_FAILURE, "E_GET_META_DIR_FAILURE"),
            (Self::E_QUERY_NOT_FOUND, "E_QUERY_NOT_FOUND"),
            (Self::E_CONSENSUS_ERROR, "E_CONSENSUS_ERROR"),
            (Self::E_KEY_HAS_EXISTS, "E_KEY_HAS_EXISTS"),
            (Self::E_DATA_TYPE_MISMATCH, "E_DATA_TYPE_MISMATCH"),
            (Self::E_INVALID_FIELD_VALUE, "E_INVALID_FIELD_VALUE"),
            (Self::E_INVALID_OPERATION, "E_INVALID_OPERATION"),
            (Self::E_NOT_NULLABLE, "E_NOT_NULLABLE"),
            (Self::E_FIELD_UNSET, "E_FIELD_UNSET"),
            (Self::E_OUT_OF_RANGE, "E_OUT_OF_RANGE"),
            (Self::E_ATOMIC_OP_FAILED, "E_ATOMIC_OP_FAILED"),
            (Self::E_DATA_CONFLICT_ERROR, "E_DATA_CONFLICT_ERROR"),
            (Self::E_WRITE_STALLED, "E_WRITE_STALLED"),
            (Self::E_IMPROPER_DATA_TYPE, "E_IMPROPER_DATA_TYPE"),
            (Self::E_INVALID_SPACEVIDLEN, "E_INVALID_SPACEVIDLEN"),
            (Self::E_INVALID_FILTER, "E_INVALID_FILTER"),
            (Self::E_INVALID_UPDATER, "E_INVALID_UPDATER"),
            (Self::E_INVALID_STORE, "E_INVALID_STORE"),
            (Self::E_INVALID_PEER, "E_INVALID_PEER"),
            (Self::E_RETRY_EXHAUSTED, "E_RETRY_EXHAUSTED"),
            (Self::E_TRANSFER_LEADER_FAILED, "E_TRANSFER_LEADER_FAILED"),
            (Self::E_INVALID_STAT_TYPE, "E_INVALID_STAT_TYPE"),
            (Self::E_INVALID_VID, "E_INVALID_VID"),
            (Self::E_NO_TRANSFORMED, "E_NO_TRANSFORMED"),
            (Self::E_LOAD_META_FAILED, "E_LOAD_META_FAILED"),
            (Self::E_FAILED_TO_CHECKPOINT, "E_FAILED_TO_CHECKPOINT"),
            (Self::E_CHECKPOINT_BLOCKED, "E_CHECKPOINT_BLOCKED"),
            (Self::E_FILTER_OUT, "E_FILTER_OUT"),
            (Self::E_INVALID_DATA, "E_INVALID_DATA"),
            (Self::E_MUTATE_EDGE_CONFLICT, "E_MUTATE_EDGE_CONFLICT"),
            (Self::E_MUTATE_TAG_CONFLICT, "E_MUTATE_TAG_CONFLICT"),
            (Self::E_OUTDATED_LOCK, "E_OUTDATED_LOCK"),
            (Self::E_INVALID_TASK_PARA, "E_INVALID_TASK_PARA"),
            (Self::E_USER_CANCEL, "E_USER_CANCEL"),
            (Self::E_TASK_EXECUTION_FAILED, "E_TASK_EXECUTION_FAILED"),
            (Self::E_PLAN_IS_KILLED, "E_PLAN_IS_KILLED"),
            (Self::E_NO_TERM, "E_NO_TERM"),
            (Self::E_OUTDATED_TERM, "E_OUTDATED_TERM"),
            (Self::E_OUTDATED_EDGE, "E_OUTDATED_EDGE"),
            (Self::E_WRITE_WRITE_CONFLICT, "E_WRITE_WRITE_CONFLICT"),
            (Self::E_CLIENT_SERVER_INCOMPATIBLE, "E_CLIENT_SERVER_INCOMPATIBLE"),
            (Self::E_UNKNOWN, "E_UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "E_DISCONNECTED",
            "E_FAIL_TO_CONNECT",
            "E_RPC_FAILURE",
            "E_LEADER_CHANGED",
            "E_SPACE_NOT_FOUND",
            "E_TAG_NOT_FOUND",
            "E_EDGE_NOT_FOUND",
            "E_INDEX_NOT_FOUND",
            "E_EDGE_PROP_NOT_FOUND",
            "E_TAG_PROP_NOT_FOUND",
            "E_ROLE_NOT_FOUND",
            "E_CONFIG_NOT_FOUND",
            "E_GROUP_NOT_FOUND",
            "E_ZONE_NOT_FOUND",
            "E_LISTENER_NOT_FOUND",
            "E_PART_NOT_FOUND",
            "E_KEY_NOT_FOUND",
            "E_USER_NOT_FOUND",
            "E_STATS_NOT_FOUND",
            "E_BACKUP_FAILED",
            "E_BACKUP_EMPTY_TABLE",
            "E_BACKUP_TABLE_FAILED",
            "E_PARTIAL_RESULT",
            "E_REBUILD_INDEX_FAILED",
            "E_INVALID_PASSWORD",
            "E_FAILED_GET_ABS_PATH",
            "E_BAD_USERNAME_PASSWORD",
            "E_SESSION_INVALID",
            "E_SESSION_TIMEOUT",
            "E_SYNTAX_ERROR",
            "E_EXECUTION_ERROR",
            "E_STATEMENT_EMPTY",
            "E_BAD_PERMISSION",
            "E_SEMANTIC_ERROR",
            "E_TOO_MANY_CONNECTIONS",
            "E_PARTIAL_SUCCEEDED",
            "E_NO_HOSTS",
            "E_EXISTED",
            "E_INVALID_HOST",
            "E_UNSUPPORTED",
            "E_NOT_DROP",
            "E_BALANCER_RUNNING",
            "E_CONFIG_IMMUTABLE",
            "E_CONFLICT",
            "E_INVALID_PARM",
            "E_WRONGCLUSTER",
            "E_STORE_FAILURE",
            "E_STORE_SEGMENT_ILLEGAL",
            "E_BAD_BALANCE_PLAN",
            "E_BALANCED",
            "E_NO_RUNNING_BALANCE_PLAN",
            "E_NO_VALID_HOST",
            "E_CORRUPTTED_BALANCE_PLAN",
            "E_NO_INVALID_BALANCE_PLAN",
            "E_IMPROPER_ROLE",
            "E_INVALID_PARTITION_NUM",
            "E_INVALID_REPLICA_FACTOR",
            "E_INVALID_CHARSET",
            "E_INVALID_COLLATE",
            "E_CHARSET_COLLATE_NOT_MATCH",
            "E_SNAPSHOT_FAILURE",
            "E_BLOCK_WRITE_FAILURE",
            "E_REBUILD_INDEX_FAILURE",
            "E_INDEX_WITH_TTL",
            "E_ADD_JOB_FAILURE",
            "E_STOP_JOB_FAILURE",
            "E_SAVE_JOB_FAILURE",
            "E_BALANCER_FAILURE",
            "E_JOB_NOT_FINISHED",
            "E_TASK_REPORT_OUT_DATE",
            "E_JOB_NOT_IN_SPACE",
            "E_INVALID_JOB",
            "E_BACKUP_BUILDING_INDEX",
            "E_BACKUP_SPACE_NOT_FOUND",
            "E_RESTORE_FAILURE",
            "E_SESSION_NOT_FOUND",
            "E_LIST_CLUSTER_FAILURE",
            "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE",
            "E_GET_META_DIR_FAILURE",
            "E_QUERY_NOT_FOUND",
            "E_CONSENSUS_ERROR",
            "E_KEY_HAS_EXISTS",
            "E_DATA_TYPE_MISMATCH",
            "E_INVALID_FIELD_VALUE",
            "E_INVALID_OPERATION",
            "E_NOT_NULLABLE",
            "E_FIELD_UNSET",
            "E_OUT_OF_RANGE",
            "E_ATOMIC_OP_FAILED",
            "E_DATA_CONFLICT_ERROR",
            "E_WRITE_STALLED",
            "E_IMPROPER_DATA_TYPE",
            "E_INVALID_SPACEVIDLEN",
            "E_INVALID_FILTER",
            "E_INVALID_UPDATER",
            "E_INVALID_STORE",
            "E_INVALID_PEER",
            "E_RETRY_EXHAUSTED",
            "E_TRANSFER_LEADER_FAILED",
            "E_INVALID_STAT_TYPE",
            "E_INVALID_VID",
            "E_NO_TRANSFORMED",
            "E_LOAD_META_FAILED",
            "E_FAILED_TO_CHECKPOINT",
            "E_CHECKPOINT_BLOCKED",
            "E_FILTER_OUT",
            "E_INVALID_DATA",
            "E_MUTATE_EDGE_CONFLICT",
            "E_MUTATE_TAG_CONFLICT",
            "E_OUTDATED_LOCK",
            "E_INVALID_TASK_PARA",
            "E_USER_CANCEL",
            "E_TASK_EXECUTION_FAILED",
            "E_PLAN_IS_KILLED",
            "E_NO_TERM",
            "E_OUTDATED_TERM",
            "E_OUTDATED_EDGE",
            "E_WRITE_WRITE_CONFLICT",
            "E_CLIENT_SERVER_INCOMPATIBLE",
            "E_UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::E_DISCONNECTED,
            Self::E_FAIL_TO_CONNECT,
            Self::E_RPC_FAILURE,
            Self::E_LEADER_CHANGED,
            Self::E_SPACE_NOT_FOUND,
            Self::E_TAG_NOT_FOUND,
            Self::E_EDGE_NOT_FOUND,
            Self::E_INDEX_NOT_FOUND,
            Self::E_EDGE_PROP_NOT_FOUND,
            Self::E_TAG_PROP_NOT_FOUND,
            Self::E_ROLE_NOT_FOUND,
            Self::E_CONFIG_NOT_FOUND,
            Self::E_GROUP_NOT_FOUND,
            Self::E_ZONE_NOT_FOUND,
            Self::E_LISTENER_NOT_FOUND,
            Self::E_PART_NOT_FOUND,
            Self::E_KEY_NOT_FOUND,
            Self::E_USER_NOT_FOUND,
            Self::E_STATS_NOT_FOUND,
            Self::E_BACKUP_FAILED,
            Self::E_BACKUP_EMPTY_TABLE,
            Self::E_BACKUP_TABLE_FAILED,
            Self::E_PARTIAL_RESULT,
            Self::E_REBUILD_INDEX_FAILED,
            Self::E_INVALID_PASSWORD,
            Self::E_FAILED_GET_ABS_PATH,
            Self::E_BAD_USERNAME_PASSWORD,
            Self::E_SESSION_INVALID,
            Self::E_SESSION_TIMEOUT,
            Self::E_SYNTAX_ERROR,
            Self::E_EXECUTION_ERROR,
            Self::E_STATEMENT_EMPTY,
            Self::E_BAD_PERMISSION,
            Self::E_SEMANTIC_ERROR,
            Self::E_TOO_MANY_CONNECTIONS,
            Self::E_PARTIAL_SUCCEEDED,
            Self::E_NO_HOSTS,
            Self::E_EXISTED,
            Self::E_INVALID_HOST,
            Self::E_UNSUPPORTED,
            Self::E_NOT_DROP,
            Self::E_BALANCER_RUNNING,
            Self::E_CONFIG_IMMUTABLE,
            Self::E_CONFLICT,
            Self::E_INVALID_PARM,
            Self::E_WRONGCLUSTER,
            Self::E_STORE_FAILURE,
            Self::E_STORE_SEGMENT_ILLEGAL,
            Self::E_BAD_BALANCE_PLAN,
            Self::E_BALANCED,
            Self::E_NO_RUNNING_BALANCE_PLAN,
            Self::E_NO_VALID_HOST,
            Self::E_CORRUPTTED_BALANCE_PLAN,
            Self::E_NO_INVALID_BALANCE_PLAN,
            Self::E_IMPROPER_ROLE,
            Self::E_INVALID_PARTITION_NUM,
            Self::E_INVALID_REPLICA_FACTOR,
            Self::E_INVALID_CHARSET,
            Self::E_INVALID_COLLATE,
            Self::E_CHARSET_COLLATE_NOT_MATCH,
            Self::E_SNAPSHOT_FAILURE,
            Self::E_BLOCK_WRITE_FAILURE,
            Self::E_REBUILD_INDEX_FAILURE,
            Self::E_INDEX_WITH_TTL,
            Self::E_ADD_JOB_FAILURE,
            Self::E_STOP_JOB_FAILURE,
            Self::E_SAVE_JOB_FAILURE,
            Self::E_BALANCER_FAILURE,
            Self::E_JOB_NOT_FINISHED,
            Self::E_TASK_REPORT_OUT_DATE,
            Self::E_JOB_NOT_IN_SPACE,
            Self::E_INVALID_JOB,
            Self::E_BACKUP_BUILDING_INDEX,
            Self::E_BACKUP_SPACE_NOT_FOUND,
            Self::E_RESTORE_FAILURE,
            Self::E_SESSION_NOT_FOUND,
            Self::E_LIST_CLUSTER_FAILURE,
            Self::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE,
            Self::E_GET_META_DIR_FAILURE,
            Self::E_QUERY_NOT_FOUND,
            Self::E_CONSENSUS_ERROR,
            Self::E_KEY_HAS_EXISTS,
            Self::E_DATA_TYPE_MISMATCH,
            Self::E_INVALID_FIELD_VALUE,
            Self::E_INVALID_OPERATION,
            Self::E_NOT_NULLABLE,
            Self::E_FIELD_UNSET,
            Self::E_OUT_OF_RANGE,
            Self::E_ATOMIC_OP_FAILED,
            Self::E_DATA_CONFLICT_ERROR,
            Self::E_WRITE_STALLED,
            Self::E_IMPROPER_DATA_TYPE,
            Self::E_INVALID_SPACEVIDLEN,
            Self::E_INVALID_FILTER,
            Self::E_INVALID_UPDATER,
            Self::E_INVALID_STORE,
            Self::E_INVALID_PEER,
            Self::E_RETRY_EXHAUSTED,
            Self::E_TRANSFER_LEADER_FAILED,
            Self::E_INVALID_STAT_TYPE,
            Self::E_INVALID_VID,
            Self::E_NO_TRANSFORMED,
            Self::E_LOAD_META_FAILED,
            Self::E_FAILED_TO_CHECKPOINT,
            Self::E_CHECKPOINT_BLOCKED,
            Self::E_FILTER_OUT,
            Self::E_INVALID_DATA,
            Self::E_MUTATE_EDGE_CONFLICT,
            Self::E_MUTATE_TAG_CONFLICT,
            Self::E_OUTDATED_LOCK,
            Self::E_INVALID_TASK_PARA,
            Self::E_USER_CANCEL,
            Self::E_TASK_EXECUTION_FAILED,
            Self::E_PLAN_IS_KILLED,
            Self::E_NO_TERM,
            Self::E_OUTDATED_TERM,
            Self::E_OUTDATED_EDGE,
            Self::E_WRITE_WRITE_CONFLICT,
            Self::E_CLIENT_SERVER_INCOMPATIBLE,
            Self::E_UNKNOWN,
        ]
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ErrorCode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_UNKNOWN", -8000),
            ("E_WRITE_WRITE_CONFLICT", -3073),
            ("E_OUTDATED_EDGE", -3072),
            ("E_OUTDATED_TERM", -3071),
            ("E_NO_TERM", -3070),
            ("E_CLIENT_SERVER_INCOMPATIBLE", -3061),
            ("E_PLAN_IS_KILLED", -3060),
            ("E_TASK_EXECUTION_FAILED", -3053),
            ("E_USER_CANCEL", -3052),
            ("E_INVALID_TASK_PARA", -3051),
            ("E_OUTDATED_LOCK", -3047),
            ("E_MUTATE_TAG_CONFLICT", -3046),
            ("E_MUTATE_EDGE_CONFLICT", -3045),
            ("E_INVALID_DATA", -3044),
            ("E_FILTER_OUT", -3043),
            ("E_CHECKPOINT_BLOCKED", -3042),
            ("E_FAILED_TO_CHECKPOINT", -3041),
            ("E_LOAD_META_FAILED", -3040),
            ("E_NO_TRANSFORMED", -3039),
            ("E_INVALID_VID", -3038),
            ("E_INVALID_STAT_TYPE", -3037),
            ("E_TRANSFER_LEADER_FAILED", -3036),
            ("E_RETRY_EXHAUSTED", -3035),
            ("E_INVALID_PEER", -3034),
            ("E_INVALID_STORE", -3033),
            ("E_INVALID_UPDATER", -3032),
            ("E_INVALID_FILTER", -3031),
            ("E_INVALID_SPACEVIDLEN", -3022),
            ("E_IMPROPER_DATA_TYPE", -3021),
            ("E_WRITE_STALLED", -3011),
            ("E_DATA_CONFLICT_ERROR", -3010),
            ("E_ATOMIC_OP_FAILED", -3009),
            ("E_OUT_OF_RANGE", -3008),
            ("E_FIELD_UNSET", -3007),
            ("E_NOT_NULLABLE", -3006),
            ("E_INVALID_OPERATION", -3005),
            ("E_INVALID_FIELD_VALUE", -3004),
            ("E_DATA_TYPE_MISMATCH", -3003),
            ("E_KEY_HAS_EXISTS", -3002),
            ("E_CONSENSUS_ERROR", -3001),
            ("E_QUERY_NOT_FOUND", -2073),
            ("E_GET_META_DIR_FAILURE", -2072),
            ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
            ("E_LIST_CLUSTER_FAILURE", -2070),
            ("E_SESSION_NOT_FOUND", -2069),
            ("E_RESTORE_FAILURE", -2068),
            ("E_BACKUP_SPACE_NOT_FOUND", -2067),
            ("E_BACKUP_BUILDING_INDEX", -2066),
            ("E_INVALID_JOB", -2065),
            ("E_JOB_NOT_IN_SPACE", -2050),
            ("E_TASK_REPORT_OUT_DATE", -2049),
            ("E_JOB_NOT_FINISHED", -2048),
            ("E_BALANCER_FAILURE", -2047),
            ("E_SAVE_JOB_FAILURE", -2046),
            ("E_STOP_JOB_FAILURE", -2045),
            ("E_ADD_JOB_FAILURE", -2044),
            ("E_INDEX_WITH_TTL", -2043),
            ("E_REBUILD_INDEX_FAILURE", -2042),
            ("E_BLOCK_WRITE_FAILURE", -2041),
            ("E_SNAPSHOT_FAILURE", -2040),
            ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
            ("E_INVALID_COLLATE", -2034),
            ("E_INVALID_CHARSET", -2033),
            ("E_INVALID_REPLICA_FACTOR", -2032),
            ("E_INVALID_PARTITION_NUM", -2031),
            ("E_IMPROPER_ROLE", -2030),
            ("E_NO_INVALID_BALANCE_PLAN", -2028),
            ("E_CORRUPTTED_BALANCE_PLAN", -2027),
            ("E_NO_VALID_HOST", -2026),
            ("E_NO_RUNNING_BALANCE_PLAN", -2025),
            ("E_BALANCED", -2024),
            ("E_BAD_BALANCE_PLAN", -2023),
            ("E_STORE_SEGMENT_ILLEGAL", -2022),
            ("E_STORE_FAILURE", -2021),
            ("E_WRONGCLUSTER", -2010),
            ("E_INVALID_PARM", -2009),
            ("E_CONFLICT", -2008),
            ("E_CONFIG_IMMUTABLE", -2007),
            ("E_BALANCER_RUNNING", -2006),
            ("E_NOT_DROP", -2005),
            ("E_UNSUPPORTED", -2004),
            ("E_INVALID_HOST", -2003),
            ("E_EXISTED", -2002),
            ("E_NO_HOSTS", -2001),
            ("E_PARTIAL_SUCCEEDED", -1011),
            ("E_TOO_MANY_CONNECTIONS", -1010),
            ("E_SEMANTIC_ERROR", -1009),
            ("E_BAD_PERMISSION", -1008),
            ("E_STATEMENT_EMPTY", -1006),
            ("E_EXECUTION_ERROR", -1005),
            ("E_SYNTAX_ERROR", -1004),
            ("E_SESSION_TIMEOUT", -1003),
            ("E_SESSION_INVALID", -1002),
            ("E_BAD_USERNAME_PASSWORD", -1001),
            ("E_FAILED_GET_ABS_PATH", -30),
            ("E_INVALID_PASSWORD", -29),
            ("E_REBUILD_INDEX_FAILED", -28),
            ("E_PARTIAL_RESULT", -27),
            ("E_BACKUP_TABLE_FAILED", -26),
            ("E_BACKUP_EMPTY_TABLE", -25),
            ("E_BACKUP_FAILED", -24),
            ("E_STATS_NOT_FOUND", -19),
            ("E_USER_NOT_FOUND", -18),
            ("E_KEY_NOT_FOUND", -17),
            ("E_PART_NOT_FOUND", -16),
            ("E_LISTENER_NOT_FOUND", -15),
            ("E_ZONE_NOT_FOUND", -14),
            ("E_GROUP_NOT_FOUND", -13),
            ("E_CONFIG_NOT_FOUND", -12),
            ("E_ROLE_NOT_FOUND", -11),
            ("E_TAG_PROP_NOT_FOUND", -10),
            ("E_EDGE_PROP_NOT_FOUND", -9),
            ("E_INDEX_NOT_FOUND", -8),
            ("E_EDGE_NOT_FOUND", -7),
            ("E_TAG_NOT_FOUND", -6),
            ("E_SPACE_NOT_FOUND", -5),
            ("E_LEADER_CHANGED", -4),
            ("E_RPC_FAILURE", -3),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_DISCONNECTED", -1),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ErrorCode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ErrorCode::{}", self)
    }
}

impl ::std::str::FromStr for ErrorCode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("E_ADD_JOB_FAILURE", -2044),
            ("E_ATOMIC_OP_FAILED", -3009),
            ("E_BACKUP_BUILDING_INDEX", -2066),
            ("E_BACKUP_EMPTY_TABLE", -25),
            ("E_BACKUP_FAILED", -24),
            ("E_BACKUP_SPACE_NOT_FOUND", -2067),
            ("E_BACKUP_TABLE_FAILED", -26),
            ("E_BAD_BALANCE_PLAN", -2023),
            ("E_BAD_PERMISSION", -1008),
            ("E_BAD_USERNAME_PASSWORD", -1001),
            ("E_BALANCED", -2024),
            ("E_BALANCER_FAILURE", -2047),
            ("E_BALANCER_RUNNING", -2006),
            ("E_BLOCK_WRITE_FAILURE", -2041),
            ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
            ("E_CHECKPOINT_BLOCKED", -3042),
            ("E_CLIENT_SERVER_INCOMPATIBLE", -3061),
            ("E_CONFIG_IMMUTABLE", -2007),
            ("E_CONFIG_NOT_FOUND", -12),
            ("E_CONFLICT", -2008),
            ("E_CONSENSUS_ERROR", -3001),
            ("E_CORRUPTTED_BALANCE_PLAN", -2027),
            ("E_DATA_CONFLICT_ERROR", -3010),
            ("E_DATA_TYPE_MISMATCH", -3003),
            ("E_DISCONNECTED", -1),
            ("E_EDGE_NOT_FOUND", -7),
            ("E_EDGE_PROP_NOT_FOUND", -9),
            ("E_EXECUTION_ERROR", -1005),
            ("E_EXISTED", -2002),
            ("E_FAILED_GET_ABS_PATH", -30),
            ("E_FAILED_TO_CHECKPOINT", -3041),
            ("E_FAIL_TO_CONNECT", -2),
            ("E_FIELD_UNSET", -3007),
            ("E_FILTER_OUT", -3043),
            ("E_GET_META_DIR_FAILURE", -2072),
            ("E_GROUP_NOT_FOUND", -13),
            ("E_IMPROPER_DATA_TYPE", -3021),
            ("E_IMPROPER_ROLE", -2030),
            ("E_INDEX_NOT_FOUND", -8),
            ("E_INDEX_WITH_TTL", -2043),
            ("E_INVALID_CHARSET", -2033),
            ("E_INVALID_COLLATE", -2034),
            ("E_INVALID_DATA", -3044),
            ("E_INVALID_FIELD_VALUE", -3004),
            ("E_INVALID_FILTER", -3031),
            ("E_INVALID_HOST", -2003),
            ("E_INVALID_JOB", -2065),
            ("E_INVALID_OPERATION", -3005),
            ("E_INVALID_PARM", -2009),
            ("E_INVALID_PARTITION_NUM", -2031),
            ("E_INVALID_PASSWORD", -29),
            ("E_INVALID_PEER", -3034),
            ("E_INVALID_REPLICA_FACTOR", -2032),
            ("E_INVALID_SPACEVIDLEN", -3022),
            ("E_INVALID_STAT_TYPE", -3037),
            ("E_INVALID_STORE", -3033),
            ("E_INVALID_TASK_PARA", -3051),
            ("E_INVALID_UPDATER", -3032),
            ("E_INVALID_VID", -3038),
            ("E_JOB_NOT_FINISHED", -2048),
            ("E_JOB_NOT_IN_SPACE", -2050),
            ("E_KEY_HAS_EXISTS", -3002),
            ("E_KEY_NOT_FOUND", -17),
            ("E_LEADER_CHANGED", -4),
            ("E_LISTENER_NOT_FOUND", -15),
            ("E_LIST_CLUSTER_FAILURE", -2070),
            ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
            ("E_LOAD_META_FAILED", -3040),
            ("E_MUTATE_EDGE_CONFLICT", -3045),
            ("E_MUTATE_TAG_CONFLICT", -3046),
            ("E_NOT_DROP", -2005),
            ("E_NOT_NULLABLE", -3006),
            ("E_NO_HOSTS", -2001),
            ("E_NO_INVALID_BALANCE_PLAN", -2028),
            ("E_NO_RUNNING_BALANCE_PLAN", -2025),
            ("E_NO_TERM", -3070),
            ("E_NO_TRANSFORMED", -3039),
            ("E_NO_VALID_HOST", -2026),
            ("E_OUTDATED_EDGE", -3072),
            ("E_OUTDATED_LOCK", -3047),
            ("E_OUTDATED_TERM", -3071),
            ("E_OUT_OF_RANGE", -3008),
            ("E_PARTIAL_RESULT", -27),
            ("E_PARTIAL_SUCCEEDED", -1011),
            ("E_PART_NOT_FOUND", -16),
            ("E_PLAN_IS_KILLED", -3060),
            ("E_QUERY_NOT_FOUND", -2073),
            ("E_REBUILD_INDEX_FAILED", -28),
            ("E_REBUILD_INDEX_FAILURE", -2042),
            ("E_RESTORE_FAILURE", -2068),
            ("E_RETRY_EXHAUSTED", -3035),
            ("E_ROLE_NOT_FOUND", -11),
            ("E_RPC_FAILURE", -3),
            ("E_SAVE_JOB_FAILURE", -2046),
            ("E_SEMANTIC_ERROR", -1009),
            ("E_SESSION_INVALID", -1002),
            ("E_SESSION_NOT_FOUND", -2069),
            ("E_SESSION_TIMEOUT", -1003),
            ("E_SNAPSHOT_FAILURE", -2040),
            ("E_SPACE_NOT_FOUND", -5),
            ("E_STATEMENT_EMPTY", -1006),
            ("E_STATS_NOT_FOUND", -19),
            ("E_STOP_JOB_FAILURE", -2045),
            ("E_STORE_FAILURE", -2021),
            ("E_STORE_SEGMENT_ILLEGAL", -2022),
            ("E_SYNTAX_ERROR", -1004),
            ("E_TAG_NOT_FOUND", -6),
            ("E_TAG_PROP_NOT_FOUND", -10),
            ("E_TASK_EXECUTION_FAILED", -3053),
            ("E_TASK_REPORT_OUT_DATE", -2049),
            ("E_TOO_MANY_CONNECTIONS", -1010),
            ("E_TRANSFER_LEADER_FAILED", -3036),
            ("E_UNKNOWN", -8000),
            ("E_UNSUPPORTED", -2004),
            ("E_USER_CANCEL", -3052),
            ("E_USER_NOT_FOUND", -18),
            ("E_WRITE_STALLED", -3011),
            ("E_WRITE_WRITE_CONFLICT", -3073),
            ("E_WRONGCLUSTER", -2010),
            ("E_ZONE_NOT_FOUND", -14),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(Self)
    }
}

impl ::fbthrift::GetTType for ErrorCode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ErrorCode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}














impl ::std::default::Default for SchemaID {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for SchemaID {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for SchemaID
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SchemaID");
        match self {
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for SchemaID
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "SchemaID",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Date {
    fn default() -> Self {
        Self {
            year: ::std::default::Default::default(),
            month: ::std::default::Default::default(),
            day: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Date {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Date")
            .field("year", &self.year)
            .field("month", &self.month)
            .field("day", &self.day)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Date {}
unsafe impl ::std::marker::Sync for self::Date {}

impl ::fbthrift::GetTType for self::Date {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Date
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Date");
        p.write_field_begin("year", ::fbthrift::TType::I16, 1);
        ::fbthrift::Serialize::write(&self.year, p);
        p.write_field_end();
        p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.month, p);
        p.write_field_end();
        p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.day, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Date
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
            ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
        ];
        let mut field_year = ::std::option::Option::None;
        let mut field_month = ::std::option::Option::None;
        let mut field_day = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            year: field_year.unwrap_or_default(),
            month: field_month.unwrap_or_default(),
            day: field_day.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Time {
    fn default() -> Self {
        Self {
            hour: ::std::default::Default::default(),
            minute: ::std::default::Default::default(),
            sec: ::std::default::Default::default(),
            microsec: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Time {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Time")
            .field("hour", &self.hour)
            .field("minute", &self.minute)
            .field("sec", &self.sec)
            .field("microsec", &self.microsec)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Time {}
unsafe impl ::std::marker::Sync for self::Time {}

impl ::fbthrift::GetTType for self::Time {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Time
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Time");
        p.write_field_begin("hour", ::fbthrift::TType::Byte, 1);
        ::fbthrift::Serialize::write(&self.hour, p);
        p.write_field_end();
        p.write_field_begin("minute", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.minute, p);
        p.write_field_end();
        p.write_field_begin("sec", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.sec, p);
        p.write_field_end();
        p.write_field_begin("microsec", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.microsec, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Time
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 1),
            ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 3),
        ];
        let mut field_hour = ::std::option::Option::None;
        let mut field_minute = ::std::option::Option::None;
        let mut field_sec = ::std::option::Option::None;
        let mut field_microsec = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Byte, 1) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hour: field_hour.unwrap_or_default(),
            minute: field_minute.unwrap_or_default(),
            sec: field_sec.unwrap_or_default(),
            microsec: field_microsec.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DateTime {
    fn default() -> Self {
        Self {
            year: ::std::default::Default::default(),
            month: ::std::default::Default::default(),
            day: ::std::default::Default::default(),
            hour: ::std::default::Default::default(),
            minute: ::std::default::Default::default(),
            sec: ::std::default::Default::default(),
            microsec: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DateTime {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DateTime")
            .field("year", &self.year)
            .field("month", &self.month)
            .field("day", &self.day)
            .field("hour", &self.hour)
            .field("minute", &self.minute)
            .field("sec", &self.sec)
            .field("microsec", &self.microsec)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DateTime {}
unsafe impl ::std::marker::Sync for self::DateTime {}

impl ::fbthrift::GetTType for self::DateTime {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DateTime
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DateTime");
        p.write_field_begin("year", ::fbthrift::TType::I16, 1);
        ::fbthrift::Serialize::write(&self.year, p);
        p.write_field_end();
        p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.month, p);
        p.write_field_end();
        p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
        ::fbthrift::Serialize::write(&self.day, p);
        p.write_field_end();
        p.write_field_begin("hour", ::fbthrift::TType::Byte, 4);
        ::fbthrift::Serialize::write(&self.hour, p);
        p.write_field_end();
        p.write_field_begin("minute", ::fbthrift::TType::Byte, 5);
        ::fbthrift::Serialize::write(&self.minute, p);
        p.write_field_end();
        p.write_field_begin("sec", ::fbthrift::TType::Byte, 6);
        ::fbthrift::Serialize::write(&self.sec, p);
        p.write_field_end();
        p.write_field_begin("microsec", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.microsec, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DateTime
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
            ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 4),
            ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 5),
            ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 6),
            ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
        ];
        let mut field_year = ::std::option::Option::None;
        let mut field_month = ::std::option::Option::None;
        let mut field_day = ::std::option::Option::None;
        let mut field_hour = ::std::option::Option::None;
        let mut field_minute = ::std::option::Option::None;
        let mut field_sec = ::std::option::Option::None;
        let mut field_microsec = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 4) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 5) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 6) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            year: field_year.unwrap_or_default(),
            month: field_month.unwrap_or_default(),
            day: field_day.unwrap_or_default(),
            hour: field_hour.unwrap_or_default(),
            minute: field_minute.unwrap_or_default(),
            sec: field_sec.unwrap_or_default(),
            microsec: field_microsec.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}



impl ::std::default::Default for Value {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for Value {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for Value
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Value");
        match self {
            Self::nVal(inner) => {
                p.write_field_begin("nVal", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::bVal(inner) => {
                p.write_field_begin("bVal", ::fbthrift::TType::Bool, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::iVal(inner) => {
                p.write_field_begin("iVal", ::fbthrift::TType::I64, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::fVal(inner) => {
                p.write_field_begin("fVal", ::fbthrift::TType::Double, 4);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::sVal(inner) => {
                p.write_field_begin("sVal", ::fbthrift::TType::String, 5);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::dVal(inner) => {
                p.write_field_begin("dVal", ::fbthrift::TType::Struct, 6);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::tVal(inner) => {
                p.write_field_begin("tVal", ::fbthrift::TType::Struct, 7);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::dtVal(inner) => {
                p.write_field_begin("dtVal", ::fbthrift::TType::Struct, 8);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::vVal(inner) => {
                p.write_field_begin("vVal", ::fbthrift::TType::Struct, 9);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::eVal(inner) => {
                p.write_field_begin("eVal", ::fbthrift::TType::Struct, 10);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::pVal(inner) => {
                p.write_field_begin("pVal", ::fbthrift::TType::Struct, 11);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::lVal(inner) => {
                p.write_field_begin("lVal", ::fbthrift::TType::Struct, 12);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::mVal(inner) => {
                p.write_field_begin("mVal", ::fbthrift::TType::Struct, 13);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::uVal(inner) => {
                p.write_field_begin("uVal", ::fbthrift::TType::Struct, 14);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::gVal(inner) => {
                p.write_field_begin("gVal", ::fbthrift::TType::Struct, 15);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::ggVal(inner) => {
                p.write_field_begin("ggVal", ::fbthrift::TType::Struct, 16);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for Value
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("bVal", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("dVal", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("dtVal", ::fbthrift::TType::Struct, 8),
            ::fbthrift::Field::new("eVal", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("fVal", ::fbthrift::TType::Double, 4),
            ::fbthrift::Field::new("gVal", ::fbthrift::TType::Struct, 15),
            ::fbthrift::Field::new("ggVal", ::fbthrift::TType::Struct, 16),
            ::fbthrift::Field::new("iVal", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("lVal", ::fbthrift::TType::Struct, 12),
            ::fbthrift::Field::new("mVal", ::fbthrift::TType::Struct, 13),
            ::fbthrift::Field::new("nVal", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("pVal", ::fbthrift::TType::Struct, 11),
            ::fbthrift::Field::new("sVal", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("tVal", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("uVal", ::fbthrift::TType::Struct, 14),
            ::fbthrift::Field::new("vVal", ::fbthrift::TType::Struct, 9),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::nVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Bool, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::bVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I64, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::iVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Double, 4, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::fVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::String, 5, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::sVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 6, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::dVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 7, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 8, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::dtVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 9, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::vVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 10, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::eVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 11, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::pVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 12, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::lVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 13, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::mVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 14, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::uVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 15, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::gVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 16, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::ggVal(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "Value",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NList {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NList {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NList")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NList {}
unsafe impl ::std::marker::Sync for self::NList {}

impl ::fbthrift::GetTType for self::NList {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NList
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NList");
        p.write_field_begin("values", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NList
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NMap {
    fn default() -> Self {
        Self {
            kvs: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NMap {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NMap")
            .field("kvs", &self.kvs)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NMap {}
unsafe impl ::std::marker::Sync for self::NMap {}

impl ::fbthrift::GetTType for self::NMap {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NMap
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NMap");
        p.write_field_begin("kvs", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.kvs, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NMap
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("kvs", ::fbthrift::TType::Map, 1),
        ];
        let mut field_kvs = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_kvs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            kvs: field_kvs.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NSet {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NSet {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NSet")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NSet {}
unsafe impl ::std::marker::Sync for self::NSet {}

impl ::fbthrift::GetTType for self::NSet {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NSet
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NSet");
        p.write_field_begin("values", ::fbthrift::TType::Set, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NSet
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::Set, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Set, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Row {
    fn default() -> Self {
        Self {
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Row {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Row")
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Row {}
unsafe impl ::std::marker::Sync for self::Row {}

impl ::fbthrift::GetTType for self::Row {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Row
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Row");
        p.write_field_begin("values", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Row
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
        ];
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DataSet {
    fn default() -> Self {
        Self {
            column_names: ::std::default::Default::default(),
            rows: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DataSet {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DataSet")
            .field("column_names", &self.column_names)
            .field("rows", &self.rows)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DataSet {}
unsafe impl ::std::marker::Sync for self::DataSet {}

impl ::fbthrift::GetTType for self::DataSet {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DataSet
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DataSet");
        p.write_field_begin("column_names", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.column_names, p);
        p.write_field_end();
        p.write_field_begin("rows", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.rows, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DataSet
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("column_names", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 2),
        ];
        let mut field_column_names = ::std::option::Option::None;
        let mut field_rows = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            column_names: field_column_names.unwrap_or_default(),
            rows: field_rows.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Coordinate {
    fn default() -> Self {
        Self {
            x: ::std::default::Default::default(),
            y: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Coordinate {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Coordinate")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Coordinate {}
unsafe impl ::std::marker::Sync for self::Coordinate {}

impl ::fbthrift::GetTType for self::Coordinate {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Coordinate
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Coordinate");
        p.write_field_begin("x", ::fbthrift::TType::Double, 1);
        ::fbthrift::Serialize::write(&self.x, p);
        p.write_field_end();
        p.write_field_begin("y", ::fbthrift::TType::Double, 2);
        ::fbthrift::Serialize::write(&self.y, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Coordinate
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("x", ::fbthrift::TType::Double, 1),
            ::fbthrift::Field::new("y", ::fbthrift::TType::Double, 2),
        ];
        let mut field_x = ::std::option::Option::None;
        let mut field_y = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Double, 1) => field_x = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 2) => field_y = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            x: field_x.unwrap_or_default(),
            y: field_y.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Point {
    fn default() -> Self {
        Self {
            coord: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Point {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Point")
            .field("coord", &self.coord)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Point {}
unsafe impl ::std::marker::Sync for self::Point {}

impl ::fbthrift::GetTType for self::Point {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Point
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Point");
        p.write_field_begin("coord", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.coord, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Point
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coord", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_coord = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_coord = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coord: field_coord.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LineString {
    fn default() -> Self {
        Self {
            coordList: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LineString {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LineString")
            .field("coordList", &self.coordList)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LineString {}
unsafe impl ::std::marker::Sync for self::LineString {}

impl ::fbthrift::GetTType for self::LineString {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LineString
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LineString");
        p.write_field_begin("coordList", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.coordList, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LineString
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coordList", ::fbthrift::TType::List, 1),
        ];
        let mut field_coordList = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_coordList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coordList: field_coordList.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Polygon {
    fn default() -> Self {
        Self {
            coordListList: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Polygon {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Polygon")
            .field("coordListList", &self.coordListList)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Polygon {}
unsafe impl ::std::marker::Sync for self::Polygon {}

impl ::fbthrift::GetTType for self::Polygon {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Polygon
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Polygon");
        p.write_field_begin("coordListList", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.coordListList, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Polygon
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("coordListList", ::fbthrift::TType::List, 1),
        ];
        let mut field_coordListList = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_coordListList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            coordListList: field_coordListList.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}



impl ::std::default::Default for Geography {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for Geography {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for Geography
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Geography");
        match self {
            Self::ptVal(inner) => {
                p.write_field_begin("ptVal", ::fbthrift::TType::Struct, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::lsVal(inner) => {
                p.write_field_begin("lsVal", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::pgVal(inner) => {
                p.write_field_begin("pgVal", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for Geography
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("lsVal", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("pgVal", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("ptVal", ::fbthrift::TType::Struct, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::Struct, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::ptVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::lsVal(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::pgVal(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "Geography",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Tag {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Tag {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Tag")
            .field("name", &self.name)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Tag {}
unsafe impl ::std::marker::Sync for self::Tag {}

impl ::fbthrift::GetTType for self::Tag {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Tag");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Tag
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Vertex {
    fn default() -> Self {
        Self {
            vid: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Vertex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Vertex")
            .field("vid", &self.vid)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Vertex {}
unsafe impl ::std::marker::Sync for self::Vertex {}

impl ::fbthrift::GetTType for self::Vertex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Vertex");
        p.write_field_begin("vid", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.vid, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Vertex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("vid", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_vid = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_vid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            vid: field_vid.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Edge {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            dst: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Edge {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Edge")
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("r#type", &self.r#type)
            .field("name", &self.name)
            .field("ranking", &self.ranking)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Edge {}
unsafe impl ::std::marker::Sync for self::Edge {}

impl ::fbthrift::GetTType for self::Edge {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Edge");
        p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("dst", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Edge
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_dst = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            dst: field_dst.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Step {
    fn default() -> Self {
        Self {
            dst: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            ranking: ::std::default::Default::default(),
            props: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Step {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Step")
            .field("dst", &self.dst)
            .field("r#type", &self.r#type)
            .field("name", &self.name)
            .field("ranking", &self.ranking)
            .field("props", &self.props)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Step {}
unsafe impl ::std::marker::Sync for self::Step {}

impl ::fbthrift::GetTType for self::Step {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Step
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Step");
        p.write_field_begin("dst", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.dst, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("ranking", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.ranking, p);
        p.write_field_end();
        p.write_field_begin("props", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.props, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Step
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_dst = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_ranking = ::std::option::Option::None;
        let mut field_props = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            dst: field_dst.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            ranking: field_ranking.unwrap_or_default(),
            props: field_props.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Path {
    fn default() -> Self {
        Self {
            src: ::std::default::Default::default(),
            steps: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Path {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Path")
            .field("src", &self.src)
            .field("steps", &self.steps)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Path {}
unsafe impl ::std::marker::Sync for self::Path {}

impl ::fbthrift::GetTType for self::Path {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Path
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Path");
        p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.src, p);
        p.write_field_end();
        p.write_field_begin("steps", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.steps, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Path
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("steps", ::fbthrift::TType::List, 2),
        ];
        let mut field_src = ::std::option::Option::None;
        let mut field_steps = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_steps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            src: field_src.unwrap_or_default(),
            steps: field_steps.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostAddr {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            port: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostAddr {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostAddr")
            .field("host", &self.host)
            .field("port", &self.port)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostAddr {}
unsafe impl ::std::marker::Sync for self::HostAddr {}

impl ::fbthrift::GetTType for self::HostAddr {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostAddr
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostAddr");
        p.write_field_begin("host", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("port", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.port, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostAddr
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("port", ::fbthrift::TType::I32, 2),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_port = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            port: field_port.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KeyValue {
    fn default() -> Self {
        Self {
            key: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KeyValue {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KeyValue")
            .field("key", &self.key)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KeyValue {}
unsafe impl ::std::marker::Sync for self::KeyValue {}

impl ::fbthrift::GetTType for self::KeyValue {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KeyValue
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KeyValue");
        p.write_field_begin("key", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KeyValue
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
        ];
        let mut field_key = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            key: field_key.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LogInfo {
    fn default() -> Self {
        Self {
            log_id: ::std::default::Default::default(),
            term_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LogInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LogInfo")
            .field("log_id", &self.log_id)
            .field("term_id", &self.term_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LogInfo {}
unsafe impl ::std::marker::Sync for self::LogInfo {}

impl ::fbthrift::GetTType for self::LogInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LogInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LogInfo");
        p.write_field_begin("log_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.log_id, p);
        p.write_field_end();
        p.write_field_begin("term_id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.term_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LogInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("log_id", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("term_id", ::fbthrift::TType::I64, 2),
        ];
        let mut field_log_id = ::std::option::Option::None;
        let mut field_term_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_term_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            log_id: field_log_id.unwrap_or_default(),
            term_id: field_term_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DirInfo {
    fn default() -> Self {
        Self {
            root: ::std::default::Default::default(),
            data: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DirInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DirInfo")
            .field("root", &self.root)
            .field("data", &self.data)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DirInfo {}
unsafe impl ::std::marker::Sync for self::DirInfo {}

impl ::fbthrift::GetTType for self::DirInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DirInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DirInfo");
        p.write_field_begin("root", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.root, p);
        p.write_field_end();
        p.write_field_begin("data", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.data, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DirInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("root", ::fbthrift::TType::String, 1),
        ];
        let mut field_root = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_root = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            root: field_root.unwrap_or_default(),
            data: field_data.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::NodeInfo {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            dir: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::NodeInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("NodeInfo")
            .field("host", &self.host)
            .field("dir", &self.dir)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::NodeInfo {}
unsafe impl ::std::marker::Sync for self::NodeInfo {}

impl ::fbthrift::GetTType for self::NodeInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::NodeInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("NodeInfo");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("dir", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dir, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::NodeInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_dir = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            dir: field_dir.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartitionBackupInfo {
    fn default() -> Self {
        Self {
            info: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartitionBackupInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartitionBackupInfo")
            .field("info", &self.info)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartitionBackupInfo {}
unsafe impl ::std::marker::Sync for self::PartitionBackupInfo {}

impl ::fbthrift::GetTType for self::PartitionBackupInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartitionBackupInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartitionBackupInfo");
        p.write_field_begin("info", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.info, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartitionBackupInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("info", ::fbthrift::TType::Map, 1),
        ];
        let mut field_info = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            info: field_info.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CheckpointInfo {
    fn default() -> Self {
        Self {
            partition_info: ::std::default::Default::default(),
            path: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CheckpointInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CheckpointInfo")
            .field("partition_info", &self.partition_info)
            .field("path", &self.path)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CheckpointInfo {}
unsafe impl ::std::marker::Sync for self::CheckpointInfo {}

impl ::fbthrift::GetTType for self::CheckpointInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CheckpointInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CheckpointInfo");
        p.write_field_begin("partition_info", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.partition_info, p);
        p.write_field_end();
        p.write_field_begin("path", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.path, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CheckpointInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("partition_info", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("path", ::fbthrift::TType::String, 2),
        ];
        let mut field_partition_info = ::std::option::Option::None;
        let mut field_path = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_partition_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            partition_info: field_partition_info.unwrap_or_default(),
            path: field_path.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
