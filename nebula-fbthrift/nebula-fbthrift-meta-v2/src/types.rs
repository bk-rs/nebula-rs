// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `meta`.

#![allow(clippy::redundant_closure)]


pub type SchemaVer = ::std::primitive::i64;

pub type ClusterID = ::std::primitive::i64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ID {
    space_id(common::types::GraphSpaceID),
    tag_id(common::types::TagID),
    edge_type(common::types::EdgeType),
    index_id(common::types::IndexID),
    cluster_id(crate::types::ClusterID),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ColumnTypeDef {
    pub r#type: crate::types::PropertyType,
    pub type_length: ::std::option::Option<::std::primitive::i16>,
    pub geo_shape: ::std::option::Option<crate::types::GeoShape>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ColumnDef {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub r#type: crate::types::ColumnTypeDef,
    pub default_value: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub nullable: ::std::option::Option<::std::primitive::bool>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SchemaProp {
    pub ttl_duration: ::std::option::Option<::std::primitive::i64>,
    pub ttl_col: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Schema {
    pub columns: ::std::vec::Vec<crate::types::ColumnDef>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IdName {
    pub id: crate::types::ID,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceDesc {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub partition_num: ::std::primitive::i32,
    pub replica_factor: ::std::primitive::i32,
    pub charset_name: ::std::vec::Vec<::std::primitive::u8>,
    pub collate_name: ::std::vec::Vec<::std::primitive::u8>,
    pub vid_type: crate::types::ColumnTypeDef,
    pub group_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub isolation_level: ::std::option::Option<crate::types::IsolationLevel>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceItem {
    pub space_id: common::types::GraphSpaceID,
    pub properties: crate::types::SpaceDesc,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TagItem {
    pub tag_id: common::types::TagID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterSchemaItem {
    pub op: crate::types::AlterSchemaOp,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct EdgeItem {
    pub edge_type: common::types::EdgeType,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct IndexItem {
    pub index_id: common::types::IndexID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema_id: common::types::SchemaID,
    pub schema_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::ColumnDef>,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostItem {
    pub hostAddr: common::types::HostAddr,
    pub status: crate::types::HostStatus,
    pub leader_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
    pub all_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
    pub role: crate::types::HostRole,
    pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub version: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UserItem {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub is_lock: ::std::primitive::bool,
    pub max_queries_per_hour: ::std::primitive::i32,
    pub max_updates_per_hour: ::std::primitive::i32,
    pub max_connections_per_hour: ::std::primitive::i32,
    pub max_user_connections: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RoleItem {
    pub user_id: ::std::vec::Vec<::std::primitive::u8>,
    pub space_id: common::types::GraphSpaceID,
    pub role_type: crate::types::RoleType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ExecResp {
    pub code: common::types::ErrorCode,
    pub id: crate::types::ID,
    pub leader: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AdminJobReq {
    pub op: crate::types::AdminJobOp,
    pub cmd: crate::types::AdminCmd,
    pub paras: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct JobDesc {
    pub id: ::std::primitive::i32,
    pub cmd: crate::types::AdminCmd,
    pub paras: ::std::vec::Vec<::std::string::String>,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct TaskDesc {
    pub task_id: ::std::primitive::i32,
    pub host: common::types::HostAddr,
    pub status: crate::types::JobStatus,
    pub start_time: ::std::primitive::i64,
    pub stop_time: ::std::primitive::i64,
    pub job_id: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResult {
    pub job_id: ::std::option::Option<::std::primitive::i32>,
    pub job_desc: ::std::option::Option<::std::vec::Vec<crate::types::JobDesc>>,
    pub task_desc: ::std::option::Option<::std::vec::Vec<crate::types::TaskDesc>>,
    pub recovered_job_num: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AdminJobResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub result: crate::types::AdminJobResult,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Correlativity {
    pub part_id: common::types::PartitionID,
    pub proportion: ::std::primitive::f64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct StatsItem {
    pub tag_vertices: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
    pub edges: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
    pub space_vertices: ::std::primitive::i64,
    pub space_edges: ::std::primitive::i64,
    pub positive_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
    pub negative_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
    pub status: crate::types::JobStatus,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSpaceReq {
    pub properties: crate::types::SpaceDesc,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateSpaceAsReq {
    pub old_space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub new_space_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSpacesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSpacesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub spaces: ::std::vec::Vec<crate::types::IdName>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSpaceReq {
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSpaceResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::SpaceItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema: crate::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub tag_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagsReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub tags: ::std::vec::Vec<crate::types::TagItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagReq {
    pub space_id: common::types::GraphSpaceID,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub schema: crate::types::Schema,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AlterEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub edge_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
    pub schema_prop: crate::types::SchemaProp,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub version: crate::types::SchemaVer,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub schema: crate::types::Schema,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeReq {
    pub space_id: common::types::GraphSpaceID,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub edges: ::std::vec::Vec<crate::types::EdgeItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListHostsReq {
    pub r#type: crate::types::ListHostType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListHostsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub hosts: ::std::vec::Vec<crate::types::HostItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct PartItem {
    pub part_id: common::types::PartitionID,
    pub leader: ::std::option::Option<common::types::HostAddr>,
    pub peers: ::std::vec::Vec<common::types::HostAddr>,
    pub losts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListPartsReq {
    pub space_id: common::types::GraphSpaceID,
    pub part_ids: ::std::vec::Vec<common::types::PartitionID>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListPartsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::vec::Vec<crate::types::PartItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetPartsAllocReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetPartsAllocResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::HostAddr>>,
    pub terms: ::std::option::Option<::std::collections::BTreeMap<common::types::PartitionID, ::std::primitive::i64>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MultiPutReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub pairs: ::std::vec::Vec<common::types::KeyValue>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub key: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub value: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MultiGetReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub keys: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MultiGetResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub values: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub key: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveRangeReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub start: ::std::vec::Vec<::std::primitive::u8>,
    pub end: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ScanReq {
    pub segment: ::std::vec::Vec<::std::primitive::u8>,
    pub start: ::std::vec::Vec<::std::primitive::u8>,
    pub end: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ScanResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub values: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub cluster_id: crate::types::ClusterID,
    pub last_update_time_in_ms: ::std::primitive::i64,
    pub meta_version: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LeaderInfo {
    pub part_id: common::types::PartitionID,
    pub term: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HBReq {
    pub role: crate::types::HostRole,
    pub host: common::types::HostAddr,
    pub cluster_id: crate::types::ClusterID,
    pub leader_partIds: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<crate::types::LeaderInfo>>>,
    pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    pub version: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexFieldDef {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub type_length: ::std::option::Option<::std::primitive::i16>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
    pub if_not_exists: ::std::primitive::bool,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetTagIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetTagIndexResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListTagIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListTagIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
    pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
    pub if_not_exists: ::std::primitive::bool,
    pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetEdgeIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetEdgeIndexResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub item: crate::types::IndexItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListEdgeIndexesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListEdgeIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::IndexItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RebuildIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    pub if_not_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub if_exists: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AlterUserReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GrantRoleReq {
    pub role_item: crate::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RevokeRoleReq {
    pub role_item: crate::types::RoleItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListUsersReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListUsersResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub users: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListRolesReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListRolesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub roles: ::std::vec::Vec<crate::types::RoleItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetUserRolesReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ChangePasswordReq {
    pub account: ::std::vec::Vec<::std::primitive::u8>,
    pub new_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    pub old_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BalanceReq {
    pub space_id: ::std::option::Option<common::types::GraphSpaceID>,
    pub id: ::std::option::Option<::std::primitive::i64>,
    pub host_del: ::std::option::Option<::std::vec::Vec<common::types::HostAddr>>,
    pub stop: ::std::option::Option<::std::primitive::bool>,
    pub reset: ::std::option::Option<::std::primitive::bool>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BalanceTask {
    pub id: ::std::vec::Vec<::std::primitive::u8>,
    pub result: crate::types::TaskResult,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BalanceResp {
    pub code: common::types::ErrorCode,
    pub id: ::std::primitive::i64,
    pub leader: common::types::HostAddr,
    pub tasks: ::std::vec::Vec<crate::types::BalanceTask>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LeaderBalanceReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ConfigItem {
    pub module: crate::types::ConfigModule,
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub mode: crate::types::ConfigMode,
    pub value: common::types::Value,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RegConfigReq {
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigReq {
    pub item: crate::types::ConfigItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetConfigResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SetConfigReq {
    pub item: crate::types::ConfigItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListConfigsReq {
    pub space: ::std::vec::Vec<::std::primitive::u8>,
    pub module: crate::types::ConfigModule,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListConfigsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateSnapshotReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropSnapshotReq {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSnapshotsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Snapshot {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub status: crate::types::SnapshotStatus,
    pub hosts: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSnapshotsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub snapshots: ::std::vec::Vec<crate::types::Snapshot>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListIndexStatusReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IndexStatus {
    pub name: ::std::vec::Vec<::std::primitive::u8>,
    pub status: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListIndexStatusResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub statuses: ::std::vec::Vec<crate::types::IndexStatus>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub nodes: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddHostIntoZoneReq {
    pub node: common::types::HostAddr,
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct DropHostFromZoneReq {
    pub node: common::types::HostAddr,
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetZoneReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetZoneResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListZonesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Zone {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub nodes: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListZonesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub zones: ::std::vec::Vec<crate::types::Zone>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AddGroupReq {
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropGroupReq {
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AddZoneIntoGroupReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropZoneFromGroupReq {
    pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetGroupReq {
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetGroupResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListGroupsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Group {
    pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListGroupsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub groups: ::std::vec::Vec<crate::types::Group>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct AddListenerReq {
    pub space_id: common::types::GraphSpaceID,
    pub r#type: crate::types::ListenerType,
    pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveListenerReq {
    pub space_id: common::types::GraphSpaceID,
    pub r#type: crate::types::ListenerType,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListListenerReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListenerInfo {
    pub r#type: crate::types::ListenerType,
    pub host: common::types::HostAddr,
    pub part_id: common::types::PartitionID,
    pub status: crate::types::HostStatus,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListListenerResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub listeners: ::std::vec::Vec<crate::types::ListenerInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetStatsReq {
    pub space_id: common::types::GraphSpaceID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetStatsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub stats: crate::types::StatsItem,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BackupInfo {
    pub host: common::types::HostAddr,
    pub info: ::std::vec::Vec<common::types::CheckpointInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SpaceBackupInfo {
    pub space: crate::types::SpaceDesc,
    pub info: ::std::vec::Vec<crate::types::BackupInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BackupMeta {
    pub backup_info: ::std::collections::BTreeMap<common::types::GraphSpaceID, crate::types::SpaceBackupInfo>,
    pub meta_files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub backup_name: ::std::vec::Vec<::std::primitive::u8>,
    pub full: ::std::primitive::bool,
    pub include_system_space: ::std::primitive::bool,
    pub create_time: ::std::primitive::i64,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreateBackupReq {
    pub spaces: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateBackupResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub meta: crate::types::BackupMeta,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct HostPair {
    pub from_host: common::types::HostAddr,
    pub to_host: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RestoreMetaReq {
    pub files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    pub hosts: ::std::vec::Vec<crate::types::HostPair>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct FTClient {
    pub host: common::types::HostAddr,
    pub user: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub pwd: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct SignInFTServiceReq {
    pub r#type: crate::types::FTServiceType,
    pub clients: ::std::vec::Vec<crate::types::FTClient>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SignOutFTServiceReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListFTClientsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListFTClientsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub clients: ::std::vec::Vec<crate::types::FTClient>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct FTIndex {
    pub space_id: common::types::GraphSpaceID,
    pub depend_schema: common::types::SchemaID,
    pub fields: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateFTIndexReq {
    pub fulltext_index_name: ::std::vec::Vec<::std::primitive::u8>,
    pub index: crate::types::FTIndex,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DropFTIndexReq {
    pub space_id: common::types::GraphSpaceID,
    pub fulltext_index_name: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListFTIndexesReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListFTIndexesResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub indexes: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::FTIndex>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct QueryDesc {
    pub start_time: common::types::Timestamp,
    pub status: crate::types::QueryStatus,
    pub duration: ::std::primitive::i64,
    pub query: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Session {
    pub session_id: common::types::SessionID,
    pub create_time: common::types::Timestamp,
    pub update_time: common::types::Timestamp,
    pub user_name: ::std::vec::Vec<::std::primitive::u8>,
    pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    pub timezone: ::std::primitive::i32,
    pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
    pub configs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, common::types::Value>,
    pub queries: ::std::collections::BTreeMap<common::types::ExecutionPlanID, crate::types::QueryDesc>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSessionReq {
    pub user: ::std::vec::Vec<::std::primitive::u8>,
    pub graph_addr: common::types::HostAddr,
    pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct CreateSessionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub session: crate::types::Session,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateSessionsReq {
    pub sessions: ::std::vec::Vec<crate::types::Session>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct UpdateSessionsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub killed_queries: ::std::collections::BTreeMap<common::types::SessionID, ::std::collections::BTreeMap<common::types::ExecutionPlanID, crate::types::QueryDesc>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListSessionsReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListSessionsResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub sessions: ::std::vec::Vec<crate::types::Session>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetSessionReq {
    pub session_id: common::types::SessionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetSessionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub session: crate::types::Session,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RemoveSessionReq {
    pub session_id: common::types::SessionID,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct KillQueryReq {
    pub kill_queries: ::std::collections::BTreeMap<common::types::SessionID, ::std::collections::BTreeSet<common::types::ExecutionPlanID>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ReportTaskReq {
    pub code: common::types::ErrorCode,
    pub job_id: ::std::primitive::i32,
    pub task_id: ::std::primitive::i32,
    pub stats: ::std::option::Option<crate::types::StatsItem>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct ListClusterInfoResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub meta_servers: ::std::vec::Vec<common::types::HostAddr>,
    pub storage_servers: ::std::vec::Vec<common::types::NodeInfo>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ListClusterInfoReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct GetMetaDirInfoResp {
    pub code: common::types::ErrorCode,
    pub dir: common::types::DirInfo,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GetMetaDirInfoReq {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct VerifyClientVersionResp {
    pub code: common::types::ErrorCode,
    pub leader: common::types::HostAddr,
    pub error_msg: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VerifyClientVersionReq {
    pub version: ::std::vec::Vec<::std::primitive::u8>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AlterSchemaOp(pub ::std::primitive::i32);

impl AlterSchemaOp {
    pub const ADD: Self = AlterSchemaOp(1i32);
    pub const CHANGE: Self = AlterSchemaOp(2i32);
    pub const DROP: Self = AlterSchemaOp(3i32);
    pub const UNKNOWN: Self = AlterSchemaOp(4i32);
}

impl ::fbthrift::ThriftEnum for AlterSchemaOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::CHANGE, "CHANGE"),
            (Self::DROP, "DROP"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "CHANGE",
            "DROP",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::CHANGE,
            Self::DROP,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for AlterSchemaOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AlterSchemaOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AlterSchemaOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AlterSchemaOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AlterSchemaOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AlterSchemaOp::{}", self)
    }
}

impl ::std::str::FromStr for AlterSchemaOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("CHANGE", 2),
            ("DROP", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSchemaOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AlterSchemaOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AlterSchemaOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct RoleType(pub ::std::primitive::i32);

impl RoleType {
    pub const GOD: Self = RoleType(1i32);
    pub const ADMIN: Self = RoleType(2i32);
    pub const DBA: Self = RoleType(3i32);
    pub const USER: Self = RoleType(4i32);
    pub const GUEST: Self = RoleType(5i32);
}

impl ::fbthrift::ThriftEnum for RoleType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::GOD, "GOD"),
            (Self::ADMIN, "ADMIN"),
            (Self::DBA, "DBA"),
            (Self::USER, "USER"),
            (Self::GUEST, "GUEST"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "GOD",
            "ADMIN",
            "DBA",
            "USER",
            "GUEST",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::GOD,
            Self::ADMIN,
            Self::DBA,
            Self::USER,
            Self::GUEST,
        ]
    }
}

impl ::std::default::Default for RoleType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a RoleType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a RoleType) -> Self {
        x.0
    }
}

impl ::std::convert::From<RoleType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: RoleType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for RoleType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for RoleType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("GOD", 1),
            ("ADMIN", 2),
            ("DBA", 3),
            ("USER", 4),
            ("GUEST", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for RoleType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "RoleType::{}", self)
    }
}

impl ::std::str::FromStr for RoleType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADMIN", 2),
            ("DBA", 3),
            ("GOD", 1),
            ("GUEST", 5),
            ("USER", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "RoleType").map(Self)
    }
}

impl ::fbthrift::GetTType for RoleType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for RoleType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for RoleType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct GeoShape(pub ::std::primitive::i32);

impl GeoShape {
    pub const ANY: Self = GeoShape(0i32);
    pub const POINT: Self = GeoShape(1i32);
    pub const LINESTRING: Self = GeoShape(2i32);
    pub const POLYGON: Self = GeoShape(3i32);
}

impl ::fbthrift::ThriftEnum for GeoShape {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ANY, "ANY"),
            (Self::POINT, "POINT"),
            (Self::LINESTRING, "LINESTRING"),
            (Self::POLYGON, "POLYGON"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ANY",
            "POINT",
            "LINESTRING",
            "POLYGON",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ANY,
            Self::POINT,
            Self::LINESTRING,
            Self::POLYGON,
        ]
    }
}

impl ::std::default::Default for GeoShape {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a GeoShape> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a GeoShape) -> Self {
        x.0
    }
}

impl ::std::convert::From<GeoShape> for ::std::primitive::i32 {
    #[inline]
    fn from(x: GeoShape) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for GeoShape {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for GeoShape {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ANY", 0),
            ("POINT", 1),
            ("LINESTRING", 2),
            ("POLYGON", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for GeoShape {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "GeoShape::{}", self)
    }
}

impl ::std::str::FromStr for GeoShape {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ANY", 0),
            ("LINESTRING", 2),
            ("POINT", 1),
            ("POLYGON", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "GeoShape").map(Self)
    }
}

impl ::fbthrift::GetTType for GeoShape {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for GeoShape
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for GeoShape
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PropertyType(pub ::std::primitive::i32);

impl PropertyType {
    pub const UNKNOWN: Self = PropertyType(0i32);
    pub const BOOL: Self = PropertyType(1i32);
    pub const INT64: Self = PropertyType(2i32);
    pub const VID: Self = PropertyType(3i32);
    pub const FLOAT: Self = PropertyType(4i32);
    pub const DOUBLE: Self = PropertyType(5i32);
    pub const STRING: Self = PropertyType(6i32);
    pub const FIXED_STRING: Self = PropertyType(7i32);
    pub const INT8: Self = PropertyType(8i32);
    pub const INT16: Self = PropertyType(9i32);
    pub const INT32: Self = PropertyType(10i32);
    pub const TIMESTAMP: Self = PropertyType(21i32);
    pub const DATE: Self = PropertyType(24i32);
    pub const DATETIME: Self = PropertyType(25i32);
    pub const TIME: Self = PropertyType(26i32);
    pub const GEOGRAPHY: Self = PropertyType(31i32);
}

impl ::fbthrift::ThriftEnum for PropertyType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::BOOL, "BOOL"),
            (Self::INT64, "INT64"),
            (Self::VID, "VID"),
            (Self::FLOAT, "FLOAT"),
            (Self::DOUBLE, "DOUBLE"),
            (Self::STRING, "STRING"),
            (Self::FIXED_STRING, "FIXED_STRING"),
            (Self::INT8, "INT8"),
            (Self::INT16, "INT16"),
            (Self::INT32, "INT32"),
            (Self::TIMESTAMP, "TIMESTAMP"),
            (Self::DATE, "DATE"),
            (Self::DATETIME, "DATETIME"),
            (Self::TIME, "TIME"),
            (Self::GEOGRAPHY, "GEOGRAPHY"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "BOOL",
            "INT64",
            "VID",
            "FLOAT",
            "DOUBLE",
            "STRING",
            "FIXED_STRING",
            "INT8",
            "INT16",
            "INT32",
            "TIMESTAMP",
            "DATE",
            "DATETIME",
            "TIME",
            "GEOGRAPHY",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::BOOL,
            Self::INT64,
            Self::VID,
            Self::FLOAT,
            Self::DOUBLE,
            Self::STRING,
            Self::FIXED_STRING,
            Self::INT8,
            Self::INT16,
            Self::INT32,
            Self::TIMESTAMP,
            Self::DATE,
            Self::DATETIME,
            Self::TIME,
            Self::GEOGRAPHY,
        ]
    }
}

impl ::std::default::Default for PropertyType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a PropertyType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a PropertyType) -> Self {
        x.0
    }
}

impl ::std::convert::From<PropertyType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: PropertyType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for PropertyType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for PropertyType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("BOOL", 1),
            ("INT64", 2),
            ("VID", 3),
            ("FLOAT", 4),
            ("DOUBLE", 5),
            ("STRING", 6),
            ("FIXED_STRING", 7),
            ("INT8", 8),
            ("INT16", 9),
            ("INT32", 10),
            ("TIMESTAMP", 21),
            ("DATE", 24),
            ("DATETIME", 25),
            ("TIME", 26),
            ("GEOGRAPHY", 31),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for PropertyType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "PropertyType::{}", self)
    }
}

impl ::std::str::FromStr for PropertyType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("BOOL", 1),
            ("DATE", 24),
            ("DATETIME", 25),
            ("DOUBLE", 5),
            ("FIXED_STRING", 7),
            ("FLOAT", 4),
            ("GEOGRAPHY", 31),
            ("INT16", 9),
            ("INT32", 10),
            ("INT64", 2),
            ("INT8", 8),
            ("STRING", 6),
            ("TIME", 26),
            ("TIMESTAMP", 21),
            ("UNKNOWN", 0),
            ("VID", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "PropertyType").map(Self)
    }
}

impl ::fbthrift::GetTType for PropertyType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for PropertyType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for PropertyType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct IsolationLevel(pub ::std::primitive::i32);

impl IsolationLevel {
    pub const DEFAULT: Self = IsolationLevel(0i32);
    pub const TOSS: Self = IsolationLevel(1i32);
}

impl ::fbthrift::ThriftEnum for IsolationLevel {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::DEFAULT, "DEFAULT"),
            (Self::TOSS, "TOSS"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "DEFAULT",
            "TOSS",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::DEFAULT,
            Self::TOSS,
        ]
    }
}

impl ::std::default::Default for IsolationLevel {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a IsolationLevel> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a IsolationLevel) -> Self {
        x.0
    }
}

impl ::std::convert::From<IsolationLevel> for ::std::primitive::i32 {
    #[inline]
    fn from(x: IsolationLevel) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for IsolationLevel {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for IsolationLevel {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DEFAULT", 0),
            ("TOSS", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for IsolationLevel {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "IsolationLevel::{}", self)
    }
}

impl ::std::str::FromStr for IsolationLevel {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DEFAULT", 0),
            ("TOSS", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "IsolationLevel").map(Self)
    }
}

impl ::fbthrift::GetTType for IsolationLevel {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for IsolationLevel
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for IsolationLevel
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct HostStatus(pub ::std::primitive::i32);

impl HostStatus {
    pub const ONLINE: Self = HostStatus(0i32);
    pub const OFFLINE: Self = HostStatus(1i32);
    pub const UNKNOWN: Self = HostStatus(2i32);
}

impl ::fbthrift::ThriftEnum for HostStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ONLINE, "ONLINE"),
            (Self::OFFLINE, "OFFLINE"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ONLINE",
            "OFFLINE",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ONLINE,
            Self::OFFLINE,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for HostStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<HostStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: HostStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for HostStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ONLINE", 0),
            ("OFFLINE", 1),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for HostStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "HostStatus::{}", self)
    }
}

impl ::std::str::FromStr for HostStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("OFFLINE", 1),
            ("ONLINE", 0),
            ("UNKNOWN", 2),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for HostStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for HostStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SnapshotStatus(pub ::std::primitive::i32);

impl SnapshotStatus {
    pub const VALID: Self = SnapshotStatus(0i32);
    pub const INVALID: Self = SnapshotStatus(1i32);
}

impl ::fbthrift::ThriftEnum for SnapshotStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::VALID, "VALID"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "VALID",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::VALID,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for SnapshotStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<SnapshotStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: SnapshotStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for SnapshotStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("VALID", 0),
            ("INVALID", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for SnapshotStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "SnapshotStatus::{}", self)
    }
}

impl ::std::str::FromStr for SnapshotStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("INVALID", 1),
            ("VALID", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "SnapshotStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for SnapshotStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for SnapshotStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AdminJobOp(pub ::std::primitive::i32);

impl AdminJobOp {
    pub const ADD: Self = AdminJobOp(1i32);
    pub const SHOW_All: Self = AdminJobOp(2i32);
    pub const SHOW: Self = AdminJobOp(3i32);
    pub const STOP: Self = AdminJobOp(4i32);
    pub const RECOVER: Self = AdminJobOp(5i32);
}

impl ::fbthrift::ThriftEnum for AdminJobOp {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ADD, "ADD"),
            (Self::SHOW_All, "SHOW_All"),
            (Self::SHOW, "SHOW"),
            (Self::STOP, "STOP"),
            (Self::RECOVER, "RECOVER"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ADD",
            "SHOW_All",
            "SHOW",
            "STOP",
            "RECOVER",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ADD,
            Self::SHOW_All,
            Self::SHOW,
            Self::STOP,
            Self::RECOVER,
        ]
    }
}

impl ::std::default::Default for AdminJobOp {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AdminJobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AdminJobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<AdminJobOp> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AdminJobOp) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AdminJobOp {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AdminJobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("SHOW_All", 2),
            ("SHOW", 3),
            ("STOP", 4),
            ("RECOVER", 5),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AdminJobOp {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AdminJobOp::{}", self)
    }
}

impl ::std::str::FromStr for AdminJobOp {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ADD", 1),
            ("RECOVER", 5),
            ("SHOW", 3),
            ("SHOW_All", 2),
            ("STOP", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminJobOp").map(Self)
    }
}

impl ::fbthrift::GetTType for AdminJobOp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AdminJobOp
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AdminJobOp
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct AdminCmd(pub ::std::primitive::i32);

impl AdminCmd {
    pub const COMPACT: Self = AdminCmd(0i32);
    pub const FLUSH: Self = AdminCmd(1i32);
    pub const REBUILD_TAG_INDEX: Self = AdminCmd(2i32);
    pub const REBUILD_EDGE_INDEX: Self = AdminCmd(3i32);
    pub const REBUILD_FULLTEXT_INDEX: Self = AdminCmd(4i32);
    pub const STATS: Self = AdminCmd(5i32);
    pub const DATA_BALANCE: Self = AdminCmd(6i32);
    pub const DOWNLOAD: Self = AdminCmd(7i32);
    pub const INGEST: Self = AdminCmd(8i32);
    pub const UNKNOWN: Self = AdminCmd(99i32);
}

impl ::fbthrift::ThriftEnum for AdminCmd {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::COMPACT, "COMPACT"),
            (Self::FLUSH, "FLUSH"),
            (Self::REBUILD_TAG_INDEX, "REBUILD_TAG_INDEX"),
            (Self::REBUILD_EDGE_INDEX, "REBUILD_EDGE_INDEX"),
            (Self::REBUILD_FULLTEXT_INDEX, "REBUILD_FULLTEXT_INDEX"),
            (Self::STATS, "STATS"),
            (Self::DATA_BALANCE, "DATA_BALANCE"),
            (Self::DOWNLOAD, "DOWNLOAD"),
            (Self::INGEST, "INGEST"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "COMPACT",
            "FLUSH",
            "REBUILD_TAG_INDEX",
            "REBUILD_EDGE_INDEX",
            "REBUILD_FULLTEXT_INDEX",
            "STATS",
            "DATA_BALANCE",
            "DOWNLOAD",
            "INGEST",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::COMPACT,
            Self::FLUSH,
            Self::REBUILD_TAG_INDEX,
            Self::REBUILD_EDGE_INDEX,
            Self::REBUILD_FULLTEXT_INDEX,
            Self::STATS,
            Self::DATA_BALANCE,
            Self::DOWNLOAD,
            Self::INGEST,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for AdminCmd {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a AdminCmd> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a AdminCmd) -> Self {
        x.0
    }
}

impl ::std::convert::From<AdminCmd> for ::std::primitive::i32 {
    #[inline]
    fn from(x: AdminCmd) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for AdminCmd {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for AdminCmd {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("COMPACT", 0),
            ("FLUSH", 1),
            ("REBUILD_TAG_INDEX", 2),
            ("REBUILD_EDGE_INDEX", 3),
            ("REBUILD_FULLTEXT_INDEX", 4),
            ("STATS", 5),
            ("DATA_BALANCE", 6),
            ("DOWNLOAD", 7),
            ("INGEST", 8),
            ("UNKNOWN", 99),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for AdminCmd {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "AdminCmd::{}", self)
    }
}

impl ::std::str::FromStr for AdminCmd {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("COMPACT", 0),
            ("DATA_BALANCE", 6),
            ("DOWNLOAD", 7),
            ("FLUSH", 1),
            ("INGEST", 8),
            ("REBUILD_EDGE_INDEX", 3),
            ("REBUILD_FULLTEXT_INDEX", 4),
            ("REBUILD_TAG_INDEX", 2),
            ("STATS", 5),
            ("UNKNOWN", 99),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminCmd").map(Self)
    }
}

impl ::fbthrift::GetTType for AdminCmd {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for AdminCmd
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for AdminCmd
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct JobStatus(pub ::std::primitive::i32);

impl JobStatus {
    pub const QUEUE: Self = JobStatus(1i32);
    pub const RUNNING: Self = JobStatus(2i32);
    pub const FINISHED: Self = JobStatus(3i32);
    pub const FAILED: Self = JobStatus(4i32);
    pub const STOPPED: Self = JobStatus(5i32);
    pub const INVALID: Self = JobStatus(255i32);
}

impl ::fbthrift::ThriftEnum for JobStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::QUEUE, "QUEUE"),
            (Self::RUNNING, "RUNNING"),
            (Self::FINISHED, "FINISHED"),
            (Self::FAILED, "FAILED"),
            (Self::STOPPED, "STOPPED"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "QUEUE",
            "RUNNING",
            "FINISHED",
            "FAILED",
            "STOPPED",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::QUEUE,
            Self::RUNNING,
            Self::FINISHED,
            Self::FAILED,
            Self::STOPPED,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for JobStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<JobStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: JobStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for JobStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("FINISHED", 3),
            ("FAILED", 4),
            ("STOPPED", 5),
            ("INVALID", 255),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for JobStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "JobStatus::{}", self)
    }
}

impl ::std::str::FromStr for JobStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 4),
            ("FINISHED", 3),
            ("INVALID", 255),
            ("QUEUE", 1),
            ("RUNNING", 2),
            ("STOPPED", 5),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for JobStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for JobStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ListHostType(pub ::std::primitive::i32);

impl ListHostType {
    pub const ALLOC: Self = ListHostType(0i32);
    pub const GRAPH: Self = ListHostType(1i32);
    pub const META: Self = ListHostType(2i32);
    pub const STORAGE: Self = ListHostType(3i32);
}

impl ::fbthrift::ThriftEnum for ListHostType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ALLOC, "ALLOC"),
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ALLOC",
            "GRAPH",
            "META",
            "STORAGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ALLOC,
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
        ]
    }
}

impl ::std::default::Default for ListHostType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ListHostType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ListHostType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ListHostType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ListHostType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ListHostType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ListHostType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALLOC", 0),
            ("GRAPH", 1),
            ("META", 2),
            ("STORAGE", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ListHostType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ListHostType::{}", self)
    }
}

impl ::std::str::FromStr for ListHostType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALLOC", 0),
            ("GRAPH", 1),
            ("META", 2),
            ("STORAGE", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListHostType").map(Self)
    }
}

impl ::fbthrift::GetTType for ListHostType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ListHostType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ListHostType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct HostRole(pub ::std::primitive::i32);

impl HostRole {
    pub const GRAPH: Self = HostRole(0i32);
    pub const META: Self = HostRole(1i32);
    pub const STORAGE: Self = HostRole(2i32);
    pub const LISTENER: Self = HostRole(3i32);
    pub const UNKNOWN: Self = HostRole(4i32);
}

impl ::fbthrift::ThriftEnum for HostRole {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
            (Self::LISTENER, "LISTENER"),
            (Self::UNKNOWN, "UNKNOWN"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "GRAPH",
            "META",
            "STORAGE",
            "LISTENER",
            "UNKNOWN",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
            Self::LISTENER,
            Self::UNKNOWN,
        ]
    }
}

impl ::std::default::Default for HostRole {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a HostRole> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a HostRole) -> Self {
        x.0
    }
}

impl ::std::convert::From<HostRole> for ::std::primitive::i32 {
    #[inline]
    fn from(x: HostRole) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for HostRole {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for HostRole {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("GRAPH", 0),
            ("META", 1),
            ("STORAGE", 2),
            ("LISTENER", 3),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for HostRole {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "HostRole::{}", self)
    }
}

impl ::std::str::FromStr for HostRole {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("GRAPH", 0),
            ("LISTENER", 3),
            ("META", 1),
            ("STORAGE", 2),
            ("UNKNOWN", 4),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostRole").map(Self)
    }
}

impl ::fbthrift::GetTType for HostRole {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for HostRole
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for HostRole
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct TaskResult(pub ::std::primitive::i32);

impl TaskResult {
    pub const SUCCEEDED: Self = TaskResult(0i32);
    pub const FAILED: Self = TaskResult(1i32);
    pub const IN_PROGRESS: Self = TaskResult(2i32);
    pub const INVALID: Self = TaskResult(3i32);
}

impl ::fbthrift::ThriftEnum for TaskResult {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::SUCCEEDED, "SUCCEEDED"),
            (Self::FAILED, "FAILED"),
            (Self::IN_PROGRESS, "IN_PROGRESS"),
            (Self::INVALID, "INVALID"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "SUCCEEDED",
            "FAILED",
            "IN_PROGRESS",
            "INVALID",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::SUCCEEDED,
            Self::FAILED,
            Self::IN_PROGRESS,
            Self::INVALID,
        ]
    }
}

impl ::std::default::Default for TaskResult {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<TaskResult> for ::std::primitive::i32 {
    #[inline]
    fn from(x: TaskResult) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for TaskResult {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("SUCCEEDED", 0),
            ("FAILED", 1),
            ("IN_PROGRESS", 2),
            ("INVALID", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for TaskResult {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "TaskResult::{}", self)
    }
}

impl ::std::str::FromStr for TaskResult {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("FAILED", 1),
            ("INVALID", 3),
            ("IN_PROGRESS", 2),
            ("SUCCEEDED", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TaskResult").map(Self)
    }
}

impl ::fbthrift::GetTType for TaskResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for TaskResult
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigModule(pub ::std::primitive::i32);

impl ConfigModule {
    pub const UNKNOWN: Self = ConfigModule(0i32);
    pub const ALL: Self = ConfigModule(1i32);
    pub const GRAPH: Self = ConfigModule(2i32);
    pub const META: Self = ConfigModule(3i32);
    pub const STORAGE: Self = ConfigModule(4i32);
}

impl ::fbthrift::ThriftEnum for ConfigModule {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::ALL, "ALL"),
            (Self::GRAPH, "GRAPH"),
            (Self::META, "META"),
            (Self::STORAGE, "STORAGE"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "ALL",
            "GRAPH",
            "META",
            "STORAGE",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::ALL,
            Self::GRAPH,
            Self::META,
            Self::STORAGE,
        ]
    }
}

impl ::std::default::Default for ConfigModule {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigModule> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigModule) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigModule {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigModule {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigModule::{}", self)
    }
}

impl ::std::str::FromStr for ConfigModule {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ALL", 1),
            ("GRAPH", 2),
            ("META", 3),
            ("STORAGE", 4),
            ("UNKNOWN", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigModule").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigModule {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigModule
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ConfigMode(pub ::std::primitive::i32);

impl ConfigMode {
    pub const IMMUTABLE: Self = ConfigMode(0i32);
    pub const REBOOT: Self = ConfigMode(1i32);
    pub const MUTABLE: Self = ConfigMode(2i32);
    pub const IGNORED: Self = ConfigMode(3i32);
}

impl ::fbthrift::ThriftEnum for ConfigMode {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::IMMUTABLE, "IMMUTABLE"),
            (Self::REBOOT, "REBOOT"),
            (Self::MUTABLE, "MUTABLE"),
            (Self::IGNORED, "IGNORED"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "IMMUTABLE",
            "REBOOT",
            "MUTABLE",
            "IGNORED",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::IMMUTABLE,
            Self::REBOOT,
            Self::MUTABLE,
            Self::IGNORED,
        ]
    }
}

impl ::std::default::Default for ConfigMode {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<ConfigMode> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ConfigMode) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ConfigMode {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IMMUTABLE", 0),
            ("REBOOT", 1),
            ("MUTABLE", 2),
            ("IGNORED", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ConfigMode {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ConfigMode::{}", self)
    }
}

impl ::std::str::FromStr for ConfigMode {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("IGNORED", 3),
            ("IMMUTABLE", 0),
            ("MUTABLE", 2),
            ("REBOOT", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigMode").map(Self)
    }
}

impl ::fbthrift::GetTType for ConfigMode {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ConfigMode
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ListenerType(pub ::std::primitive::i32);

impl ListenerType {
    pub const UNKNOWN: Self = ListenerType(0i32);
    pub const ELASTICSEARCH: Self = ListenerType(1i32);
}

impl ::fbthrift::ThriftEnum for ListenerType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::UNKNOWN, "UNKNOWN"),
            (Self::ELASTICSEARCH, "ELASTICSEARCH"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "UNKNOWN",
            "ELASTICSEARCH",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::UNKNOWN,
            Self::ELASTICSEARCH,
        ]
    }
}

impl ::std::default::Default for ListenerType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a ListenerType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a ListenerType) -> Self {
        x.0
    }
}

impl ::std::convert::From<ListenerType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: ListenerType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for ListenerType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for ListenerType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("UNKNOWN", 0),
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for ListenerType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "ListenerType::{}", self)
    }
}

impl ::std::str::FromStr for ListenerType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
            ("UNKNOWN", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListenerType").map(Self)
    }
}

impl ::fbthrift::GetTType for ListenerType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for ListenerType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for ListenerType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct FTServiceType(pub ::std::primitive::i32);

impl FTServiceType {
    pub const ELASTICSEARCH: Self = FTServiceType(1i32);
}

impl ::fbthrift::ThriftEnum for FTServiceType {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::ELASTICSEARCH, "ELASTICSEARCH"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "ELASTICSEARCH",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::ELASTICSEARCH,
        ]
    }
}

impl ::std::default::Default for FTServiceType {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a FTServiceType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a FTServiceType) -> Self {
        x.0
    }
}

impl ::std::convert::From<FTServiceType> for ::std::primitive::i32 {
    #[inline]
    fn from(x: FTServiceType) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for FTServiceType {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for FTServiceType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for FTServiceType {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "FTServiceType::{}", self)
    }
}

impl ::std::str::FromStr for FTServiceType {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("ELASTICSEARCH", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "FTServiceType").map(Self)
    }
}

impl ::fbthrift::GetTType for FTServiceType {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for FTServiceType
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for FTServiceType
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct QueryStatus(pub ::std::primitive::i32);

impl QueryStatus {
    pub const RUNNING: Self = QueryStatus(1i32);
    pub const KILLING: Self = QueryStatus(2i32);
}

impl ::fbthrift::ThriftEnum for QueryStatus {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::RUNNING, "RUNNING"),
            (Self::KILLING, "KILLING"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "RUNNING",
            "KILLING",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::RUNNING,
            Self::KILLING,
        ]
    }
}

impl ::std::default::Default for QueryStatus {
    fn default() -> Self {
        Self(::fbthrift::__UNKNOWN_ID)
    }
}

impl<'a> ::std::convert::From<&'a QueryStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a QueryStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<QueryStatus> for ::std::primitive::i32 {
    #[inline]
    fn from(x: QueryStatus) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for QueryStatus {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for QueryStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("RUNNING", 1),
            ("KILLING", 2),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for QueryStatus {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "QueryStatus::{}", self)
    }
}

impl ::std::str::FromStr for QueryStatus {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("KILLING", 2),
            ("RUNNING", 1),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "QueryStatus").map(Self)
    }
}

impl ::fbthrift::GetTType for QueryStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for QueryStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for QueryStatus
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(p.read_i32()?))
    }
}




impl ::std::default::Default for ID {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for ID {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for ID
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ID");
        match self {
            Self::space_id(inner) => {
                p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::tag_id(inner) => {
                p.write_field_begin("tag_id", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::edge_type(inner) => {
                p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::index_id(inner) => {
                p.write_field_begin("index_id", ::fbthrift::TType::I32, 4);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::cluster_id(inner) => {
                p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 5);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for ID
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 2),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::I32, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::space_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::tag_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::edge_type(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 4, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::index_id(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I64, 5, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::cluster_id(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "ID",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ColumnTypeDef {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            type_length: ::std::option::Option::Some(0),
            geo_shape: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ColumnTypeDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ColumnTypeDef")
            .field("r#type", &self.r#type)
            .field("type_length", &self.type_length)
            .field("geo_shape", &self.geo_shape)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ColumnTypeDef {}
unsafe impl ::std::marker::Sync for self::ColumnTypeDef {}

impl ::fbthrift::GetTType for self::ColumnTypeDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ColumnTypeDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ColumnTypeDef");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.type_length {
            p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.geo_shape {
            p.write_field_begin("geo_shape", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ColumnTypeDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("geo_shape", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_type_length = ::std::option::Option::None;
        let mut field_geo_shape = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_geo_shape = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            type_length: field_type_length,
            geo_shape: field_geo_shape,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ColumnDef {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            default_value: ::std::option::Option::None,
            nullable: ::std::option::Option::Some(false),
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ColumnDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ColumnDef")
            .field("name", &self.name)
            .field("r#type", &self.r#type)
            .field("default_value", &self.default_value)
            .field("nullable", &self.nullable)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ColumnDef {}
unsafe impl ::std::marker::Sync for self::ColumnDef {}

impl ::fbthrift::GetTType for self::ColumnDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ColumnDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ColumnDef");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.default_value {
            p.write_field_begin("default_value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.nullable {
            p.write_field_begin("nullable", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ColumnDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("default_value", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("nullable", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_default_value = ::std::option::Option::None;
        let mut field_nullable = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_default_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_nullable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            default_value: field_default_value,
            nullable: field_nullable,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SchemaProp {
    fn default() -> Self {
        Self {
            ttl_duration: ::std::option::Option::None,
            ttl_col: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SchemaProp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SchemaProp")
            .field("ttl_duration", &self.ttl_duration)
            .field("ttl_col", &self.ttl_col)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SchemaProp {}
unsafe impl ::std::marker::Sync for self::SchemaProp {}

impl ::fbthrift::GetTType for self::SchemaProp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SchemaProp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SchemaProp");
        if let ::std::option::Option::Some(some) = &self.ttl_duration {
            p.write_field_begin("ttl_duration", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.ttl_col {
            p.write_field_begin("ttl_col", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SchemaProp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("ttl_col", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("ttl_duration", ::fbthrift::TType::I64, 1),
        ];
        let mut field_ttl_duration = ::std::option::Option::None;
        let mut field_ttl_col = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_ttl_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_ttl_col = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            ttl_duration: field_ttl_duration,
            ttl_col: field_ttl_col,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Schema {
    fn default() -> Self {
        Self {
            columns: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Schema {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Schema")
            .field("columns", &self.columns)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Schema {}
unsafe impl ::std::marker::Sync for self::Schema {}

impl ::fbthrift::GetTType for self::Schema {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Schema
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Schema");
        p.write_field_begin("columns", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.columns, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Schema
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("columns", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_columns = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            columns: field_columns.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IdName {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IdName {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IdName")
            .field("id", &self.id)
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IdName {}
unsafe impl ::std::marker::Sync for self::IdName {}

impl ::fbthrift::GetTType for self::IdName {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IdName");
        p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IdName
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceDesc {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            partition_num: 0,
            replica_factor: 0,
            charset_name: ::std::default::Default::default(),
            collate_name: ::std::default::Default::default(),
            vid_type: crate::types::ColumnTypeDef {
                    r#type: crate::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                    geo_shape: ::std::default::Default::default(),
                    ..::std::default::Default::default()
                },
            group_name: ::std::option::Option::None,
            isolation_level: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceDesc")
            .field("space_name", &self.space_name)
            .field("partition_num", &self.partition_num)
            .field("replica_factor", &self.replica_factor)
            .field("charset_name", &self.charset_name)
            .field("collate_name", &self.collate_name)
            .field("vid_type", &self.vid_type)
            .field("group_name", &self.group_name)
            .field("isolation_level", &self.isolation_level)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceDesc {}
unsafe impl ::std::marker::Sync for self::SpaceDesc {}

impl ::fbthrift::GetTType for self::SpaceDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceDesc");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("partition_num", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.partition_num, p);
        p.write_field_end();
        p.write_field_begin("replica_factor", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.replica_factor, p);
        p.write_field_end();
        p.write_field_begin("charset_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.charset_name, p);
        p.write_field_end();
        p.write_field_begin("collate_name", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.collate_name, p);
        p.write_field_end();
        p.write_field_begin("vid_type", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.vid_type, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.group_name {
            p.write_field_begin("group_name", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.isolation_level {
            p.write_field_begin("isolation_level", ::fbthrift::TType::I32, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("charset_name", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("collate_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 9),
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 7),
            ::fbthrift::Field::new("isolation_level", ::fbthrift::TType::I32, 8),
            ::fbthrift::Field::new("partition_num", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("replica_factor", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("vid_type", ::fbthrift::TType::Struct, 6),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_partition_num = ::std::option::Option::None;
        let mut field_replica_factor = ::std::option::Option::None;
        let mut field_charset_name = ::std::option::Option::None;
        let mut field_collate_name = ::std::option::Option::None;
        let mut field_vid_type = ::std::option::Option::None;
        let mut field_group_name = ::std::option::Option::None;
        let mut field_isolation_level = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_partition_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_replica_factor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_charset_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_collate_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_vid_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 8) => field_isolation_level = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 9) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            partition_num: field_partition_num.unwrap_or(0),
            replica_factor: field_replica_factor.unwrap_or(0),
            charset_name: field_charset_name.unwrap_or_default(),
            collate_name: field_collate_name.unwrap_or_default(),
            vid_type: field_vid_type.unwrap_or_else(|| crate::types::ColumnTypeDef {
                    r#type: crate::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                    geo_shape: ::std::default::Default::default(),
                    ..::std::default::Default::default()
                }),
            group_name: field_group_name,
            isolation_level: field_isolation_level,
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceItem {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            properties: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceItem")
            .field("space_id", &self.space_id)
            .field("properties", &self.properties)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceItem {}
unsafe impl ::std::marker::Sync for self::SpaceItem {}

impl ::fbthrift::GetTType for self::SpaceItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceItem");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_properties = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            properties: field_properties.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TagItem {
    fn default() -> Self {
        Self {
            tag_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TagItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TagItem")
            .field("tag_id", &self.tag_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TagItem {}
unsafe impl ::std::marker::Sync for self::TagItem {}

impl ::fbthrift::GetTType for self::TagItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TagItem");
        p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.tag_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TagItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_tag_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_id: field_tag_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterSchemaItem {
    fn default() -> Self {
        Self {
            op: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterSchemaItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterSchemaItem")
            .field("op", &self.op)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterSchemaItem {}
unsafe impl ::std::marker::Sync for self::AlterSchemaItem {}

impl ::fbthrift::GetTType for self::AlterSchemaItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterSchemaItem");
        p.write_field_begin("op", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterSchemaItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_op = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            op: field_op.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::EdgeItem {
    fn default() -> Self {
        Self {
            edge_type: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::EdgeItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("EdgeItem")
            .field("edge_type", &self.edge_type)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::EdgeItem {}
unsafe impl ::std::marker::Sync for self::EdgeItem {}

impl ::fbthrift::GetTType for self::EdgeItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("EdgeItem");
        p.write_field_begin("edge_type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.edge_type, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::EdgeItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_edge_type = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            edge_type: field_edge_type.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexItem {
    fn default() -> Self {
        Self {
            index_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            schema_id: ::std::default::Default::default(),
            schema_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexItem")
            .field("index_id", &self.index_id)
            .field("index_name", &self.index_name)
            .field("schema_id", &self.schema_id)
            .field("schema_name", &self.schema_name)
            .field("fields", &self.fields)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexItem {}
unsafe impl ::std::marker::Sync for self::IndexItem {}

impl ::fbthrift::GetTType for self::IndexItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexItem");
        p.write_field_begin("index_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.index_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("schema_id", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema_id, p);
        p.write_field_end();
        p.write_field_begin("schema_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.schema_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 5);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("schema_id", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("schema_name", ::fbthrift::TType::String, 4),
        ];
        let mut field_index_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_schema_id = ::std::option::Option::None;
        let mut field_schema_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_schema_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            index_id: field_index_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            schema_id: field_schema_id.unwrap_or_default(),
            schema_name: field_schema_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostItem {
    fn default() -> Self {
        Self {
            hostAddr: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            leader_parts: ::std::default::Default::default(),
            all_parts: ::std::default::Default::default(),
            role: ::std::default::Default::default(),
            git_info_sha: ::std::default::Default::default(),
            zone_name: ::std::option::Option::None,
            version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostItem")
            .field("hostAddr", &self.hostAddr)
            .field("status", &self.status)
            .field("leader_parts", &self.leader_parts)
            .field("all_parts", &self.all_parts)
            .field("role", &self.role)
            .field("git_info_sha", &self.git_info_sha)
            .field("zone_name", &self.zone_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostItem {}
unsafe impl ::std::marker::Sync for self::HostItem {}

impl ::fbthrift::GetTType for self::HostItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostItem");
        p.write_field_begin("hostAddr", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.hostAddr, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.leader_parts, p);
        p.write_field_end();
        p.write_field_begin("all_parts", ::fbthrift::TType::Map, 4);
        ::fbthrift::Serialize::write(&self.all_parts, p);
        p.write_field_end();
        p.write_field_begin("role", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 6);
        ::fbthrift::Serialize::write(&self.git_info_sha, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.zone_name {
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.version {
            p.write_field_begin("version", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("all_parts", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("hostAddr", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 7),
        ];
        let mut field_hostAddr = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_leader_parts = ::std::option::Option::None;
        let mut field_all_parts = ::std::option::Option::None;
        let mut field_role = ::std::option::Option::None;
        let mut field_git_info_sha = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_hostAddr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_all_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 7) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            hostAddr: field_hostAddr.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            leader_parts: field_leader_parts.unwrap_or_default(),
            all_parts: field_all_parts.unwrap_or_default(),
            role: field_role.unwrap_or_default(),
            git_info_sha: field_git_info_sha.unwrap_or_default(),
            zone_name: field_zone_name,
            version: field_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UserItem {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            is_lock: ::std::default::Default::default(),
            max_queries_per_hour: ::std::default::Default::default(),
            max_updates_per_hour: ::std::default::Default::default(),
            max_connections_per_hour: ::std::default::Default::default(),
            max_user_connections: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UserItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UserItem")
            .field("account", &self.account)
            .field("is_lock", &self.is_lock)
            .field("max_queries_per_hour", &self.max_queries_per_hour)
            .field("max_updates_per_hour", &self.max_updates_per_hour)
            .field("max_connections_per_hour", &self.max_connections_per_hour)
            .field("max_user_connections", &self.max_user_connections)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UserItem {}
unsafe impl ::std::marker::Sync for self::UserItem {}

impl ::fbthrift::GetTType for self::UserItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UserItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UserItem");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("is_lock", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.is_lock, p);
        p.write_field_end();
        p.write_field_begin("max_queries_per_hour", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.max_queries_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_updates_per_hour", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.max_updates_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_connections_per_hour", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.max_connections_per_hour, p);
        p.write_field_end();
        p.write_field_begin("max_user_connections", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.max_user_connections, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UserItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("is_lock", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("max_connections_per_hour", ::fbthrift::TType::I32, 5),
            ::fbthrift::Field::new("max_queries_per_hour", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("max_updates_per_hour", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("max_user_connections", ::fbthrift::TType::I32, 6),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_is_lock = ::std::option::Option::None;
        let mut field_max_queries_per_hour = ::std::option::Option::None;
        let mut field_max_updates_per_hour = ::std::option::Option::None;
        let mut field_max_connections_per_hour = ::std::option::Option::None;
        let mut field_max_user_connections = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_is_lock = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_max_queries_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_max_updates_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_max_connections_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_max_user_connections = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            is_lock: field_is_lock.unwrap_or_default(),
            max_queries_per_hour: field_max_queries_per_hour.unwrap_or_default(),
            max_updates_per_hour: field_max_updates_per_hour.unwrap_or_default(),
            max_connections_per_hour: field_max_connections_per_hour.unwrap_or_default(),
            max_user_connections: field_max_user_connections.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RoleItem {
    fn default() -> Self {
        Self {
            user_id: ::std::default::Default::default(),
            space_id: ::std::default::Default::default(),
            role_type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RoleItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RoleItem")
            .field("user_id", &self.user_id)
            .field("space_id", &self.space_id)
            .field("role_type", &self.role_type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RoleItem {}
unsafe impl ::std::marker::Sync for self::RoleItem {}

impl ::fbthrift::GetTType for self::RoleItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RoleItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RoleItem");
        p.write_field_begin("user_id", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.user_id, p);
        p.write_field_end();
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("role_type", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.role_type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RoleItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_type", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("user_id", ::fbthrift::TType::String, 1),
        ];
        let mut field_user_id = ::std::option::Option::None;
        let mut field_space_id = ::std::option::Option::None;
        let mut field_role_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_user_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_role_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            user_id: field_user_id.unwrap_or_default(),
            space_id: field_space_id.unwrap_or_default(),
            role_type: field_role_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ExecResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ExecResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ExecResp")
            .field("code", &self.code)
            .field("id", &self.id)
            .field("leader", &self.leader)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ExecResp {}
unsafe impl ::std::marker::Sync for self::ExecResp {}

impl ::fbthrift::GetTType for self::ExecResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ExecResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ExecResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobReq {
    fn default() -> Self {
        Self {
            op: ::std::default::Default::default(),
            cmd: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobReq")
            .field("op", &self.op)
            .field("cmd", &self.cmd)
            .field("paras", &self.paras)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobReq {}
unsafe impl ::std::marker::Sync for self::AdminJobReq {}

impl ::fbthrift::GetTType for self::AdminJobReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobReq");
        p.write_field_begin("op", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.op, p);
        p.write_field_end();
        p.write_field_begin("cmd", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.cmd, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cmd", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
        ];
        let mut field_op = ::std::option::Option::None;
        let mut field_cmd = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            op: field_op.unwrap_or_default(),
            cmd: field_cmd.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::JobDesc {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            cmd: ::std::default::Default::default(),
            paras: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::JobDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("JobDesc")
            .field("id", &self.id)
            .field("cmd", &self.cmd)
            .field("paras", &self.paras)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::JobDesc {}
unsafe impl ::std::marker::Sync for self::JobDesc {}

impl ::fbthrift::GetTType for self::JobDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("JobDesc");
        p.write_field_begin("id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("cmd", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.cmd, p);
        p.write_field_end();
        p.write_field_begin("paras", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.paras, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::JobDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cmd", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 6),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_cmd = ::std::option::Option::None;
        let mut field_paras = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            cmd: field_cmd.unwrap_or_default(),
            paras: field_paras.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::TaskDesc {
    fn default() -> Self {
        Self {
            task_id: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            start_time: ::std::default::Default::default(),
            stop_time: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::TaskDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("TaskDesc")
            .field("task_id", &self.task_id)
            .field("host", &self.host)
            .field("status", &self.status)
            .field("start_time", &self.start_time)
            .field("stop_time", &self.stop_time)
            .field("job_id", &self.job_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::TaskDesc {}
unsafe impl ::std::marker::Sync for self::TaskDesc {}

impl ::fbthrift::GetTType for self::TaskDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("TaskDesc");
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("stop_time", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.stop_time, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 6);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::TaskDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 6),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_task_id = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_start_time = ::std::option::Option::None;
        let mut field_stop_time = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 6) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            task_id: field_task_id.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            start_time: field_start_time.unwrap_or_default(),
            stop_time: field_stop_time.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResult {
    fn default() -> Self {
        Self {
            job_id: ::std::option::Option::None,
            job_desc: ::std::option::Option::None,
            task_desc: ::std::option::Option::None,
            recovered_job_num: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResult {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResult")
            .field("job_id", &self.job_id)
            .field("job_desc", &self.job_desc)
            .field("task_desc", &self.task_desc)
            .field("recovered_job_num", &self.recovered_job_num)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResult {}
unsafe impl ::std::marker::Sync for self::AdminJobResult {}

impl ::fbthrift::GetTType for self::AdminJobResult {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResult");
        if let ::std::option::Option::Some(some) = &self.job_id {
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.job_desc {
            p.write_field_begin("job_desc", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.task_desc {
            p.write_field_begin("task_desc", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.recovered_job_num {
            p.write_field_begin("recovered_job_num", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResult
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("job_desc", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("recovered_job_num", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("task_desc", ::fbthrift::TType::List, 3),
        ];
        let mut field_job_id = ::std::option::Option::None;
        let mut field_job_desc = ::std::option::Option::None;
        let mut field_task_desc = ::std::option::Option::None;
        let mut field_recovered_job_num = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_job_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_task_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_recovered_job_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            job_id: field_job_id,
            job_desc: field_job_desc,
            task_desc: field_task_desc,
            recovered_job_num: field_recovered_job_num,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AdminJobResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AdminJobResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AdminJobResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AdminJobResp {}
unsafe impl ::std::marker::Sync for self::AdminJobResp {}

impl ::fbthrift::GetTType for self::AdminJobResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AdminJobResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Correlativity {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            proportion: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Correlativity {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Correlativity")
            .field("part_id", &self.part_id)
            .field("proportion", &self.proportion)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Correlativity {}
unsafe impl ::std::marker::Sync for self::Correlativity {}

impl ::fbthrift::GetTType for self::Correlativity {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Correlativity
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Correlativity");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("proportion", ::fbthrift::TType::Double, 2);
        ::fbthrift::Serialize::write(&self.proportion, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Correlativity
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("proportion", ::fbthrift::TType::Double, 2),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_proportion = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 2) => field_proportion = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            proportion: field_proportion.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::StatsItem {
    fn default() -> Self {
        Self {
            tag_vertices: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            space_vertices: ::std::default::Default::default(),
            space_edges: ::std::default::Default::default(),
            positive_part_correlativity: ::std::default::Default::default(),
            negative_part_correlativity: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::StatsItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("StatsItem")
            .field("tag_vertices", &self.tag_vertices)
            .field("edges", &self.edges)
            .field("space_vertices", &self.space_vertices)
            .field("space_edges", &self.space_edges)
            .field("positive_part_correlativity", &self.positive_part_correlativity)
            .field("negative_part_correlativity", &self.negative_part_correlativity)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::StatsItem {}
unsafe impl ::std::marker::Sync for self::StatsItem {}

impl ::fbthrift::GetTType for self::StatsItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::StatsItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("StatsItem");
        p.write_field_begin("tag_vertices", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.tag_vertices, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::Map, 2);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_begin("space_vertices", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.space_vertices, p);
        p.write_field_end();
        p.write_field_begin("space_edges", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.space_edges, p);
        p.write_field_end();
        p.write_field_begin("positive_part_correlativity", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.positive_part_correlativity, p);
        p.write_field_end();
        p.write_field_begin("negative_part_correlativity", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.negative_part_correlativity, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::StatsItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edges", ::fbthrift::TType::Map, 2),
            ::fbthrift::Field::new("negative_part_correlativity", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("positive_part_correlativity", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("space_edges", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("space_vertices", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("tag_vertices", ::fbthrift::TType::Map, 1),
        ];
        let mut field_tag_vertices = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let mut field_space_vertices = ::std::option::Option::None;
        let mut field_space_edges = ::std::option::Option::None;
        let mut field_positive_part_correlativity = ::std::option::Option::None;
        let mut field_negative_part_correlativity = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_tag_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 2) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_space_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_space_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_positive_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_negative_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            tag_vertices: field_tag_vertices.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            space_vertices: field_space_vertices.unwrap_or_default(),
            space_edges: field_space_edges.unwrap_or_default(),
            positive_part_correlativity: field_positive_part_correlativity.unwrap_or_default(),
            negative_part_correlativity: field_negative_part_correlativity.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSpaceReq {
    fn default() -> Self {
        Self {
            properties: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSpaceReq")
            .field("properties", &self.properties)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSpaceReq {}
unsafe impl ::std::marker::Sync for self::CreateSpaceReq {}

impl ::fbthrift::GetTType for self::CreateSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSpaceReq");
        p.write_field_begin("properties", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.properties, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_properties = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            properties: field_properties.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSpaceAsReq {
    fn default() -> Self {
        Self {
            old_space_name: ::std::default::Default::default(),
            new_space_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSpaceAsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSpaceAsReq")
            .field("old_space_name", &self.old_space_name)
            .field("new_space_name", &self.new_space_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSpaceAsReq {}
unsafe impl ::std::marker::Sync for self::CreateSpaceAsReq {}

impl ::fbthrift::GetTType for self::CreateSpaceAsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceAsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSpaceAsReq");
        p.write_field_begin("old_space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.old_space_name, p);
        p.write_field_end();
        p.write_field_begin("new_space_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.new_space_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceAsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("new_space_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("old_space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_old_space_name = ::std::option::Option::None;
        let mut field_new_space_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_old_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_new_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            old_space_name: field_old_space_name.unwrap_or_default(),
            new_space_name: field_new_space_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSpaceReq")
            .field("space_name", &self.space_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSpaceReq {}
unsafe impl ::std::marker::Sync for self::DropSpaceReq {}

impl ::fbthrift::GetTType for self::DropSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesReq {}
unsafe impl ::std::marker::Sync for self::ListSpacesReq {}

impl ::fbthrift::GetTType for self::ListSpacesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSpacesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            spaces: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSpacesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSpacesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("spaces", &self.spaces)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSpacesResp {}
unsafe impl ::std::marker::Sync for self::ListSpacesResp {}

impl ::fbthrift::GetTType for self::ListSpacesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSpacesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("spaces", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.spaces, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_spaces = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            spaces: field_spaces.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceReq {
    fn default() -> Self {
        Self {
            space_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceReq")
            .field("space_name", &self.space_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceReq {}
unsafe impl ::std::marker::Sync for self::GetSpaceReq {}

impl ::fbthrift::GetTType for self::GetSpaceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceReq");
        p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_space_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_name: field_space_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSpaceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSpaceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSpaceResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSpaceResp {}
unsafe impl ::std::marker::Sync for self::GetSpaceResp {}

impl ::fbthrift::GetTType for self::GetSpaceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSpaceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagReq {}
unsafe impl ::std::marker::Sync for self::CreateTagReq {}

impl ::fbthrift::GetTType for self::CreateTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            tag_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("tag_items", &self.tag_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterTagReq {}
unsafe impl ::std::marker::Sync for self::AlterTagReq {}

impl ::fbthrift::GetTType for self::AlterTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("tag_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tag_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_tag_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tag_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            tag_items: field_tag_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagReq {}
unsafe impl ::std::marker::Sync for self::DropTagReq {}

impl ::fbthrift::GetTType for self::DropTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsReq {}
unsafe impl ::std::marker::Sync for self::ListTagsReq {}

impl ::fbthrift::GetTType for self::ListTagsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            tags: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("tags", &self.tags)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagsResp {}
unsafe impl ::std::marker::Sync for self::ListTagsResp {}

impl ::fbthrift::GetTType for self::ListTagsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("tags", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.tags, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_tags = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            tags: field_tags.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagReq")
            .field("space_id", &self.space_id)
            .field("tag_name", &self.tag_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagReq {}
unsafe impl ::std::marker::Sync for self::GetTagReq {}

impl ::fbthrift::GetTType for self::GetTagReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagResp {}
unsafe impl ::std::marker::Sync for self::GetTagResp {}

impl ::fbthrift::GetTType for self::GetTagResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("schema", &self.schema)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeReq {}

impl ::fbthrift::GetTType for self::CreateEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            edge_items: ::std::default::Default::default(),
            schema_prop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("edge_items", &self.edge_items)
            .field("schema_prop", &self.schema_prop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterEdgeReq {}
unsafe impl ::std::marker::Sync for self::AlterEdgeReq {}

impl ::fbthrift::GetTType for self::AlterEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("edge_items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edge_items, p);
        p.write_field_end();
        p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.schema_prop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_edge_items = ::std::option::Option::None;
        let mut field_schema_prop = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edge_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            edge_items: field_edge_items.unwrap_or_default(),
            schema_prop: field_schema_prop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeReq {}

impl ::fbthrift::GetTType for self::GetEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("version", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            version: field_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            schema: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("schema", &self.schema)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeResp {}

impl ::fbthrift::GetTType for self::GetEdgeResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.schema, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_schema = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            schema: field_schema.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeReq")
            .field("space_id", &self.space_id)
            .field("edge_name", &self.edge_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeReq {}

impl ::fbthrift::GetTType for self::DropEdgeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgesReq {}

impl ::fbthrift::GetTType for self::ListEdgesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            edges: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("edges", &self.edges)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgesResp {}

impl ::fbthrift::GetTType for self::ListEdgesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("edges", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.edges, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_edges = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            edges: field_edges.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsReq")
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsReq {}
unsafe impl ::std::marker::Sync for self::ListHostsReq {}

impl ::fbthrift::GetTType for self::ListHostsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListHostsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListHostsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListHostsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListHostsResp {}
unsafe impl ::std::marker::Sync for self::ListHostsResp {}

impl ::fbthrift::GetTType for self::ListHostsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListHostsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListHostsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::PartItem {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            leader: ::std::option::Option::None,
            peers: ::std::default::Default::default(),
            losts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::PartItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("PartItem")
            .field("part_id", &self.part_id)
            .field("leader", &self.leader)
            .field("peers", &self.peers)
            .field("losts", &self.losts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::PartItem {}
unsafe impl ::std::marker::Sync for self::PartItem {}

impl ::fbthrift::GetTType for self::PartItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("PartItem");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader {
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("peers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.peers, p);
        p.write_field_end();
        p.write_field_begin("losts", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.losts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::PartItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("losts", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_peers = ::std::option::Option::None;
        let mut field_losts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_losts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            leader: field_leader,
            peers: field_peers.unwrap_or_default(),
            losts: field_losts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            part_ids: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsReq")
            .field("space_id", &self.space_id)
            .field("part_ids", &self.part_ids)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsReq {}
unsafe impl ::std::marker::Sync for self::ListPartsReq {}

impl ::fbthrift::GetTType for self::ListPartsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("part_ids", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.part_ids, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_ids", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_part_ids = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_part_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            part_ids: field_part_ids.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListPartsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListPartsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListPartsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListPartsResp {}
unsafe impl ::std::marker::Sync for self::ListPartsResp {}

impl ::fbthrift::GetTType for self::ListPartsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListPartsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListPartsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocReq {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocReq {}

impl ::fbthrift::GetTType for self::GetPartsAllocReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetPartsAllocResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            parts: ::std::default::Default::default(),
            terms: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetPartsAllocResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetPartsAllocResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("parts", &self.parts)
            .field("terms", &self.terms)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetPartsAllocResp {}
unsafe impl ::std::marker::Sync for self::GetPartsAllocResp {}

impl ::fbthrift::GetTType for self::GetPartsAllocResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetPartsAllocResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.parts, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.terms {
            p.write_field_begin("terms", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("terms", ::fbthrift::TType::Map, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_parts = ::std::option::Option::None;
        let mut field_terms = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_terms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            parts: field_parts.unwrap_or_default(),
            terms: field_terms,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiPutReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            pairs: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiPutReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiPutReq")
            .field("segment", &self.segment)
            .field("pairs", &self.pairs)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiPutReq {}
unsafe impl ::std::marker::Sync for self::MultiPutReq {}

impl ::fbthrift::GetTType for self::MultiPutReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiPutReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiPutReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("pairs", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.pairs, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiPutReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("pairs", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_pairs = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_pairs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            pairs: field_pairs.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            key: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetReq")
            .field("segment", &self.segment)
            .field("key", &self.key)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetReq {}
unsafe impl ::std::marker::Sync for self::GetReq {}

impl ::fbthrift::GetTType for self::GetReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("key", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_key = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            key: field_key.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetResp {}
unsafe impl ::std::marker::Sync for self::GetResp {}

impl ::fbthrift::GetTType for self::GetResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiGetReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            keys: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiGetReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiGetReq")
            .field("segment", &self.segment)
            .field("keys", &self.keys)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiGetReq {}
unsafe impl ::std::marker::Sync for self::MultiGetReq {}

impl ::fbthrift::GetTType for self::MultiGetReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiGetReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiGetReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("keys", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.keys, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiGetReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("keys", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_keys = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            keys: field_keys.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MultiGetResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MultiGetResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MultiGetResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MultiGetResp {}
unsafe impl ::std::marker::Sync for self::MultiGetResp {}

impl ::fbthrift::GetTType for self::MultiGetResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::MultiGetResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MultiGetResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("values", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MultiGetResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            key: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveReq")
            .field("segment", &self.segment)
            .field("key", &self.key)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveReq {}
unsafe impl ::std::marker::Sync for self::RemoveReq {}

impl ::fbthrift::GetTType for self::RemoveReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("key", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.key, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_key = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            key: field_key.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveRangeReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            start: ::std::default::Default::default(),
            end: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveRangeReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveRangeReq")
            .field("segment", &self.segment)
            .field("start", &self.start)
            .field("end", &self.end)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveRangeReq {}
unsafe impl ::std::marker::Sync for self::RemoveRangeReq {}

impl ::fbthrift::GetTType for self::RemoveRangeReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveRangeReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("start", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.start, p);
        p.write_field_end();
        p.write_field_begin("end", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.end, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_start = ::std::option::Option::None;
        let mut field_end = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            start: field_start.unwrap_or_default(),
            end: field_end.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanReq {
    fn default() -> Self {
        Self {
            segment: ::std::default::Default::default(),
            start: ::std::default::Default::default(),
            end: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanReq")
            .field("segment", &self.segment)
            .field("start", &self.start)
            .field("end", &self.end)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanReq {}
unsafe impl ::std::marker::Sync for self::ScanReq {}

impl ::fbthrift::GetTType for self::ScanReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanReq");
        p.write_field_begin("segment", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.segment, p);
        p.write_field_end();
        p.write_field_begin("start", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.start, p);
        p.write_field_end();
        p.write_field_begin("end", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.end, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
        ];
        let mut field_segment = ::std::option::Option::None;
        let mut field_start = ::std::option::Option::None;
        let mut field_end = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            segment: field_segment.unwrap_or_default(),
            start: field_start.unwrap_or_default(),
            end: field_end.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ScanResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            values: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ScanResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ScanResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("values", &self.values)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ScanResp {}
unsafe impl ::std::marker::Sync for self::ScanResp {}

impl ::fbthrift::GetTType for self::ScanResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ScanResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ScanResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("values", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.values, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ScanResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_values = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            values: field_values.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            last_update_time_in_ms: ::std::default::Default::default(),
            meta_version: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("cluster_id", &self.cluster_id)
            .field("last_update_time_in_ms", &self.last_update_time_in_ms)
            .field("meta_version", &self.meta_version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBResp {}
unsafe impl ::std::marker::Sync for self::HBResp {}

impl ::fbthrift::GetTType for self::HBResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        p.write_field_begin("last_update_time_in_ms", ::fbthrift::TType::I64, 4);
        ::fbthrift::Serialize::write(&self.last_update_time_in_ms, p);
        p.write_field_end();
        p.write_field_begin("meta_version", ::fbthrift::TType::I32, 5);
        ::fbthrift::Serialize::write(&self.meta_version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("last_update_time_in_ms", ::fbthrift::TType::I64, 4),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("meta_version", ::fbthrift::TType::I32, 5),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_last_update_time_in_ms = ::std::option::Option::None;
        let mut field_meta_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 4) => field_last_update_time_in_ms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 5) => field_meta_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            last_update_time_in_ms: field_last_update_time_in_ms.unwrap_or_default(),
            meta_version: field_meta_version.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LeaderInfo {
    fn default() -> Self {
        Self {
            part_id: ::std::default::Default::default(),
            term: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LeaderInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LeaderInfo")
            .field("part_id", &self.part_id)
            .field("term", &self.term)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LeaderInfo {}
unsafe impl ::std::marker::Sync for self::LeaderInfo {}

impl ::fbthrift::GetTType for self::LeaderInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LeaderInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LeaderInfo");
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("term", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.term, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LeaderInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 2),
        ];
        let mut field_part_id = ::std::option::Option::None;
        let mut field_term = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            part_id: field_part_id.unwrap_or_default(),
            term: field_term.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HBReq {
    fn default() -> Self {
        Self {
            role: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            cluster_id: ::std::default::Default::default(),
            leader_partIds: ::std::option::Option::None,
            git_info_sha: ::std::default::Default::default(),
            version: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HBReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HBReq")
            .field("role", &self.role)
            .field("host", &self.host)
            .field("cluster_id", &self.cluster_id)
            .field("leader_partIds", &self.leader_partIds)
            .field("git_info_sha", &self.git_info_sha)
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HBReq {}
unsafe impl ::std::marker::Sync for self::HBReq {}

impl ::fbthrift::GetTType for self::HBReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HBReq");
        p.write_field_begin("role", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.role, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.cluster_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.leader_partIds {
            p.write_field_begin("leader_partIds", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.git_info_sha, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.version {
            p.write_field_begin("version", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HBReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("leader_partIds", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 6),
        ];
        let mut field_role = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_cluster_id = ::std::option::Option::None;
        let mut field_leader_partIds = ::std::option::Option::None;
        let mut field_git_info_sha = ::std::option::Option::None;
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_leader_partIds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role: field_role.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            cluster_id: field_cluster_id.unwrap_or_default(),
            leader_partIds: field_leader_partIds,
            git_info_sha: field_git_info_sha.unwrap_or_default(),
            version: field_version,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexFieldDef {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            type_length: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexFieldDef {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexFieldDef")
            .field("name", &self.name)
            .field("type_length", &self.type_length)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexFieldDef {}
unsafe impl ::std::marker::Sync for self::IndexFieldDef {}

impl ::fbthrift::GetTType for self::IndexFieldDef {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexFieldDef
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexFieldDef");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.type_length {
            p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexFieldDef
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_type_length = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            type_length: field_type_length,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            tag_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("tag_name", &self.tag_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateTagIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateTagIndexReq {}

impl ::fbthrift::GetTType for self::CreateTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("tag_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.tag_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 3),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_tag_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            tag_name: field_tag_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropTagIndexReq {}
unsafe impl ::std::marker::Sync for self::DropTagIndexReq {}

impl ::fbthrift::GetTType for self::DropTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexReq {}
unsafe impl ::std::marker::Sync for self::GetTagIndexReq {}

impl ::fbthrift::GetTType for self::GetTagIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetTagIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetTagIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetTagIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetTagIndexResp {}
unsafe impl ::std::marker::Sync for self::GetTagIndexResp {}

impl ::fbthrift::GetTType for self::GetTagIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetTagIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesReq {}

impl ::fbthrift::GetTType for self::ListTagIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListTagIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListTagIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListTagIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListTagIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListTagIndexesResp {}

impl ::fbthrift::GetTType for self::ListTagIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListTagIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            edge_name: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            comment: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("edge_name", &self.edge_name)
            .field("fields", &self.fields)
            .field("if_not_exists", &self.if_not_exists)
            .field("comment", &self.comment)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateEdgeIndexReq {}

impl ::fbthrift::GetTType for self::CreateEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("edge_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.edge_name, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.comment {
            p.write_field_begin("comment", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
            ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_edge_name = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let mut field_comment = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            edge_name: field_edge_name.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            comment: field_comment,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::DropEdgeIndexReq {}

impl ::fbthrift::GetTType for self::DropEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexReq {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexReq {}

impl ::fbthrift::GetTType for self::GetEdgeIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetEdgeIndexResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetEdgeIndexResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetEdgeIndexResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetEdgeIndexResp {}
unsafe impl ::std::marker::Sync for self::GetEdgeIndexResp {}

impl ::fbthrift::GetTType for self::GetEdgeIndexResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetEdgeIndexResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesReq {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListEdgeIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListEdgeIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListEdgeIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListEdgeIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListEdgeIndexesResp {}

impl ::fbthrift::GetTType for self::ListEdgeIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListEdgeIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RebuildIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RebuildIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RebuildIndexReq")
            .field("space_id", &self.space_id)
            .field("index_name", &self.index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RebuildIndexReq {}
unsafe impl ::std::marker::Sync for self::RebuildIndexReq {}

impl ::fbthrift::GetTType for self::RebuildIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RebuildIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            index_name: field_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            if_not_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .field("if_not_exists", &self.if_not_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateUserReq {}
unsafe impl ::std::marker::Sync for self::CreateUserReq {}

impl ::fbthrift::GetTType for self::CreateUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 3);
        ::fbthrift::Serialize::write(&self.if_not_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let mut field_if_not_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 3) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            if_not_exists: field_if_not_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            if_exists: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropUserReq")
            .field("account", &self.account)
            .field("if_exists", &self.if_exists)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropUserReq {}
unsafe impl ::std::marker::Sync for self::DropUserReq {}

impl ::fbthrift::GetTType for self::DropUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.if_exists, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_if_exists = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            if_exists: field_if_exists.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AlterUserReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AlterUserReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AlterUserReq")
            .field("account", &self.account)
            .field("encoded_pwd", &self.encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AlterUserReq {}
unsafe impl ::std::marker::Sync for self::AlterUserReq {}

impl ::fbthrift::GetTType for self::AlterUserReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AlterUserReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AlterUserReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GrantRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GrantRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GrantRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GrantRoleReq {}
unsafe impl ::std::marker::Sync for self::GrantRoleReq {}

impl ::fbthrift::GetTType for self::GrantRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GrantRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GrantRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RevokeRoleReq {
    fn default() -> Self {
        Self {
            role_item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RevokeRoleReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RevokeRoleReq")
            .field("role_item", &self.role_item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RevokeRoleReq {}
unsafe impl ::std::marker::Sync for self::RevokeRoleReq {}

impl ::fbthrift::GetTType for self::RevokeRoleReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RevokeRoleReq");
        p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.role_item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RevokeRoleReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_role_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            role_item: field_role_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersReq {}
unsafe impl ::std::marker::Sync for self::ListUsersReq {}

impl ::fbthrift::GetTType for self::ListUsersReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListUsersResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            users: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListUsersResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListUsersResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("users", &self.users)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListUsersResp {}
unsafe impl ::std::marker::Sync for self::ListUsersResp {}

impl ::fbthrift::GetTType for self::ListUsersResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListUsersResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("users", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.users, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListUsersResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("users", ::fbthrift::TType::Map, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_users = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_users = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            users: field_users.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesReq {}
unsafe impl ::std::marker::Sync for self::ListRolesReq {}

impl ::fbthrift::GetTType for self::ListRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListRolesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            roles: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListRolesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListRolesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("roles", &self.roles)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListRolesResp {}
unsafe impl ::std::marker::Sync for self::ListRolesResp {}

impl ::fbthrift::GetTType for self::ListRolesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListRolesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("roles", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.roles, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListRolesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("roles", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_roles = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_roles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            roles: field_roles.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetUserRolesReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetUserRolesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetUserRolesReq")
            .field("account", &self.account)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetUserRolesReq {}
unsafe impl ::std::marker::Sync for self::GetUserRolesReq {}

impl ::fbthrift::GetTType for self::GetUserRolesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetUserRolesReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetUserRolesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
        ];
        let mut field_account = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ChangePasswordReq {
    fn default() -> Self {
        Self {
            account: ::std::default::Default::default(),
            new_encoded_pwd: ::std::default::Default::default(),
            old_encoded_pwd: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ChangePasswordReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ChangePasswordReq")
            .field("account", &self.account)
            .field("new_encoded_pwd", &self.new_encoded_pwd)
            .field("old_encoded_pwd", &self.old_encoded_pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ChangePasswordReq {}
unsafe impl ::std::marker::Sync for self::ChangePasswordReq {}

impl ::fbthrift::GetTType for self::ChangePasswordReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ChangePasswordReq");
        p.write_field_begin("account", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.account, p);
        p.write_field_end();
        p.write_field_begin("new_encoded_pwd", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.new_encoded_pwd, p);
        p.write_field_end();
        p.write_field_begin("old_encoded_pwd", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.old_encoded_pwd, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ChangePasswordReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("new_encoded_pwd", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("old_encoded_pwd", ::fbthrift::TType::String, 3),
        ];
        let mut field_account = ::std::option::Option::None;
        let mut field_new_encoded_pwd = ::std::option::Option::None;
        let mut field_old_encoded_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_new_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_old_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            account: field_account.unwrap_or_default(),
            new_encoded_pwd: field_new_encoded_pwd.unwrap_or_default(),
            old_encoded_pwd: field_old_encoded_pwd.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceReq {
    fn default() -> Self {
        Self {
            space_id: ::std::option::Option::None,
            id: ::std::option::Option::None,
            host_del: ::std::option::Option::None,
            stop: ::std::option::Option::None,
            reset: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceReq")
            .field("space_id", &self.space_id)
            .field("id", &self.id)
            .field("host_del", &self.host_del)
            .field("stop", &self.stop)
            .field("reset", &self.reset)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceReq {}
unsafe impl ::std::marker::Sync for self::BalanceReq {}

impl ::fbthrift::GetTType for self::BalanceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceReq");
        if let ::std::option::Option::Some(some) = &self.space_id {
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.id {
            p.write_field_begin("id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.host_del {
            p.write_field_begin("host_del", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.stop {
            p.write_field_begin("stop", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.reset {
            p.write_field_begin("reset", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host_del", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("reset", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("stop", ::fbthrift::TType::Bool, 4),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_host_del = ::std::option::Option::None;
        let mut field_stop = ::std::option::Option::None;
        let mut field_reset = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_host_del = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_stop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_reset = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id,
            id: field_id,
            host_del: field_host_del,
            stop: field_stop,
            reset: field_reset,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceTask {
    fn default() -> Self {
        Self {
            id: ::std::default::Default::default(),
            result: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceTask {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceTask")
            .field("id", &self.id)
            .field("result", &self.result)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceTask {}
unsafe impl ::std::marker::Sync for self::BalanceTask {}

impl ::fbthrift::GetTType for self::BalanceTask {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceTask");
        p.write_field_begin("id", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("result", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.result, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceTask
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("result", ::fbthrift::TType::I32, 2),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_result = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.unwrap_or_default(),
            result: field_result.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BalanceResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            id: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            tasks: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BalanceResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BalanceResp")
            .field("code", &self.code)
            .field("id", &self.id)
            .field("leader", &self.leader)
            .field("tasks", &self.tasks)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BalanceResp {}
unsafe impl ::std::marker::Sync for self::BalanceResp {}

impl ::fbthrift::GetTType for self::BalanceResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BalanceResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BalanceResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("id", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.id, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("tasks", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.tasks, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BalanceResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("tasks", ::fbthrift::TType::List, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_id = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_tasks = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_tasks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            id: field_id.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            tasks: field_tasks.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LeaderBalanceReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LeaderBalanceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LeaderBalanceReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LeaderBalanceReq {}
unsafe impl ::std::marker::Sync for self::LeaderBalanceReq {}

impl ::fbthrift::GetTType for self::LeaderBalanceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::LeaderBalanceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LeaderBalanceReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LeaderBalanceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ConfigItem {
    fn default() -> Self {
        Self {
            module: ::std::default::Default::default(),
            name: ::std::default::Default::default(),
            mode: ::std::default::Default::default(),
            value: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ConfigItem {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ConfigItem")
            .field("module", &self.module)
            .field("name", &self.name)
            .field("mode", &self.mode)
            .field("value", &self.value)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ConfigItem {}
unsafe impl ::std::marker::Sync for self::ConfigItem {}

impl ::fbthrift::GetTType for self::ConfigItem {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ConfigItem");
        p.write_field_begin("module", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_begin("name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.mode, p);
        p.write_field_end();
        p.write_field_begin("value", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.value, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ConfigItem
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("value", ::fbthrift::TType::Struct, 4),
        ];
        let mut field_module = ::std::option::Option::None;
        let mut field_name = ::std::option::Option::None;
        let mut field_mode = ::std::option::Option::None;
        let mut field_value = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            module: field_module.unwrap_or_default(),
            name: field_name.unwrap_or_default(),
            mode: field_mode.unwrap_or_default(),
            value: field_value.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RegConfigReq {
    fn default() -> Self {
        Self {
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RegConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RegConfigReq")
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RegConfigReq {}
unsafe impl ::std::marker::Sync for self::RegConfigReq {}

impl ::fbthrift::GetTType for self::RegConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RegConfigReq");
        p.write_field_begin("items", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RegConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 1),
        ];
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigReq")
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigReq {}
unsafe impl ::std::marker::Sync for self::GetConfigReq {}

impl ::fbthrift::GetTType for self::GetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetConfigResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetConfigResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetConfigResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetConfigResp {}
unsafe impl ::std::marker::Sync for self::GetConfigResp {}

impl ::fbthrift::GetTType for self::GetConfigResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetConfigResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetConfigResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SetConfigReq {
    fn default() -> Self {
        Self {
            item: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SetConfigReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SetConfigReq")
            .field("item", &self.item)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SetConfigReq {}
unsafe impl ::std::marker::Sync for self::SetConfigReq {}

impl ::fbthrift::GetTType for self::SetConfigReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SetConfigReq");
        p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.item, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SetConfigReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_item = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            item: field_item.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsReq {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            module: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsReq")
            .field("space", &self.space)
            .field("module", &self.module)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsReq {}
unsafe impl ::std::marker::Sync for self::ListConfigsReq {}

impl ::fbthrift::GetTType for self::ListConfigsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsReq");
        p.write_field_begin("space", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("module", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.module, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::String, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_module = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            module: field_module.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListConfigsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            items: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListConfigsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListConfigsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("items", &self.items)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListConfigsResp {}
unsafe impl ::std::marker::Sync for self::ListConfigsResp {}

impl ::fbthrift::GetTType for self::ListConfigsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListConfigsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("items", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.items, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_items = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            items: field_items.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSnapshotReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSnapshotReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSnapshotReq {}
unsafe impl ::std::marker::Sync for self::CreateSnapshotReq {}

impl ::fbthrift::GetTType for self::CreateSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSnapshotReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropSnapshotReq {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropSnapshotReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropSnapshotReq")
            .field("name", &self.name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropSnapshotReq {}
unsafe impl ::std::marker::Sync for self::DropSnapshotReq {}

impl ::fbthrift::GetTType for self::DropSnapshotReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropSnapshotReq");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropSnapshotReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
        ];
        let mut field_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsReq {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsReq {}

impl ::fbthrift::GetTType for self::ListSnapshotsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Snapshot {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Snapshot {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Snapshot")
            .field("name", &self.name)
            .field("status", &self.status)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Snapshot {}
unsafe impl ::std::marker::Sync for self::Snapshot {}

impl ::fbthrift::GetTType for self::Snapshot {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Snapshot");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Snapshot
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSnapshotsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            snapshots: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSnapshotsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSnapshotsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("snapshots", &self.snapshots)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSnapshotsResp {}
unsafe impl ::std::marker::Sync for self::ListSnapshotsResp {}

impl ::fbthrift::GetTType for self::ListSnapshotsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSnapshotsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("snapshots", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.snapshots, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("snapshots", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_snapshots = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_snapshots = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            snapshots: field_snapshots.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusReq {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusReq {}

impl ::fbthrift::GetTType for self::ListIndexStatusReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::IndexStatus {
    fn default() -> Self {
        Self {
            name: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::IndexStatus {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("IndexStatus")
            .field("name", &self.name)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::IndexStatus {}
unsafe impl ::std::marker::Sync for self::IndexStatus {}

impl ::fbthrift::GetTType for self::IndexStatus {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("IndexStatus");
        p.write_field_begin("name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.name, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::IndexStatus
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::String, 2),
        ];
        let mut field_name = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            name: field_name.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListIndexStatusResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            statuses: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListIndexStatusResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListIndexStatusResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("statuses", &self.statuses)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListIndexStatusResp {}
unsafe impl ::std::marker::Sync for self::ListIndexStatusResp {}

impl ::fbthrift::GetTType for self::ListIndexStatusResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListIndexStatusResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("statuses", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.statuses, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("statuses", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_statuses = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_statuses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            statuses: field_statuses.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            nodes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddZoneReq")
            .field("zone_name", &self.zone_name)
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddZoneReq {}
unsafe impl ::std::marker::Sync for self::AddZoneReq {}

impl ::fbthrift::GetTType for self::AddZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("nodes", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.nodes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_nodes = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            nodes: field_nodes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropZoneReq")
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropZoneReq {}
unsafe impl ::std::marker::Sync for self::DropZoneReq {}

impl ::fbthrift::GetTType for self::DropZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddHostIntoZoneReq {
    fn default() -> Self {
        Self {
            node: ::std::default::Default::default(),
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddHostIntoZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddHostIntoZoneReq")
            .field("node", &self.node)
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddHostIntoZoneReq {}
unsafe impl ::std::marker::Sync for self::AddHostIntoZoneReq {}

impl ::fbthrift::GetTType for self::AddHostIntoZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddHostIntoZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddHostIntoZoneReq");
        p.write_field_begin("node", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.node, p);
        p.write_field_end();
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddHostIntoZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("node", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_node = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_node = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            node: field_node.unwrap_or_default(),
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropHostFromZoneReq {
    fn default() -> Self {
        Self {
            node: ::std::default::Default::default(),
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropHostFromZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropHostFromZoneReq")
            .field("node", &self.node)
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropHostFromZoneReq {}
unsafe impl ::std::marker::Sync for self::DropHostFromZoneReq {}

impl ::fbthrift::GetTType for self::DropHostFromZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropHostFromZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropHostFromZoneReq");
        p.write_field_begin("node", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.node, p);
        p.write_field_end();
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropHostFromZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("node", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
        ];
        let mut field_node = ::std::option::Option::None;
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_node = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            node: field_node.unwrap_or_default(),
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetZoneReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetZoneReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetZoneReq")
            .field("zone_name", &self.zone_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetZoneReq {}
unsafe impl ::std::marker::Sync for self::GetZoneReq {}

impl ::fbthrift::GetTType for self::GetZoneReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetZoneReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetZoneReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetZoneReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetZoneResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetZoneResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetZoneResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetZoneResp {}
unsafe impl ::std::marker::Sync for self::GetZoneResp {}

impl ::fbthrift::GetTType for self::GetZoneResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetZoneResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetZoneResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetZoneResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListZonesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListZonesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListZonesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListZonesReq {}
unsafe impl ::std::marker::Sync for self::ListZonesReq {}

impl ::fbthrift::GetTType for self::ListZonesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListZonesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListZonesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListZonesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Zone {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            nodes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Zone {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Zone")
            .field("zone_name", &self.zone_name)
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Zone {}
unsafe impl ::std::marker::Sync for self::Zone {}

impl ::fbthrift::GetTType for self::Zone {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Zone
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Zone");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("nodes", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.nodes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Zone
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_nodes = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            nodes: field_nodes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListZonesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            zones: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListZonesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListZonesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("zones", &self.zones)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListZonesResp {}
unsafe impl ::std::marker::Sync for self::ListZonesResp {}

impl ::fbthrift::GetTType for self::ListZonesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListZonesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListZonesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("zones", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.zones, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListZonesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("zones", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_zones = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_zones = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            zones: field_zones.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddGroupReq {
    fn default() -> Self {
        Self {
            group_name: ::std::default::Default::default(),
            zone_names: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddGroupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddGroupReq")
            .field("group_name", &self.group_name)
            .field("zone_names", &self.zone_names)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddGroupReq {}
unsafe impl ::std::marker::Sync for self::AddGroupReq {}

impl ::fbthrift::GetTType for self::AddGroupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddGroupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddGroupReq");
        p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_begin("zone_names", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.zone_names, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddGroupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 2),
        ];
        let mut field_group_name = ::std::option::Option::None;
        let mut field_zone_names = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            group_name: field_group_name.unwrap_or_default(),
            zone_names: field_zone_names.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropGroupReq {
    fn default() -> Self {
        Self {
            group_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropGroupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropGroupReq")
            .field("group_name", &self.group_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropGroupReq {}
unsafe impl ::std::marker::Sync for self::DropGroupReq {}

impl ::fbthrift::GetTType for self::DropGroupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropGroupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropGroupReq");
        p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropGroupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_group_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            group_name: field_group_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddZoneIntoGroupReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            group_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddZoneIntoGroupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddZoneIntoGroupReq")
            .field("zone_name", &self.zone_name)
            .field("group_name", &self.group_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddZoneIntoGroupReq {}
unsafe impl ::std::marker::Sync for self::AddZoneIntoGroupReq {}

impl ::fbthrift::GetTType for self::AddZoneIntoGroupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddZoneIntoGroupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddZoneIntoGroupReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("group_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddZoneIntoGroupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_group_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            group_name: field_group_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropZoneFromGroupReq {
    fn default() -> Self {
        Self {
            zone_name: ::std::default::Default::default(),
            group_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropZoneFromGroupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropZoneFromGroupReq")
            .field("zone_name", &self.zone_name)
            .field("group_name", &self.group_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropZoneFromGroupReq {}
unsafe impl ::std::marker::Sync for self::DropZoneFromGroupReq {}

impl ::fbthrift::GetTType for self::DropZoneFromGroupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropZoneFromGroupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropZoneFromGroupReq");
        p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.zone_name, p);
        p.write_field_end();
        p.write_field_begin("group_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropZoneFromGroupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_zone_name = ::std::option::Option::None;
        let mut field_group_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            zone_name: field_zone_name.unwrap_or_default(),
            group_name: field_group_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetGroupReq {
    fn default() -> Self {
        Self {
            group_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetGroupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetGroupReq")
            .field("group_name", &self.group_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetGroupReq {}
unsafe impl ::std::marker::Sync for self::GetGroupReq {}

impl ::fbthrift::GetTType for self::GetGroupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetGroupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetGroupReq");
        p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetGroupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
        ];
        let mut field_group_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            group_name: field_group_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetGroupResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            zone_names: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetGroupResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetGroupResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("zone_names", &self.zone_names)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetGroupResp {}
unsafe impl ::std::marker::Sync for self::GetGroupResp {}

impl ::fbthrift::GetTType for self::GetGroupResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetGroupResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetGroupResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("zone_names", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.zone_names, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetGroupResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_zone_names = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            zone_names: field_zone_names.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListGroupsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListGroupsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListGroupsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListGroupsReq {}
unsafe impl ::std::marker::Sync for self::ListGroupsReq {}

impl ::fbthrift::GetTType for self::ListGroupsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListGroupsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListGroupsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListGroupsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Group {
    fn default() -> Self {
        Self {
            group_name: ::std::default::Default::default(),
            zone_names: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Group {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Group")
            .field("group_name", &self.group_name)
            .field("zone_names", &self.zone_names)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Group {}
unsafe impl ::std::marker::Sync for self::Group {}

impl ::fbthrift::GetTType for self::Group {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Group
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Group");
        p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.group_name, p);
        p.write_field_end();
        p.write_field_begin("zone_names", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.zone_names, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Group
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 2),
        ];
        let mut field_group_name = ::std::option::Option::None;
        let mut field_zone_names = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            group_name: field_group_name.unwrap_or_default(),
            zone_names: field_zone_names.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListGroupsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            groups: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListGroupsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListGroupsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("groups", &self.groups)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListGroupsResp {}
unsafe impl ::std::marker::Sync for self::ListGroupsResp {}

impl ::fbthrift::GetTType for self::ListGroupsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListGroupsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListGroupsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("groups", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.groups, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListGroupsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("groups", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_groups = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_groups = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            groups: field_groups.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::AddListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::AddListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("AddListenerReq")
            .field("space_id", &self.space_id)
            .field("r#type", &self.r#type)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::AddListenerReq {}
unsafe impl ::std::marker::Sync for self::AddListenerReq {}

impl ::fbthrift::GetTType for self::AddListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::AddListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("AddListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::AddListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            r#type: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveListenerReq")
            .field("space_id", &self.space_id)
            .field("r#type", &self.r#type)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveListenerReq {}
unsafe impl ::std::marker::Sync for self::RemoveListenerReq {}

impl ::fbthrift::GetTType for self::RemoveListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("type", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_type = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            r#type: field_type.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListListenerReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListListenerReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListListenerReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListListenerReq {}
unsafe impl ::std::marker::Sync for self::ListListenerReq {}

impl ::fbthrift::GetTType for self::ListListenerReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListListenerReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListListenerReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListListenerReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListenerInfo {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            host: ::std::default::Default::default(),
            part_id: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListenerInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListenerInfo")
            .field("r#type", &self.r#type)
            .field("host", &self.host)
            .field("part_id", &self.part_id)
            .field("status", &self.status)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListenerInfo {}
unsafe impl ::std::marker::Sync for self::ListenerInfo {}

impl ::fbthrift::GetTType for self::ListenerInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListenerInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListenerInfo");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.part_id, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListenerInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 3),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_host = ::std::option::Option::None;
        let mut field_part_id = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            host: field_host.unwrap_or_default(),
            part_id: field_part_id.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListListenerResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            listeners: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListListenerResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListListenerResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("listeners", &self.listeners)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListListenerResp {}
unsafe impl ::std::marker::Sync for self::ListListenerResp {}

impl ::fbthrift::GetTType for self::ListListenerResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListListenerResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListListenerResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("listeners", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.listeners, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListListenerResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("listeners", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_listeners = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_listeners = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            listeners: field_listeners.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStatsReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStatsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStatsReq")
            .field("space_id", &self.space_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStatsReq {}
unsafe impl ::std::marker::Sync for self::GetStatsReq {}

impl ::fbthrift::GetTType for self::GetStatsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStatsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStatsReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStatsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetStatsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            stats: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetStatsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetStatsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("stats", &self.stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetStatsResp {}
unsafe impl ::std::marker::Sync for self::GetStatsResp {}

impl ::fbthrift::GetTType for self::GetStatsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetStatsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetStatsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("stats", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.stats, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetStatsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("stats", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            stats: field_stats.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BackupInfo {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            info: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BackupInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BackupInfo")
            .field("host", &self.host)
            .field("info", &self.info)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BackupInfo {}
unsafe impl ::std::marker::Sync for self::BackupInfo {}

impl ::fbthrift::GetTType for self::BackupInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BackupInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BackupInfo");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        p.write_field_begin("info", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.info, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BackupInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("info", ::fbthrift::TType::List, 2),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_info = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            info: field_info.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SpaceBackupInfo {
    fn default() -> Self {
        Self {
            space: ::std::default::Default::default(),
            info: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SpaceBackupInfo {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SpaceBackupInfo")
            .field("space", &self.space)
            .field("info", &self.info)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SpaceBackupInfo {}
unsafe impl ::std::marker::Sync for self::SpaceBackupInfo {}

impl ::fbthrift::GetTType for self::SpaceBackupInfo {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SpaceBackupInfo
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SpaceBackupInfo");
        p.write_field_begin("space", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.space, p);
        p.write_field_end();
        p.write_field_begin("info", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.info, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SpaceBackupInfo
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("info", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("space", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_space = ::std::option::Option::None;
        let mut field_info = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space: field_space.unwrap_or_default(),
            info: field_info.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BackupMeta {
    fn default() -> Self {
        Self {
            backup_info: ::std::default::Default::default(),
            meta_files: ::std::default::Default::default(),
            backup_name: ::std::default::Default::default(),
            full: ::std::default::Default::default(),
            include_system_space: ::std::default::Default::default(),
            create_time: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BackupMeta {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BackupMeta")
            .field("backup_info", &self.backup_info)
            .field("meta_files", &self.meta_files)
            .field("backup_name", &self.backup_name)
            .field("full", &self.full)
            .field("include_system_space", &self.include_system_space)
            .field("create_time", &self.create_time)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BackupMeta {}
unsafe impl ::std::marker::Sync for self::BackupMeta {}

impl ::fbthrift::GetTType for self::BackupMeta {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::BackupMeta
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BackupMeta");
        p.write_field_begin("backup_info", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.backup_info, p);
        p.write_field_end();
        p.write_field_begin("meta_files", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.meta_files, p);
        p.write_field_end();
        p.write_field_begin("backup_name", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.backup_name, p);
        p.write_field_end();
        p.write_field_begin("full", ::fbthrift::TType::Bool, 4);
        ::fbthrift::Serialize::write(&self.full, p);
        p.write_field_end();
        p.write_field_begin("include_system_space", ::fbthrift::TType::Bool, 5);
        ::fbthrift::Serialize::write(&self.include_system_space, p);
        p.write_field_end();
        p.write_field_begin("create_time", ::fbthrift::TType::I64, 6);
        ::fbthrift::Serialize::write(&self.create_time, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BackupMeta
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("backup_info", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("backup_name", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("create_time", ::fbthrift::TType::I64, 6),
            ::fbthrift::Field::new("full", ::fbthrift::TType::Bool, 4),
            ::fbthrift::Field::new("include_system_space", ::fbthrift::TType::Bool, 5),
            ::fbthrift::Field::new("meta_files", ::fbthrift::TType::List, 2),
        ];
        let mut field_backup_info = ::std::option::Option::None;
        let mut field_meta_files = ::std::option::Option::None;
        let mut field_backup_name = ::std::option::Option::None;
        let mut field_full = ::std::option::Option::None;
        let mut field_include_system_space = ::std::option::Option::None;
        let mut field_create_time = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_backup_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_meta_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_backup_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 4) => field_full = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 5) => field_include_system_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 6) => field_create_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            backup_info: field_backup_info.unwrap_or_default(),
            meta_files: field_meta_files.unwrap_or_default(),
            backup_name: field_backup_name.unwrap_or_default(),
            full: field_full.unwrap_or_default(),
            include_system_space: field_include_system_space.unwrap_or_default(),
            create_time: field_create_time.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateBackupReq {
    fn default() -> Self {
        Self {
            spaces: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateBackupReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateBackupReq")
            .field("spaces", &self.spaces)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateBackupReq {}
unsafe impl ::std::marker::Sync for self::CreateBackupReq {}

impl ::fbthrift::GetTType for self::CreateBackupReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateBackupReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateBackupReq");
        if let ::std::option::Option::Some(some) = &self.spaces {
            p.write_field_begin("spaces", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 1),
        ];
        let mut field_spaces = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            spaces: field_spaces,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateBackupResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            meta: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateBackupResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateBackupResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("meta", &self.meta)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateBackupResp {}
unsafe impl ::std::marker::Sync for self::CreateBackupResp {}

impl ::fbthrift::GetTType for self::CreateBackupResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateBackupResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateBackupResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("meta", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.meta, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("meta", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_meta = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_meta = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            meta: field_meta.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::HostPair {
    fn default() -> Self {
        Self {
            from_host: ::std::default::Default::default(),
            to_host: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::HostPair {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("HostPair")
            .field("from_host", &self.from_host)
            .field("to_host", &self.to_host)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::HostPair {}
unsafe impl ::std::marker::Sync for self::HostPair {}

impl ::fbthrift::GetTType for self::HostPair {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::HostPair
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("HostPair");
        p.write_field_begin("from_host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.from_host, p);
        p.write_field_end();
        p.write_field_begin("to_host", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.to_host, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::HostPair
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("from_host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("to_host", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_from_host = ::std::option::Option::None;
        let mut field_to_host = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_from_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_to_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            from_host: field_from_host.unwrap_or_default(),
            to_host: field_to_host.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RestoreMetaReq {
    fn default() -> Self {
        Self {
            files: ::std::default::Default::default(),
            hosts: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RestoreMetaReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RestoreMetaReq")
            .field("files", &self.files)
            .field("hosts", &self.hosts)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RestoreMetaReq {}
unsafe impl ::std::marker::Sync for self::RestoreMetaReq {}

impl ::fbthrift::GetTType for self::RestoreMetaReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RestoreMetaReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RestoreMetaReq");
        p.write_field_begin("files", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.files, p);
        p.write_field_end();
        p.write_field_begin("hosts", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.hosts, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RestoreMetaReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("files", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 2),
        ];
        let mut field_files = ::std::option::Option::None;
        let mut field_hosts = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            files: field_files.unwrap_or_default(),
            hosts: field_hosts.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::FTClient {
    fn default() -> Self {
        Self {
            host: ::std::default::Default::default(),
            user: ::std::option::Option::None,
            pwd: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::FTClient {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("FTClient")
            .field("host", &self.host)
            .field("user", &self.user)
            .field("pwd", &self.pwd)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::FTClient {}
unsafe impl ::std::marker::Sync for self::FTClient {}

impl ::fbthrift::GetTType for self::FTClient {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::FTClient
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("FTClient");
        p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.host, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.user {
            p.write_field_begin("user", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.pwd {
            p.write_field_begin("pwd", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::FTClient
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("pwd", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("user", ::fbthrift::TType::String, 2),
        ];
        let mut field_host = ::std::option::Option::None;
        let mut field_user = ::std::option::Option::None;
        let mut field_pwd = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            host: field_host.unwrap_or_default(),
            user: field_user,
            pwd: field_pwd,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SignInFTServiceReq {
    fn default() -> Self {
        Self {
            r#type: ::std::default::Default::default(),
            clients: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SignInFTServiceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SignInFTServiceReq")
            .field("r#type", &self.r#type)
            .field("clients", &self.clients)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SignInFTServiceReq {}
unsafe impl ::std::marker::Sync for self::SignInFTServiceReq {}

impl ::fbthrift::GetTType for self::SignInFTServiceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SignInFTServiceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SignInFTServiceReq");
        p.write_field_begin("type", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.r#type, p);
        p.write_field_end();
        p.write_field_begin("clients", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.clients, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SignInFTServiceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clients", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
        ];
        let mut field_type = ::std::option::Option::None;
        let mut field_clients = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#type: field_type.unwrap_or_default(),
            clients: field_clients.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::SignOutFTServiceReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::SignOutFTServiceReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("SignOutFTServiceReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::SignOutFTServiceReq {}
unsafe impl ::std::marker::Sync for self::SignOutFTServiceReq {}

impl ::fbthrift::GetTType for self::SignOutFTServiceReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::SignOutFTServiceReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("SignOutFTServiceReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::SignOutFTServiceReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTClientsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTClientsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTClientsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTClientsReq {}
unsafe impl ::std::marker::Sync for self::ListFTClientsReq {}

impl ::fbthrift::GetTType for self::ListFTClientsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTClientsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTClientsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTClientsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTClientsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            clients: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTClientsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTClientsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("clients", &self.clients)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTClientsResp {}
unsafe impl ::std::marker::Sync for self::ListFTClientsResp {}

impl ::fbthrift::GetTType for self::ListFTClientsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTClientsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTClientsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("clients", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.clients, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTClientsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clients", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_clients = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            clients: field_clients.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::FTIndex {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            depend_schema: ::std::default::Default::default(),
            fields: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::FTIndex {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("FTIndex")
            .field("space_id", &self.space_id)
            .field("depend_schema", &self.depend_schema)
            .field("fields", &self.fields)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::FTIndex {}
unsafe impl ::std::marker::Sync for self::FTIndex {}

impl ::fbthrift::GetTType for self::FTIndex {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::FTIndex
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("FTIndex");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("depend_schema", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.depend_schema, p);
        p.write_field_end();
        p.write_field_begin("fields", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.fields, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::FTIndex
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("depend_schema", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_depend_schema = ::std::option::Option::None;
        let mut field_fields = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_depend_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            depend_schema: field_depend_schema.unwrap_or_default(),
            fields: field_fields.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateFTIndexReq {
    fn default() -> Self {
        Self {
            fulltext_index_name: ::std::default::Default::default(),
            index: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateFTIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateFTIndexReq")
            .field("fulltext_index_name", &self.fulltext_index_name)
            .field("index", &self.index)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateFTIndexReq {}
unsafe impl ::std::marker::Sync for self::CreateFTIndexReq {}

impl ::fbthrift::GetTType for self::CreateFTIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateFTIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateFTIndexReq");
        p.write_field_begin("fulltext_index_name", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.fulltext_index_name, p);
        p.write_field_end();
        p.write_field_begin("index", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.index, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateFTIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("fulltext_index_name", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("index", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_fulltext_index_name = ::std::option::Option::None;
        let mut field_index = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_fulltext_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_index = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            fulltext_index_name: field_fulltext_index_name.unwrap_or_default(),
            index: field_index.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::DropFTIndexReq {
    fn default() -> Self {
        Self {
            space_id: ::std::default::Default::default(),
            fulltext_index_name: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::DropFTIndexReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("DropFTIndexReq")
            .field("space_id", &self.space_id)
            .field("fulltext_index_name", &self.fulltext_index_name)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::DropFTIndexReq {}
unsafe impl ::std::marker::Sync for self::DropFTIndexReq {}

impl ::fbthrift::GetTType for self::DropFTIndexReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::DropFTIndexReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("DropFTIndexReq");
        p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.space_id, p);
        p.write_field_end();
        p.write_field_begin("fulltext_index_name", ::fbthrift::TType::String, 2);
        ::fbthrift::Serialize::write(&self.fulltext_index_name, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::DropFTIndexReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("fulltext_index_name", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
        ];
        let mut field_space_id = ::std::option::Option::None;
        let mut field_fulltext_index_name = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_fulltext_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            space_id: field_space_id.unwrap_or_default(),
            fulltext_index_name: field_fulltext_index_name.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTIndexesReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTIndexesReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTIndexesReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTIndexesReq {}
unsafe impl ::std::marker::Sync for self::ListFTIndexesReq {}

impl ::fbthrift::GetTType for self::ListFTIndexesReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTIndexesReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTIndexesReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTIndexesReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListFTIndexesResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            indexes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListFTIndexesResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListFTIndexesResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("indexes", &self.indexes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListFTIndexesResp {}
unsafe impl ::std::marker::Sync for self::ListFTIndexesResp {}

impl ::fbthrift::GetTType for self::ListFTIndexesResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListFTIndexesResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListFTIndexesResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("indexes", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.indexes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListFTIndexesResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("indexes", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_indexes = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_indexes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            indexes: field_indexes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::QueryDesc {
    fn default() -> Self {
        Self {
            start_time: ::std::default::Default::default(),
            status: ::std::default::Default::default(),
            duration: ::std::default::Default::default(),
            query: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::QueryDesc {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("QueryDesc")
            .field("start_time", &self.start_time)
            .field("status", &self.status)
            .field("duration", &self.duration)
            .field("query", &self.query)
            .field("graph_addr", &self.graph_addr)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::QueryDesc {}
unsafe impl ::std::marker::Sync for self::QueryDesc {}

impl ::fbthrift::GetTType for self::QueryDesc {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::QueryDesc
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("QueryDesc");
        p.write_field_begin("start_time", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.start_time, p);
        p.write_field_end();
        p.write_field_begin("status", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.status, p);
        p.write_field_end();
        p.write_field_begin("duration", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.duration, p);
        p.write_field_end();
        p.write_field_begin("query", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.query, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::QueryDesc
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("duration", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("query", ::fbthrift::TType::String, 4),
            ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
        ];
        let mut field_start_time = ::std::option::Option::None;
        let mut field_status = ::std::option::Option::None;
        let mut field_duration = ::std::option::Option::None;
        let mut field_query = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_query = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            start_time: field_start_time.unwrap_or_default(),
            status: field_status.unwrap_or_default(),
            duration: field_duration.unwrap_or_default(),
            query: field_query.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Session {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            create_time: ::std::default::Default::default(),
            update_time: ::std::default::Default::default(),
            user_name: ::std::default::Default::default(),
            space_name: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            timezone: ::std::default::Default::default(),
            client_ip: ::std::default::Default::default(),
            configs: ::std::default::Default::default(),
            queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Session {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Session")
            .field("session_id", &self.session_id)
            .field("create_time", &self.create_time)
            .field("update_time", &self.update_time)
            .field("user_name", &self.user_name)
            .field("space_name", &self.space_name)
            .field("graph_addr", &self.graph_addr)
            .field("timezone", &self.timezone)
            .field("client_ip", &self.client_ip)
            .field("configs", &self.configs)
            .field("queries", &self.queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Session {}
unsafe impl ::std::marker::Sync for self::Session {}

impl ::fbthrift::GetTType for self::Session {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::Session
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Session");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_begin("create_time", ::fbthrift::TType::I64, 2);
        ::fbthrift::Serialize::write(&self.create_time, p);
        p.write_field_end();
        p.write_field_begin("update_time", ::fbthrift::TType::I64, 3);
        ::fbthrift::Serialize::write(&self.update_time, p);
        p.write_field_end();
        p.write_field_begin("user_name", ::fbthrift::TType::String, 4);
        ::fbthrift::Serialize::write(&self.user_name, p);
        p.write_field_end();
        p.write_field_begin("space_name", ::fbthrift::TType::String, 5);
        ::fbthrift::Serialize::write(&self.space_name, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_begin("timezone", ::fbthrift::TType::I32, 7);
        ::fbthrift::Serialize::write(&self.timezone, p);
        p.write_field_end();
        p.write_field_begin("client_ip", ::fbthrift::TType::String, 8);
        ::fbthrift::Serialize::write(&self.client_ip, p);
        p.write_field_end();
        p.write_field_begin("configs", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.configs, p);
        p.write_field_end();
        p.write_field_begin("queries", ::fbthrift::TType::Map, 10);
        ::fbthrift::Serialize::write(&self.queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Session
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("configs", ::fbthrift::TType::Map, 9),
            ::fbthrift::Field::new("create_time", ::fbthrift::TType::I64, 2),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("queries", ::fbthrift::TType::Map, 10),
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
            ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 5),
            ::fbthrift::Field::new("timezone", ::fbthrift::TType::I32, 7),
            ::fbthrift::Field::new("update_time", ::fbthrift::TType::I64, 3),
            ::fbthrift::Field::new("user_name", ::fbthrift::TType::String, 4),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let mut field_create_time = ::std::option::Option::None;
        let mut field_update_time = ::std::option::Option::None;
        let mut field_user_name = ::std::option::Option::None;
        let mut field_space_name = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let mut field_timezone = ::std::option::Option::None;
        let mut field_client_ip = ::std::option::Option::None;
        let mut field_configs = ::std::option::Option::None;
        let mut field_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 2) => field_create_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 3) => field_update_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 4) => field_user_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 5) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 7) => field_timezone = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_configs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 10) => field_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            create_time: field_create_time.unwrap_or_default(),
            update_time: field_update_time.unwrap_or_default(),
            user_name: field_user_name.unwrap_or_default(),
            space_name: field_space_name.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            timezone: field_timezone.unwrap_or_default(),
            client_ip: field_client_ip.unwrap_or_default(),
            configs: field_configs.unwrap_or_default(),
            queries: field_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSessionReq {
    fn default() -> Self {
        Self {
            user: ::std::default::Default::default(),
            graph_addr: ::std::default::Default::default(),
            client_ip: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSessionReq")
            .field("user", &self.user)
            .field("graph_addr", &self.graph_addr)
            .field("client_ip", &self.client_ip)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSessionReq {}
unsafe impl ::std::marker::Sync for self::CreateSessionReq {}

impl ::fbthrift::GetTType for self::CreateSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSessionReq");
        p.write_field_begin("user", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.user, p);
        p.write_field_end();
        p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.graph_addr, p);
        p.write_field_end();
        p.write_field_begin("client_ip", ::fbthrift::TType::String, 3);
        ::fbthrift::Serialize::write(&self.client_ip, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("user", ::fbthrift::TType::String, 1),
        ];
        let mut field_user = ::std::option::Option::None;
        let mut field_graph_addr = ::std::option::Option::None;
        let mut field_client_ip = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            user: field_user.unwrap_or_default(),
            graph_addr: field_graph_addr.unwrap_or_default(),
            client_ip: field_client_ip.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::CreateSessionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            session: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::CreateSessionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("CreateSessionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("session", &self.session)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::CreateSessionResp {}
unsafe impl ::std::marker::Sync for self::CreateSessionResp {}

impl ::fbthrift::GetTType for self::CreateSessionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::CreateSessionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("CreateSessionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.session, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_session = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            session: field_session.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateSessionsReq {
    fn default() -> Self {
        Self {
            sessions: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateSessionsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateSessionsReq")
            .field("sessions", &self.sessions)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateSessionsReq {}
unsafe impl ::std::marker::Sync for self::UpdateSessionsReq {}

impl ::fbthrift::GetTType for self::UpdateSessionsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateSessionsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateSessionsReq");
        p.write_field_begin("sessions", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.sessions, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateSessionsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 1),
        ];
        let mut field_sessions = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            sessions: field_sessions.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::UpdateSessionsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            killed_queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::UpdateSessionsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("UpdateSessionsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("killed_queries", &self.killed_queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::UpdateSessionsResp {}
unsafe impl ::std::marker::Sync for self::UpdateSessionsResp {}

impl ::fbthrift::GetTType for self::UpdateSessionsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::UpdateSessionsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("UpdateSessionsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("killed_queries", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.killed_queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::UpdateSessionsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("killed_queries", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_killed_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_killed_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            killed_queries: field_killed_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSessionsReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSessionsReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSessionsReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSessionsReq {}
unsafe impl ::std::marker::Sync for self::ListSessionsReq {}

impl ::fbthrift::GetTType for self::ListSessionsReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSessionsReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSessionsReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListSessionsResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            sessions: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListSessionsResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListSessionsResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("sessions", &self.sessions)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListSessionsResp {}
unsafe impl ::std::marker::Sync for self::ListSessionsResp {}

impl ::fbthrift::GetTType for self::ListSessionsResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListSessionsResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListSessionsResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("sessions", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.sessions, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_sessions = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            sessions: field_sessions.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSessionReq {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSessionReq")
            .field("session_id", &self.session_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSessionReq {}
unsafe impl ::std::marker::Sync for self::GetSessionReq {}

impl ::fbthrift::GetTType for self::GetSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSessionReq");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetSessionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            session: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetSessionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetSessionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("session", &self.session)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetSessionResp {}
unsafe impl ::std::marker::Sync for self::GetSessionResp {}

impl ::fbthrift::GetTType for self::GetSessionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetSessionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetSessionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.session, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetSessionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_session = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            session: field_session.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RemoveSessionReq {
    fn default() -> Self {
        Self {
            session_id: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RemoveSessionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RemoveSessionReq")
            .field("session_id", &self.session_id)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RemoveSessionReq {}
unsafe impl ::std::marker::Sync for self::RemoveSessionReq {}

impl ::fbthrift::GetTType for self::RemoveSessionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::RemoveSessionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RemoveSessionReq");
        p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
        ::fbthrift::Serialize::write(&self.session_id, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RemoveSessionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_session_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            session_id: field_session_id.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::KillQueryReq {
    fn default() -> Self {
        Self {
            kill_queries: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::KillQueryReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("KillQueryReq")
            .field("kill_queries", &self.kill_queries)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::KillQueryReq {}
unsafe impl ::std::marker::Sync for self::KillQueryReq {}

impl ::fbthrift::GetTType for self::KillQueryReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::KillQueryReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("KillQueryReq");
        p.write_field_begin("kill_queries", ::fbthrift::TType::Map, 1);
        ::fbthrift::Serialize::write(&self.kill_queries, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::KillQueryReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("kill_queries", ::fbthrift::TType::Map, 1),
        ];
        let mut field_kill_queries = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_kill_queries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            kill_queries: field_kill_queries.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ReportTaskReq {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            job_id: ::std::default::Default::default(),
            task_id: ::std::default::Default::default(),
            stats: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ReportTaskReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ReportTaskReq")
            .field("code", &self.code)
            .field("job_id", &self.job_id)
            .field("task_id", &self.task_id)
            .field("stats", &self.stats)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ReportTaskReq {}
unsafe impl ::std::marker::Sync for self::ReportTaskReq {}

impl ::fbthrift::GetTType for self::ReportTaskReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ReportTaskReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ReportTaskReq");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.job_id, p);
        p.write_field_end();
        p.write_field_begin("task_id", ::fbthrift::TType::I32, 3);
        ::fbthrift::Serialize::write(&self.task_id, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.stats {
            p.write_field_begin("stats", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ReportTaskReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("stats", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 3),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_job_id = ::std::option::Option::None;
        let mut field_task_id = ::std::option::Option::None;
        let mut field_stats = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 3) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_stats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            job_id: field_job_id.unwrap_or_default(),
            task_id: field_task_id.unwrap_or_default(),
            stats: field_stats,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            meta_servers: ::std::default::Default::default(),
            storage_servers: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("meta_servers", &self.meta_servers)
            .field("storage_servers", &self.storage_servers)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoResp {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoResp {}

impl ::fbthrift::GetTType for self::ListClusterInfoResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        p.write_field_begin("meta_servers", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.meta_servers, p);
        p.write_field_end();
        p.write_field_begin("storage_servers", ::fbthrift::TType::List, 4);
        ::fbthrift::Serialize::write(&self.storage_servers, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("meta_servers", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("storage_servers", ::fbthrift::TType::List, 4),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_meta_servers = ::std::option::Option::None;
        let mut field_storage_servers = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_meta_servers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_storage_servers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            meta_servers: field_meta_servers.unwrap_or_default(),
            storage_servers: field_storage_servers.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::ListClusterInfoReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::ListClusterInfoReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("ListClusterInfoReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::ListClusterInfoReq {}
unsafe impl ::std::marker::Sync for self::ListClusterInfoReq {}

impl ::fbthrift::GetTType for self::ListClusterInfoReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("ListClusterInfoReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::ListClusterInfoReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetMetaDirInfoResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            dir: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetMetaDirInfoResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetMetaDirInfoResp")
            .field("code", &self.code)
            .field("dir", &self.dir)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetMetaDirInfoResp {}
unsafe impl ::std::marker::Sync for self::GetMetaDirInfoResp {}

impl ::fbthrift::GetTType for self::GetMetaDirInfoResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetMetaDirInfoResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetMetaDirInfoResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("dir", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.dir, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetMetaDirInfoResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_dir = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            dir: field_dir.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::GetMetaDirInfoReq {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::GetMetaDirInfoReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("GetMetaDirInfoReq")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::GetMetaDirInfoReq {}
unsafe impl ::std::marker::Sync for self::GetMetaDirInfoReq {}

impl ::fbthrift::GetTType for self::GetMetaDirInfoReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::GetMetaDirInfoReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("GetMetaDirInfoReq");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::GetMetaDirInfoReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionResp {
    fn default() -> Self {
        Self {
            code: ::std::default::Default::default(),
            leader: ::std::default::Default::default(),
            error_msg: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionResp {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionResp")
            .field("code", &self.code)
            .field("leader", &self.leader)
            .field("error_msg", &self.error_msg)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionResp {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionResp {}

impl ::fbthrift::GetTType for self::VerifyClientVersionResp {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionResp");
        p.write_field_begin("code", ::fbthrift::TType::I32, 1);
        ::fbthrift::Serialize::write(&self.code, p);
        p.write_field_end();
        p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.leader, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.error_msg {
            p.write_field_begin("error_msg", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionResp
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("error_msg", ::fbthrift::TType::String, 3),
            ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_code = ::std::option::Option::None;
        let mut field_leader = ::std::option::Option::None;
        let mut field_error_msg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 3) => field_error_msg = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            code: field_code.unwrap_or_default(),
            leader: field_leader.unwrap_or_default(),
            error_msg: field_error_msg,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::VerifyClientVersionReq {
    fn default() -> Self {
        Self {
            version: "2.6.0".as_bytes().into(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::VerifyClientVersionReq {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("VerifyClientVersionReq")
            .field("version", &self.version)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::VerifyClientVersionReq {}
unsafe impl ::std::marker::Sync for self::VerifyClientVersionReq {}

impl ::fbthrift::GetTType for self::VerifyClientVersionReq {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl<P> ::fbthrift::Serialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("VerifyClientVersionReq");
        p.write_field_begin("version", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.version, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::VerifyClientVersionReq
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("version", ::fbthrift::TType::String, 1),
        ];
        let mut field_version = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            version: field_version.unwrap_or_else(|| "2.6.0".as_bytes().into()),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
