// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(bare_trait_objects)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types;

#[doc(hidden)]
pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod meta_service {
        #[derive(Clone, Debug)]
        pub enum CreateSpaceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSpaceError> for CreateSpaceExn {
            fn from(err: crate::errors::meta_service::CreateSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSpaceError::ApplicationException(aexn) => CreateSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSpaceError::ThriftError(err) => CreateSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSpaceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropSpaceError> for DropSpaceExn {
            fn from(err: crate::errors::meta_service::DropSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::DropSpaceError::ApplicationException(aexn) => DropSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropSpaceError::ThriftError(err) => DropSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSpaceExn {
            #[doc(hidden)]
            Success(crate::types::GetSpaceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetSpaceError> for GetSpaceExn {
            fn from(err: crate::errors::meta_service::GetSpaceError) -> Self {
                match err {
                    crate::errors::meta_service::GetSpaceError::ApplicationException(aexn) => GetSpaceExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetSpaceError::ThriftError(err) => GetSpaceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSpaceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSpacesExn {
            #[doc(hidden)]
            Success(crate::types::ListSpacesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListSpacesError> for ListSpacesExn {
            fn from(err: crate::errors::meta_service::ListSpacesError) -> Self {
                match err {
                    crate::errors::meta_service::ListSpacesError::ApplicationException(aexn) => ListSpacesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListSpacesError::ThriftError(err) => ListSpacesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSpacesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListSpacesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListSpacesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListSpacesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSpaces");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSpacesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSpacesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSpaceAsExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSpaceAsError> for CreateSpaceAsExn {
            fn from(err: crate::errors::meta_service::CreateSpaceAsError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSpaceAsError::ApplicationException(aexn) => CreateSpaceAsExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSpaceAsError::ThriftError(err) => CreateSpaceAsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSpaceAsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSpaceAsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSpaceAsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSpaceAsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSpaceAsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSpaceAs");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSpaceAsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceAsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceAsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateTagError> for CreateTagExn {
            fn from(err: crate::errors::meta_service::CreateTagError) -> Self {
                match err {
                    crate::errors::meta_service::CreateTagError::ApplicationException(aexn) => CreateTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateTagError::ThriftError(err) => CreateTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterTagError> for AlterTagExn {
            fn from(err: crate::errors::meta_service::AlterTagError) -> Self {
                match err {
                    crate::errors::meta_service::AlterTagError::ApplicationException(aexn) => AlterTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterTagError::ThriftError(err) => AlterTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropTagError> for DropTagExn {
            fn from(err: crate::errors::meta_service::DropTagError) -> Self {
                match err {
                    crate::errors::meta_service::DropTagError::ApplicationException(aexn) => DropTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropTagError::ThriftError(err) => DropTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagExn {
            #[doc(hidden)]
            Success(crate::types::GetTagResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetTagError> for GetTagExn {
            fn from(err: crate::errors::meta_service::GetTagError) -> Self {
                match err {
                    crate::errors::meta_service::GetTagError::ApplicationException(aexn) => GetTagExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetTagError::ThriftError(err) => GetTagExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetTagExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagsExn {
            #[doc(hidden)]
            Success(crate::types::ListTagsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagsError> for ListTagsExn {
            fn from(err: crate::errors::meta_service::ListTagsError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagsError::ApplicationException(aexn) => ListTagsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagsError::ThriftError(err) => ListTagsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTags");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateEdgeError> for CreateEdgeExn {
            fn from(err: crate::errors::meta_service::CreateEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::CreateEdgeError::ApplicationException(aexn) => CreateEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateEdgeError::ThriftError(err) => CreateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterEdgeError> for AlterEdgeExn {
            fn from(err: crate::errors::meta_service::AlterEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::AlterEdgeError::ApplicationException(aexn) => AlterEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterEdgeError::ThriftError(err) => AlterEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropEdgeError> for DropEdgeExn {
            fn from(err: crate::errors::meta_service::DropEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::DropEdgeError::ApplicationException(aexn) => DropEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropEdgeError::ThriftError(err) => DropEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeExn {
            #[doc(hidden)]
            Success(crate::types::GetEdgeResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetEdgeError> for GetEdgeExn {
            fn from(err: crate::errors::meta_service::GetEdgeError) -> Self {
                match err {
                    crate::errors::meta_service::GetEdgeError::ApplicationException(aexn) => GetEdgeExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetEdgeError::ThriftError(err) => GetEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ListEdgesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgesError> for ListEdgesExn {
            fn from(err: crate::errors::meta_service::ListEdgesError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgesError::ApplicationException(aexn) => ListEdgesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgesError::ThriftError(err) => ListEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListHostsExn {
            #[doc(hidden)]
            Success(crate::types::ListHostsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListHostsError> for ListHostsExn {
            fn from(err: crate::errors::meta_service::ListHostsError) -> Self {
                match err {
                    crate::errors::meta_service::ListHostsError::ApplicationException(aexn) => ListHostsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListHostsError::ThriftError(err) => ListHostsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListHostsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListHostsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListHostsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListHostsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListHosts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPartsAllocExn {
            #[doc(hidden)]
            Success(crate::types::GetPartsAllocResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetPartsAllocError> for GetPartsAllocExn {
            fn from(err: crate::errors::meta_service::GetPartsAllocError) -> Self {
                match err {
                    crate::errors::meta_service::GetPartsAllocError::ApplicationException(aexn) => GetPartsAllocExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetPartsAllocError::ThriftError(err) => GetPartsAllocExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPartsAllocExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetPartsAllocExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetPartsAllocExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetPartsAllocExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetPartsAlloc");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPartsAllocExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPartsAllocExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListPartsExn {
            #[doc(hidden)]
            Success(crate::types::ListPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListPartsError> for ListPartsExn {
            fn from(err: crate::errors::meta_service::ListPartsError) -> Self {
                match err {
                    crate::errors::meta_service::ListPartsError::ApplicationException(aexn) => ListPartsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListPartsError::ThriftError(err) => ListPartsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListPartsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListPartsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListParts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiPutExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::MultiPutError> for MultiPutExn {
            fn from(err: crate::errors::meta_service::MultiPutError) -> Self {
                match err {
                    crate::errors::meta_service::MultiPutError::ApplicationException(aexn) => MultiPutExn::ApplicationException(aexn),
                    crate::errors::meta_service::MultiPutError::ThriftError(err) => MultiPutExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiPutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MultiPutExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MultiPutExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MultiPutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MultiPut");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiPutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiPutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            #[doc(hidden)]
            Success(crate::types::GetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetError> for GetExn {
            fn from(err: crate::errors::meta_service::GetError) -> Self {
                match err {
                    crate::errors::meta_service::GetError::ApplicationException(aexn) => GetExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetError::ThriftError(err) => GetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Get");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiGetExn {
            #[doc(hidden)]
            Success(crate::types::MultiGetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::MultiGetError> for MultiGetExn {
            fn from(err: crate::errors::meta_service::MultiGetError) -> Self {
                match err {
                    crate::errors::meta_service::MultiGetError::ApplicationException(aexn) => MultiGetExn::ApplicationException(aexn),
                    crate::errors::meta_service::MultiGetError::ThriftError(err) => MultiGetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiGetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MultiGetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MultiGetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MultiGetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MultiGet");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiGetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiGetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveError> for RemoveExn {
            fn from(err: crate::errors::meta_service::RemoveError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveError::ApplicationException(aexn) => RemoveExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveError::ThriftError(err) => RemoveExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Remove");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveRangeError> for RemoveRangeExn {
            fn from(err: crate::errors::meta_service::RemoveRangeError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveRangeError::ApplicationException(aexn) => RemoveRangeExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveRangeError::ThriftError(err) => RemoveRangeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveRangeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveRangeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveRange");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanExn {
            #[doc(hidden)]
            Success(crate::types::ScanResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ScanError> for ScanExn {
            fn from(err: crate::errors::meta_service::ScanError) -> Self {
                match err {
                    crate::errors::meta_service::ScanError::ApplicationException(aexn) => ScanExn::ApplicationException(aexn),
                    crate::errors::meta_service::ScanError::ThriftError(err) => ScanExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Scan");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateTagIndexError> for CreateTagIndexExn {
            fn from(err: crate::errors::meta_service::CreateTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::CreateTagIndexError::ApplicationException(aexn) => CreateTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateTagIndexError::ThriftError(err) => CreateTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropTagIndexError> for DropTagIndexExn {
            fn from(err: crate::errors::meta_service::DropTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::DropTagIndexError::ApplicationException(aexn) => DropTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropTagIndexError::ThriftError(err) => DropTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::GetTagIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetTagIndexError> for GetTagIndexExn {
            fn from(err: crate::errors::meta_service::GetTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::GetTagIndexError::ApplicationException(aexn) => GetTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetTagIndexError::ThriftError(err) => GetTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexesExn {
            #[doc(hidden)]
            Success(crate::types::ListTagIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagIndexesError> for ListTagIndexesExn {
            fn from(err: crate::errors::meta_service::ListTagIndexesError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagIndexesError::ApplicationException(aexn) => ListTagIndexesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagIndexesError::ThriftError(err) => ListTagIndexesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagIndexesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RebuildTagIndexError> for RebuildTagIndexExn {
            fn from(err: crate::errors::meta_service::RebuildTagIndexError) -> Self {
                match err {
                    crate::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn) => RebuildTagIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::RebuildTagIndexError::ThriftError(err) => RebuildTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexStatusExn {
            #[doc(hidden)]
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListTagIndexStatusError> for ListTagIndexStatusExn {
            fn from(err: crate::errors::meta_service::ListTagIndexStatusError) -> Self {
                match err {
                    crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn) => ListTagIndexStatusExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListTagIndexStatusError::ThriftError(err) => ListTagIndexStatusExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListTagIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListTagIndexStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateEdgeIndexError> for CreateEdgeIndexExn {
            fn from(err: crate::errors::meta_service::CreateEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn) => CreateEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateEdgeIndexError::ThriftError(err) => CreateEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropEdgeIndexError> for DropEdgeIndexExn {
            fn from(err: crate::errors::meta_service::DropEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn) => DropEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropEdgeIndexError::ThriftError(err) => DropEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::GetEdgeIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetEdgeIndexError> for GetEdgeIndexExn {
            fn from(err: crate::errors::meta_service::GetEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn) => GetEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetEdgeIndexError::ThriftError(err) => GetEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexesExn {
            #[doc(hidden)]
            Success(crate::types::ListEdgeIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgeIndexesError> for ListEdgeIndexesExn {
            fn from(err: crate::errors::meta_service::ListEdgeIndexesError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn) => ListEdgeIndexesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgeIndexesError::ThriftError(err) => ListEdgeIndexesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgeIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgeIndexesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RebuildEdgeIndexError> for RebuildEdgeIndexExn {
            fn from(err: crate::errors::meta_service::RebuildEdgeIndexError) -> Self {
                match err {
                    crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn) => RebuildEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::RebuildEdgeIndexError::ThriftError(err) => RebuildEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexStatusExn {
            #[doc(hidden)]
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListEdgeIndexStatusError> for ListEdgeIndexStatusExn {
            fn from(err: crate::errors::meta_service::ListEdgeIndexStatusError) -> Self {
                match err {
                    crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn) => ListEdgeIndexStatusExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListEdgeIndexStatusError::ThriftError(err) => ListEdgeIndexStatusExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListEdgeIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListEdgeIndexStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateUserError> for CreateUserExn {
            fn from(err: crate::errors::meta_service::CreateUserError) -> Self {
                match err {
                    crate::errors::meta_service::CreateUserError::ApplicationException(aexn) => CreateUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateUserError::ThriftError(err) => CreateUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropUserError> for DropUserExn {
            fn from(err: crate::errors::meta_service::DropUserError) -> Self {
                match err {
                    crate::errors::meta_service::DropUserError::ApplicationException(aexn) => DropUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropUserError::ThriftError(err) => DropUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterUserExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AlterUserError> for AlterUserExn {
            fn from(err: crate::errors::meta_service::AlterUserError) -> Self {
                match err {
                    crate::errors::meta_service::AlterUserError::ApplicationException(aexn) => AlterUserExn::ApplicationException(aexn),
                    crate::errors::meta_service::AlterUserError::ThriftError(err) => AlterUserExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AlterUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AlterUserExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AlterUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GrantRoleExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GrantRoleError> for GrantRoleExn {
            fn from(err: crate::errors::meta_service::GrantRoleError) -> Self {
                match err {
                    crate::errors::meta_service::GrantRoleError::ApplicationException(aexn) => GrantRoleExn::ApplicationException(aexn),
                    crate::errors::meta_service::GrantRoleError::ThriftError(err) => GrantRoleExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GrantRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GrantRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GrantRoleExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GrantRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GrantRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GrantRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GrantRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RevokeRoleExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RevokeRoleError> for RevokeRoleExn {
            fn from(err: crate::errors::meta_service::RevokeRoleError) -> Self {
                match err {
                    crate::errors::meta_service::RevokeRoleError::ApplicationException(aexn) => RevokeRoleExn::ApplicationException(aexn),
                    crate::errors::meta_service::RevokeRoleError::ThriftError(err) => RevokeRoleExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RevokeRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RevokeRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RevokeRoleExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RevokeRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RevokeRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RevokeRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RevokeRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListUsersExn {
            #[doc(hidden)]
            Success(crate::types::ListUsersResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListUsersError> for ListUsersExn {
            fn from(err: crate::errors::meta_service::ListUsersError) -> Self {
                match err {
                    crate::errors::meta_service::ListUsersError::ApplicationException(aexn) => ListUsersExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListUsersError::ThriftError(err) => ListUsersExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListUsersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListUsersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListUsersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListUsersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListUsers");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListUsersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListUsersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListRolesExn {
            #[doc(hidden)]
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListRolesError> for ListRolesExn {
            fn from(err: crate::errors::meta_service::ListRolesError) -> Self {
                match err {
                    crate::errors::meta_service::ListRolesError::ApplicationException(aexn) => ListRolesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListRolesError::ThriftError(err) => ListRolesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListRolesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUserRolesExn {
            #[doc(hidden)]
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetUserRolesError> for GetUserRolesExn {
            fn from(err: crate::errors::meta_service::GetUserRolesError) -> Self {
                match err {
                    crate::errors::meta_service::GetUserRolesError::ApplicationException(aexn) => GetUserRolesExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetUserRolesError::ThriftError(err) => GetUserRolesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUserRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetUserRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetUserRolesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetUserRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetUserRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUserRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUserRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChangePasswordExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ChangePasswordError> for ChangePasswordExn {
            fn from(err: crate::errors::meta_service::ChangePasswordError) -> Self {
                match err {
                    crate::errors::meta_service::ChangePasswordError::ApplicationException(aexn) => ChangePasswordExn::ApplicationException(aexn),
                    crate::errors::meta_service::ChangePasswordError::ThriftError(err) => ChangePasswordExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChangePasswordExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChangePasswordExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChangePasswordExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChangePasswordExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChangePassword");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChangePasswordExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChangePasswordExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum HeartBeatExn {
            #[doc(hidden)]
            Success(crate::types::HBResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::HeartBeatError> for HeartBeatExn {
            fn from(err: crate::errors::meta_service::HeartBeatError) -> Self {
                match err {
                    crate::errors::meta_service::HeartBeatError::ApplicationException(aexn) => HeartBeatExn::ApplicationException(aexn),
                    crate::errors::meta_service::HeartBeatError::ThriftError(err) => HeartBeatExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for HeartBeatExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for HeartBeatExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for HeartBeatExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for HeartBeatExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("HeartBeat");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "HeartBeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "HeartBeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BalanceExn {
            #[doc(hidden)]
            Success(crate::types::BalanceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::BalanceError> for BalanceExn {
            fn from(err: crate::errors::meta_service::BalanceError) -> Self {
                match err {
                    crate::errors::meta_service::BalanceError::ApplicationException(aexn) => BalanceExn::ApplicationException(aexn),
                    crate::errors::meta_service::BalanceError::ThriftError(err) => BalanceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for BalanceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for BalanceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for BalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Balance");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LeaderBalanceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::LeaderBalanceError> for LeaderBalanceExn {
            fn from(err: crate::errors::meta_service::LeaderBalanceError) -> Self {
                match err {
                    crate::errors::meta_service::LeaderBalanceError::ApplicationException(aexn) => LeaderBalanceExn::ApplicationException(aexn),
                    crate::errors::meta_service::LeaderBalanceError::ThriftError(err) => LeaderBalanceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LeaderBalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for LeaderBalanceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for LeaderBalanceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for LeaderBalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("LeaderBalance");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LeaderBalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LeaderBalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RegConfigExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RegConfigError> for RegConfigExn {
            fn from(err: crate::errors::meta_service::RegConfigError) -> Self {
                match err {
                    crate::errors::meta_service::RegConfigError::ApplicationException(aexn) => RegConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::RegConfigError::ThriftError(err) => RegConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RegConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RegConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RegConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RegConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RegConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RegConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RegConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            #[doc(hidden)]
            Success(crate::types::GetConfigResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetConfigError> for GetConfigExn {
            fn from(err: crate::errors::meta_service::GetConfigError) -> Self {
                match err {
                    crate::errors::meta_service::GetConfigError::ApplicationException(aexn) => GetConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetConfigError::ThriftError(err) => GetConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetConfigExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::SetConfigError> for SetConfigExn {
            fn from(err: crate::errors::meta_service::SetConfigError) -> Self {
                match err {
                    crate::errors::meta_service::SetConfigError::ApplicationException(aexn) => SetConfigExn::ApplicationException(aexn),
                    crate::errors::meta_service::SetConfigError::ThriftError(err) => SetConfigExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SetConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for SetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListConfigsExn {
            #[doc(hidden)]
            Success(crate::types::ListConfigsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListConfigsError> for ListConfigsExn {
            fn from(err: crate::errors::meta_service::ListConfigsError) -> Self {
                match err {
                    crate::errors::meta_service::ListConfigsError::ApplicationException(aexn) => ListConfigsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListConfigsError::ThriftError(err) => ListConfigsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListConfigsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListConfigsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListConfigsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListConfigsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListConfigs");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListConfigsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListConfigsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSnapshotExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSnapshotError> for CreateSnapshotExn {
            fn from(err: crate::errors::meta_service::CreateSnapshotError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSnapshotError::ApplicationException(aexn) => CreateSnapshotExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSnapshotError::ThriftError(err) => CreateSnapshotExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSnapshotExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSnapshotExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropSnapshotError> for DropSnapshotExn {
            fn from(err: crate::errors::meta_service::DropSnapshotError) -> Self {
                match err {
                    crate::errors::meta_service::DropSnapshotError::ApplicationException(aexn) => DropSnapshotExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropSnapshotError::ThriftError(err) => DropSnapshotExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropSnapshotExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSnapshotsExn {
            #[doc(hidden)]
            Success(crate::types::ListSnapshotsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListSnapshotsError> for ListSnapshotsExn {
            fn from(err: crate::errors::meta_service::ListSnapshotsError) -> Self {
                match err {
                    crate::errors::meta_service::ListSnapshotsError::ApplicationException(aexn) => ListSnapshotsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListSnapshotsError::ThriftError(err) => ListSnapshotsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSnapshotsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListSnapshotsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListSnapshotsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListSnapshotsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSnapshots");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSnapshotsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSnapshotsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RunAdminJobExn {
            #[doc(hidden)]
            Success(crate::types::AdminJobResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RunAdminJobError> for RunAdminJobExn {
            fn from(err: crate::errors::meta_service::RunAdminJobError) -> Self {
                match err {
                    crate::errors::meta_service::RunAdminJobError::ApplicationException(aexn) => RunAdminJobExn::ApplicationException(aexn),
                    crate::errors::meta_service::RunAdminJobError::ThriftError(err) => RunAdminJobExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RunAdminJobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RunAdminJobExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RunAdminJobExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RunAdminJobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RunAdminJob");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RunAdminJobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RunAdminJobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddZoneExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AddZoneError> for AddZoneExn {
            fn from(err: crate::errors::meta_service::AddZoneError) -> Self {
                match err {
                    crate::errors::meta_service::AddZoneError::ApplicationException(aexn) => AddZoneExn::ApplicationException(aexn),
                    crate::errors::meta_service::AddZoneError::ThriftError(err) => AddZoneExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddZoneExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropZoneExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropZoneError> for DropZoneExn {
            fn from(err: crate::errors::meta_service::DropZoneError) -> Self {
                match err {
                    crate::errors::meta_service::DropZoneError::ApplicationException(aexn) => DropZoneExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropZoneError::ThriftError(err) => DropZoneExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropZoneExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddHostIntoZoneExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AddHostIntoZoneError> for AddHostIntoZoneExn {
            fn from(err: crate::errors::meta_service::AddHostIntoZoneError) -> Self {
                match err {
                    crate::errors::meta_service::AddHostIntoZoneError::ApplicationException(aexn) => AddHostIntoZoneExn::ApplicationException(aexn),
                    crate::errors::meta_service::AddHostIntoZoneError::ThriftError(err) => AddHostIntoZoneExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddHostIntoZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddHostIntoZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddHostIntoZoneExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddHostIntoZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddHostIntoZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddHostIntoZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddHostIntoZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddHostIntoZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddHostIntoZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropHostFromZoneExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropHostFromZoneError> for DropHostFromZoneExn {
            fn from(err: crate::errors::meta_service::DropHostFromZoneError) -> Self {
                match err {
                    crate::errors::meta_service::DropHostFromZoneError::ApplicationException(aexn) => DropHostFromZoneExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropHostFromZoneError::ThriftError(err) => DropHostFromZoneExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropHostFromZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropHostFromZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropHostFromZoneExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropHostFromZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropHostFromZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropHostFromZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropHostFromZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropHostFromZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropHostFromZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetZoneExn {
            #[doc(hidden)]
            Success(crate::types::GetZoneResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetZoneError> for GetZoneExn {
            fn from(err: crate::errors::meta_service::GetZoneError) -> Self {
                match err {
                    crate::errors::meta_service::GetZoneError::ApplicationException(aexn) => GetZoneExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetZoneError::ThriftError(err) => GetZoneExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetZoneExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListZonesExn {
            #[doc(hidden)]
            Success(crate::types::ListZonesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListZonesError> for ListZonesExn {
            fn from(err: crate::errors::meta_service::ListZonesError) -> Self {
                match err {
                    crate::errors::meta_service::ListZonesError::ApplicationException(aexn) => ListZonesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListZonesError::ThriftError(err) => ListZonesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListZonesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListZonesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListZonesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListZonesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListZonesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListZones");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListZonesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListZonesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListZonesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddGroupExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AddGroupError> for AddGroupExn {
            fn from(err: crate::errors::meta_service::AddGroupError) -> Self {
                match err {
                    crate::errors::meta_service::AddGroupError::ApplicationException(aexn) => AddGroupExn::ApplicationException(aexn),
                    crate::errors::meta_service::AddGroupError::ThriftError(err) => AddGroupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddGroupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddGroupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddGroup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropGroupExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropGroupError> for DropGroupExn {
            fn from(err: crate::errors::meta_service::DropGroupError) -> Self {
                match err {
                    crate::errors::meta_service::DropGroupError::ApplicationException(aexn) => DropGroupExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropGroupError::ThriftError(err) => DropGroupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropGroupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropGroupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropGroup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddZoneIntoGroupExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AddZoneIntoGroupError> for AddZoneIntoGroupExn {
            fn from(err: crate::errors::meta_service::AddZoneIntoGroupError) -> Self {
                match err {
                    crate::errors::meta_service::AddZoneIntoGroupError::ApplicationException(aexn) => AddZoneIntoGroupExn::ApplicationException(aexn),
                    crate::errors::meta_service::AddZoneIntoGroupError::ThriftError(err) => AddZoneIntoGroupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddZoneIntoGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddZoneIntoGroupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddZoneIntoGroupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddZoneIntoGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddZoneIntoGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddZoneIntoGroup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddZoneIntoGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddZoneIntoGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddZoneIntoGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropZoneFromGroupExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropZoneFromGroupError> for DropZoneFromGroupExn {
            fn from(err: crate::errors::meta_service::DropZoneFromGroupError) -> Self {
                match err {
                    crate::errors::meta_service::DropZoneFromGroupError::ApplicationException(aexn) => DropZoneFromGroupExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropZoneFromGroupError::ThriftError(err) => DropZoneFromGroupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropZoneFromGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropZoneFromGroupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropZoneFromGroupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropZoneFromGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropZoneFromGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropZoneFromGroup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropZoneFromGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropZoneFromGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropZoneFromGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetGroupExn {
            #[doc(hidden)]
            Success(crate::types::GetGroupResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetGroupError> for GetGroupExn {
            fn from(err: crate::errors::meta_service::GetGroupError) -> Self {
                match err {
                    crate::errors::meta_service::GetGroupError::ApplicationException(aexn) => GetGroupExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetGroupError::ThriftError(err) => GetGroupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetGroupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetGroupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetGroup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListGroupsExn {
            #[doc(hidden)]
            Success(crate::types::ListGroupsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListGroupsError> for ListGroupsExn {
            fn from(err: crate::errors::meta_service::ListGroupsError) -> Self {
                match err {
                    crate::errors::meta_service::ListGroupsError::ApplicationException(aexn) => ListGroupsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListGroupsError::ThriftError(err) => ListGroupsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListGroupsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListGroupsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListGroupsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListGroupsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListGroupsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListGroups");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListGroupsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListGroupsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListGroupsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateBackupExn {
            #[doc(hidden)]
            Success(crate::types::CreateBackupResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateBackupError> for CreateBackupExn {
            fn from(err: crate::errors::meta_service::CreateBackupError) -> Self {
                match err {
                    crate::errors::meta_service::CreateBackupError::ApplicationException(aexn) => CreateBackupExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateBackupError::ThriftError(err) => CreateBackupExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateBackupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateBackupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateBackupExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateBackupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateBackupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateBackup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateBackupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateBackupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateBackupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RestoreMetaExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RestoreMetaError> for RestoreMetaExn {
            fn from(err: crate::errors::meta_service::RestoreMetaError) -> Self {
                match err {
                    crate::errors::meta_service::RestoreMetaError::ApplicationException(aexn) => RestoreMetaExn::ApplicationException(aexn),
                    crate::errors::meta_service::RestoreMetaError::ThriftError(err) => RestoreMetaExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RestoreMetaExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RestoreMetaExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RestoreMetaExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RestoreMetaExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RestoreMetaExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RestoreMeta");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RestoreMetaExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RestoreMetaExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RestoreMetaExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddListenerExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::AddListenerError> for AddListenerExn {
            fn from(err: crate::errors::meta_service::AddListenerError) -> Self {
                match err {
                    crate::errors::meta_service::AddListenerError::ApplicationException(aexn) => AddListenerExn::ApplicationException(aexn),
                    crate::errors::meta_service::AddListenerError::ThriftError(err) => AddListenerExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddListenerExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveListenerExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveListenerError> for RemoveListenerExn {
            fn from(err: crate::errors::meta_service::RemoveListenerError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveListenerError::ApplicationException(aexn) => RemoveListenerExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveListenerError::ThriftError(err) => RemoveListenerExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveListenerExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListListenerExn {
            #[doc(hidden)]
            Success(crate::types::ListListenerResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListListenerError> for ListListenerExn {
            fn from(err: crate::errors::meta_service::ListListenerError) -> Self {
                match err {
                    crate::errors::meta_service::ListListenerError::ApplicationException(aexn) => ListListenerExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListListenerError::ThriftError(err) => ListListenerExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListListenerExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatsExn {
            #[doc(hidden)]
            Success(crate::types::GetStatsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetStatsError> for GetStatsExn {
            fn from(err: crate::errors::meta_service::GetStatsError) -> Self {
                match err {
                    crate::errors::meta_service::GetStatsError::ApplicationException(aexn) => GetStatsExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetStatsError::ThriftError(err) => GetStatsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetStatsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetStatsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetStatsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetStats");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignInFTServiceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::SignInFTServiceError> for SignInFTServiceExn {
            fn from(err: crate::errors::meta_service::SignInFTServiceError) -> Self {
                match err {
                    crate::errors::meta_service::SignInFTServiceError::ApplicationException(aexn) => SignInFTServiceExn::ApplicationException(aexn),
                    crate::errors::meta_service::SignInFTServiceError::ThriftError(err) => SignInFTServiceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SignInFTServiceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SignInFTServiceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SignInFTServiceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for SignInFTServiceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SignInFTServiceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SignInFTService");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SignInFTServiceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignInFTServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignInFTServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignOutFTServiceExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::SignOutFTServiceError> for SignOutFTServiceExn {
            fn from(err: crate::errors::meta_service::SignOutFTServiceError) -> Self {
                match err {
                    crate::errors::meta_service::SignOutFTServiceError::ApplicationException(aexn) => SignOutFTServiceExn::ApplicationException(aexn),
                    crate::errors::meta_service::SignOutFTServiceError::ThriftError(err) => SignOutFTServiceExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SignOutFTServiceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SignOutFTServiceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SignOutFTServiceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for SignOutFTServiceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SignOutFTServiceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SignOutFTService");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SignOutFTServiceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignOutFTServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignOutFTServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListFTClientsExn {
            #[doc(hidden)]
            Success(crate::types::ListFTClientsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListFTClientsError> for ListFTClientsExn {
            fn from(err: crate::errors::meta_service::ListFTClientsError) -> Self {
                match err {
                    crate::errors::meta_service::ListFTClientsError::ApplicationException(aexn) => ListFTClientsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListFTClientsError::ThriftError(err) => ListFTClientsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListFTClientsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListFTClientsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListFTClientsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListFTClientsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListFTClientsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListFTClients");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListFTClientsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListFTClientsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListFTClientsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateFTIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateFTIndexError> for CreateFTIndexExn {
            fn from(err: crate::errors::meta_service::CreateFTIndexError) -> Self {
                match err {
                    crate::errors::meta_service::CreateFTIndexError::ApplicationException(aexn) => CreateFTIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateFTIndexError::ThriftError(err) => CreateFTIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateFTIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateFTIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateFTIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateFTIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateFTIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateFTIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateFTIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateFTIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateFTIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropFTIndexExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::DropFTIndexError> for DropFTIndexExn {
            fn from(err: crate::errors::meta_service::DropFTIndexError) -> Self {
                match err {
                    crate::errors::meta_service::DropFTIndexError::ApplicationException(aexn) => DropFTIndexExn::ApplicationException(aexn),
                    crate::errors::meta_service::DropFTIndexError::ThriftError(err) => DropFTIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropFTIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropFTIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropFTIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropFTIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropFTIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropFTIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropFTIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropFTIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropFTIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListFTIndexesExn {
            #[doc(hidden)]
            Success(crate::types::ListFTIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListFTIndexesError> for ListFTIndexesExn {
            fn from(err: crate::errors::meta_service::ListFTIndexesError) -> Self {
                match err {
                    crate::errors::meta_service::ListFTIndexesError::ApplicationException(aexn) => ListFTIndexesExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListFTIndexesError::ThriftError(err) => ListFTIndexesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListFTIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListFTIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListFTIndexesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListFTIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListFTIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListFTIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListFTIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListFTIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListFTIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSessionExn {
            #[doc(hidden)]
            Success(crate::types::CreateSessionResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::CreateSessionError> for CreateSessionExn {
            fn from(err: crate::errors::meta_service::CreateSessionError) -> Self {
                match err {
                    crate::errors::meta_service::CreateSessionError::ApplicationException(aexn) => CreateSessionExn::ApplicationException(aexn),
                    crate::errors::meta_service::CreateSessionError::ThriftError(err) => CreateSessionExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateSessionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateSessionsExn {
            #[doc(hidden)]
            Success(crate::types::UpdateSessionsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::UpdateSessionsError> for UpdateSessionsExn {
            fn from(err: crate::errors::meta_service::UpdateSessionsError) -> Self {
                match err {
                    crate::errors::meta_service::UpdateSessionsError::ApplicationException(aexn) => UpdateSessionsExn::ApplicationException(aexn),
                    crate::errors::meta_service::UpdateSessionsError::ThriftError(err) => UpdateSessionsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateSessionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UpdateSessionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UpdateSessionsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for UpdateSessionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateSessionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateSessions");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateSessionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSessionsExn {
            #[doc(hidden)]
            Success(crate::types::ListSessionsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListSessionsError> for ListSessionsExn {
            fn from(err: crate::errors::meta_service::ListSessionsError) -> Self {
                match err {
                    crate::errors::meta_service::ListSessionsError::ApplicationException(aexn) => ListSessionsExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListSessionsError::ThriftError(err) => ListSessionsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSessionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListSessionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListSessionsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListSessionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSessionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSessions");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSessionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSessionExn {
            #[doc(hidden)]
            Success(crate::types::GetSessionResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetSessionError> for GetSessionExn {
            fn from(err: crate::errors::meta_service::GetSessionError) -> Self {
                match err {
                    crate::errors::meta_service::GetSessionError::ApplicationException(aexn) => GetSessionExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetSessionError::ThriftError(err) => GetSessionExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSessionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveSessionExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::RemoveSessionError> for RemoveSessionExn {
            fn from(err: crate::errors::meta_service::RemoveSessionError) -> Self {
                match err {
                    crate::errors::meta_service::RemoveSessionError::ApplicationException(aexn) => RemoveSessionExn::ApplicationException(aexn),
                    crate::errors::meta_service::RemoveSessionError::ThriftError(err) => RemoveSessionExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveSessionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum KillQueryExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::KillQueryError> for KillQueryExn {
            fn from(err: crate::errors::meta_service::KillQueryError) -> Self {
                match err {
                    crate::errors::meta_service::KillQueryError::ApplicationException(aexn) => KillQueryExn::ApplicationException(aexn),
                    crate::errors::meta_service::KillQueryError::ThriftError(err) => KillQueryExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for KillQueryExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for KillQueryExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for KillQueryExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for KillQueryExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for KillQueryExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("KillQuery");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for KillQueryExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "KillQueryExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "KillQueryExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReportTaskFinishExn {
            #[doc(hidden)]
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ReportTaskFinishError> for ReportTaskFinishExn {
            fn from(err: crate::errors::meta_service::ReportTaskFinishError) -> Self {
                match err {
                    crate::errors::meta_service::ReportTaskFinishError::ApplicationException(aexn) => ReportTaskFinishExn::ApplicationException(aexn),
                    crate::errors::meta_service::ReportTaskFinishError::ThriftError(err) => ReportTaskFinishExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReportTaskFinishExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ReportTaskFinishExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ReportTaskFinishExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ReportTaskFinishExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ReportTaskFinishExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ReportTaskFinish");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ReportTaskFinishExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReportTaskFinishExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ReportTaskFinishExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListClusterExn {
            #[doc(hidden)]
            Success(crate::types::ListClusterInfoResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::ListClusterError> for ListClusterExn {
            fn from(err: crate::errors::meta_service::ListClusterError) -> Self {
                match err {
                    crate::errors::meta_service::ListClusterError::ApplicationException(aexn) => ListClusterExn::ApplicationException(aexn),
                    crate::errors::meta_service::ListClusterError::ThriftError(err) => ListClusterExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListClusterExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListClusterExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListClusterExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListClusterExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListClusterExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListCluster");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListClusterExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListClusterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListClusterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetMetaDirInfoExn {
            #[doc(hidden)]
            Success(crate::types::GetMetaDirInfoResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::GetMetaDirInfoError> for GetMetaDirInfoExn {
            fn from(err: crate::errors::meta_service::GetMetaDirInfoError) -> Self {
                match err {
                    crate::errors::meta_service::GetMetaDirInfoError::ApplicationException(aexn) => GetMetaDirInfoExn::ApplicationException(aexn),
                    crate::errors::meta_service::GetMetaDirInfoError::ThriftError(err) => GetMetaDirInfoExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetMetaDirInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetMetaDirInfoExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetMetaDirInfoExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetMetaDirInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetMetaDirInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetMetaDirInfo");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetMetaDirInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetMetaDirInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetMetaDirInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum VerifyClientVersionExn {
            #[doc(hidden)]
            Success(crate::types::VerifyClientVersionResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::meta_service::VerifyClientVersionError> for VerifyClientVersionExn {
            fn from(err: crate::errors::meta_service::VerifyClientVersionError) -> Self {
                match err {
                    crate::errors::meta_service::VerifyClientVersionError::ApplicationException(aexn) => VerifyClientVersionExn::ApplicationException(aexn),
                    crate::errors::meta_service::VerifyClientVersionError::ThriftError(err) => VerifyClientVersionExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for VerifyClientVersionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for VerifyClientVersionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for VerifyClientVersionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for VerifyClientVersionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for VerifyClientVersionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("VerifyClientVersion");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for VerifyClientVersionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "VerifyClientVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "VerifyClientVersionExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `meta`.
pub mod client {

    pub struct MetaServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _createSpace_impl(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let args = self::Args_MetaService_createSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSpace"))
            .boxed()
        }

        fn _dropSpace_impl(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let args = self::Args_MetaService_dropSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSpace"))
            .boxed()
        }

        fn _getSpace_impl(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let args = self::Args_MetaService_getSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetSpaceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSpace"))
            .boxed()
        }

        fn _listSpaces_impl(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let args = self::Args_MetaService_listSpaces {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listSpaces", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSpaces"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListSpacesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSpaces"))
            .boxed()
        }

        fn _createSpaceAs_impl(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpaceAs";
            }
            let args = self::Args_MetaService_createSpaceAs {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSpaceAs", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSpaceAs"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSpaceAsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceAsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSpaceAs"))
            .boxed()
        }

        fn _createTag_impl(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let args = self::Args_MetaService_createTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTag"))
            .boxed()
        }

        fn _alterTag_impl(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let args = self::Args_MetaService_alterTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterTag"))
            .boxed()
        }

        fn _dropTag_impl(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let args = self::Args_MetaService_dropTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTag"))
            .boxed()
        }

        fn _getTag_impl(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let args = self::Args_MetaService_getTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetTagExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTag"))
            .boxed()
        }

        fn _listTags_impl(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let args = self::Args_MetaService_listTags {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTags", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTags"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTags"))
            .boxed()
        }

        fn _createEdge_impl(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let args = self::Args_MetaService_createEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdge"))
            .boxed()
        }

        fn _alterEdge_impl(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let args = self::Args_MetaService_alterEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterEdge"))
            .boxed()
        }

        fn _dropEdge_impl(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let args = self::Args_MetaService_dropEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdge"))
            .boxed()
        }

        fn _getEdge_impl(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let args = self::Args_MetaService_getEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdge"))
            .boxed()
        }

        fn _listEdges_impl(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let args = self::Args_MetaService_listEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdges"))
            .boxed()
        }

        fn _listHosts_impl(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let args = self::Args_MetaService_listHosts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listHosts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listHosts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListHostsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listHosts"))
            .boxed()
        }

        fn _getPartsAlloc_impl(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let args = self::Args_MetaService_getPartsAlloc {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getPartsAlloc", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getPartsAlloc"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetPartsAllocExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getPartsAlloc"))
            .boxed()
        }

        fn _listParts_impl(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let args = self::Args_MetaService_listParts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listParts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listParts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListPartsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listParts"))
            .boxed()
        }

        fn _multiPut_impl(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let args = self::Args_MetaService_multiPut {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("multiPut", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.multiPut"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::MultiPutExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.multiPut"))
            .boxed()
        }

        fn _get_impl(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let args = self::Args_MetaService_get {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("get", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.get"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.get"))
            .boxed()
        }

        fn _multiGet_impl(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let args = self::Args_MetaService_multiGet {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("multiGet", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.multiGet"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::MultiGetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.multiGet"))
            .boxed()
        }

        fn _remove_impl(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let args = self::Args_MetaService_remove {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("remove", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.remove"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.remove"))
            .boxed()
        }

        fn _removeRange_impl(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let args = self::Args_MetaService_removeRange {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeRange", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeRange"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveRangeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeRange"))
            .boxed()
        }

        fn _scan_impl(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let args = self::Args_MetaService_scan {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scan", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.scan"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ScanExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.scan"))
            .boxed()
        }

        fn _createTagIndex_impl(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let args = self::Args_MetaService_createTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTagIndex"))
            .boxed()
        }

        fn _dropTagIndex_impl(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let args = self::Args_MetaService_dropTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTagIndex"))
            .boxed()
        }

        fn _getTagIndex_impl(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let args = self::Args_MetaService_getTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTagIndex"))
            .boxed()
        }

        fn _listTagIndexes_impl(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let args = self::Args_MetaService_listTagIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagIndexesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexes"))
            .boxed()
        }

        fn _rebuildTagIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let args = self::Args_MetaService_rebuildTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RebuildTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildTagIndex"))
            .boxed()
        }

        fn _listTagIndexStatus_impl(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let args = self::Args_MetaService_listTagIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListTagIndexStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexStatus"))
            .boxed()
        }

        fn _createEdgeIndex_impl(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let args = self::Args_MetaService_createEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdgeIndex"))
            .boxed()
        }

        fn _dropEdgeIndex_impl(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let args = self::Args_MetaService_dropEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdgeIndex"))
            .boxed()
        }

        fn _getEdgeIndex_impl(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let args = self::Args_MetaService_getEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexes_impl(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let args = self::Args_MetaService_listEdgeIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgeIndexesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexes"))
            .boxed()
        }

        fn _rebuildEdgeIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let args = self::Args_MetaService_rebuildEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RebuildEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexStatus_impl(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let args = self::Args_MetaService_listEdgeIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListEdgeIndexStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexStatus"))
            .boxed()
        }

        fn _createUser_impl(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let args = self::Args_MetaService_createUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createUser"))
            .boxed()
        }

        fn _dropUser_impl(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let args = self::Args_MetaService_dropUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropUser"))
            .boxed()
        }

        fn _alterUser_impl(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let args = self::Args_MetaService_alterUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("alterUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AlterUserExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterUser"))
            .boxed()
        }

        fn _grantRole_impl(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let args = self::Args_MetaService_grantRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("grantRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.grantRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GrantRoleExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.grantRole"))
            .boxed()
        }

        fn _revokeRole_impl(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let args = self::Args_MetaService_revokeRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("revokeRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.revokeRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RevokeRoleExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.revokeRole"))
            .boxed()
        }

        fn _listUsers_impl(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let args = self::Args_MetaService_listUsers {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listUsers", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listUsers"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListUsersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listUsers"))
            .boxed()
        }

        fn _listRoles_impl(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let args = self::Args_MetaService_listRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListRolesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listRoles"))
            .boxed()
        }

        fn _getUserRoles_impl(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let args = self::Args_MetaService_getUserRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getUserRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getUserRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetUserRolesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getUserRoles"))
            .boxed()
        }

        fn _changePassword_impl(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let args = self::Args_MetaService_changePassword {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("changePassword", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.changePassword"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ChangePasswordExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.changePassword"))
            .boxed()
        }

        fn _heartBeat_impl(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let args = self::Args_MetaService_heartBeat {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("heartBeat", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.heartBeat"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::HeartBeatExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.heartBeat"))
            .boxed()
        }

        fn _balance_impl(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let args = self::Args_MetaService_balance {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("balance", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.balance"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::BalanceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.balance"))
            .boxed()
        }

        fn _leaderBalance_impl(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let args = self::Args_MetaService_leaderBalance {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("leaderBalance", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.leaderBalance"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::LeaderBalanceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.leaderBalance"))
            .boxed()
        }

        fn _regConfig_impl(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let args = self::Args_MetaService_regConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("regConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.regConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RegConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.regConfig"))
            .boxed()
        }

        fn _getConfig_impl(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let args = self::Args_MetaService_getConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getConfig"))
            .boxed()
        }

        fn _setConfig_impl(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let args = self::Args_MetaService_setConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("setConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.setConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::SetConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.setConfig"))
            .boxed()
        }

        fn _listConfigs_impl(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let args = self::Args_MetaService_listConfigs {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listConfigs", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listConfigs"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListConfigsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listConfigs"))
            .boxed()
        }

        fn _createSnapshot_impl(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let args = self::Args_MetaService_createSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSnapshotExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSnapshot"))
            .boxed()
        }

        fn _dropSnapshot_impl(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let args = self::Args_MetaService_dropSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropSnapshotExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSnapshot"))
            .boxed()
        }

        fn _listSnapshots_impl(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let args = self::Args_MetaService_listSnapshots {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listSnapshots", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSnapshots"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListSnapshotsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSnapshots"))
            .boxed()
        }

        fn _runAdminJob_impl(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let args = self::Args_MetaService_runAdminJob {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("runAdminJob", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.runAdminJob"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RunAdminJobExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.runAdminJob"))
            .boxed()
        }

        fn _addZone_impl(
            &self,
            arg_req: &crate::types::AddZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZone";
            }
            let args = self::Args_MetaService_addZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AddZoneExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AddZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addZone"))
            .boxed()
        }

        fn _dropZone_impl(
            &self,
            arg_req: &crate::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZone";
            }
            let args = self::Args_MetaService_dropZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropZoneExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropZone"))
            .boxed()
        }

        fn _addHostIntoZone_impl(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHostIntoZone";
            }
            let args = self::Args_MetaService_addHostIntoZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addHostIntoZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addHostIntoZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AddHostIntoZoneExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AddHostIntoZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addHostIntoZone"))
            .boxed()
        }

        fn _dropHostFromZone_impl(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropHostFromZone";
            }
            let args = self::Args_MetaService_dropHostFromZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropHostFromZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropHostFromZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropHostFromZoneExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropHostFromZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropHostFromZone"))
            .boxed()
        }

        fn _getZone_impl(
            &self,
            arg_req: &crate::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getZone";
            }
            let args = self::Args_MetaService_getZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetZoneExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getZone"))
            .boxed()
        }

        fn _listZones_impl(
            &self,
            arg_req: &crate::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listZones";
            }
            let args = self::Args_MetaService_listZones {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listZones", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listZones"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListZonesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListZonesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listZones"))
            .boxed()
        }

        fn _addGroup_impl(
            &self,
            arg_req: &crate::types::AddGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addGroup";
            }
            let args = self::Args_MetaService_addGroup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addGroup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addGroup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AddGroupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AddGroupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addGroup"))
            .boxed()
        }

        fn _dropGroup_impl(
            &self,
            arg_req: &crate::types::DropGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropGroup";
            }
            let args = self::Args_MetaService_dropGroup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropGroup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropGroup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropGroupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropGroupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropGroup"))
            .boxed()
        }

        fn _addZoneIntoGroup_impl(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZoneIntoGroup";
            }
            let args = self::Args_MetaService_addZoneIntoGroup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addZoneIntoGroup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addZoneIntoGroup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AddZoneIntoGroupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AddZoneIntoGroupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addZoneIntoGroup"))
            .boxed()
        }

        fn _dropZoneFromGroup_impl(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZoneFromGroup";
            }
            let args = self::Args_MetaService_dropZoneFromGroup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropZoneFromGroup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropZoneFromGroup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropZoneFromGroupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropZoneFromGroupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropZoneFromGroup"))
            .boxed()
        }

        fn _getGroup_impl(
            &self,
            arg_req: &crate::types::GetGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getGroup";
            }
            let args = self::Args_MetaService_getGroup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getGroup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getGroup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetGroupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetGroupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getGroup"))
            .boxed()
        }

        fn _listGroups_impl(
            &self,
            arg_req: &crate::types::ListGroupsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listGroups";
            }
            let args = self::Args_MetaService_listGroups {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listGroups", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listGroups"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListGroupsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListGroupsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listGroups"))
            .boxed()
        }

        fn _createBackup_impl(
            &self,
            arg_req: &crate::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createBackup";
            }
            let args = self::Args_MetaService_createBackup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createBackup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createBackup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateBackupExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateBackupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createBackup"))
            .boxed()
        }

        fn _restoreMeta_impl(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.restoreMeta";
            }
            let args = self::Args_MetaService_restoreMeta {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("restoreMeta", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.restoreMeta"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RestoreMetaExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RestoreMetaError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.restoreMeta"))
            .boxed()
        }

        fn _addListener_impl(
            &self,
            arg_req: &crate::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addListener";
            }
            let args = self::Args_MetaService_addListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::AddListenerExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::AddListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addListener"))
            .boxed()
        }

        fn _removeListener_impl(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeListener";
            }
            let args = self::Args_MetaService_removeListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveListenerExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeListener"))
            .boxed()
        }

        fn _listListener_impl(
            &self,
            arg_req: &crate::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listListener";
            }
            let args = self::Args_MetaService_listListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListListenerExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listListener"))
            .boxed()
        }

        fn _getStats_impl(
            &self,
            arg_req: &crate::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getStats";
            }
            let args = self::Args_MetaService_getStats {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getStats", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getStats"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetStatsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetStatsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getStats"))
            .boxed()
        }

        fn _signInFTService_impl(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signInFTService";
            }
            let args = self::Args_MetaService_signInFTService {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("signInFTService", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.signInFTService"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::SignInFTServiceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::SignInFTServiceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.signInFTService"))
            .boxed()
        }

        fn _signOutFTService_impl(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signOutFTService";
            }
            let args = self::Args_MetaService_signOutFTService {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("signOutFTService", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.signOutFTService"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::SignOutFTServiceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::SignOutFTServiceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.signOutFTService"))
            .boxed()
        }

        fn _listFTClients_impl(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTClients";
            }
            let args = self::Args_MetaService_listFTClients {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listFTClients", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listFTClients"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListFTClientsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListFTClientsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listFTClients"))
            .boxed()
        }

        fn _createFTIndex_impl(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createFTIndex";
            }
            let args = self::Args_MetaService_createFTIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createFTIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createFTIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateFTIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateFTIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createFTIndex"))
            .boxed()
        }

        fn _dropFTIndex_impl(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropFTIndex";
            }
            let args = self::Args_MetaService_dropFTIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropFTIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropFTIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::DropFTIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::DropFTIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropFTIndex"))
            .boxed()
        }

        fn _listFTIndexes_impl(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTIndexes";
            }
            let args = self::Args_MetaService_listFTIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listFTIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listFTIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListFTIndexesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListFTIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listFTIndexes"))
            .boxed()
        }

        fn _createSession_impl(
            &self,
            arg_req: &crate::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSession";
            }
            let args = self::Args_MetaService_createSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::CreateSessionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::CreateSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSession"))
            .boxed()
        }

        fn _updateSessions_impl(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.updateSessions";
            }
            let args = self::Args_MetaService_updateSessions {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("updateSessions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.updateSessions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::UpdateSessionsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::UpdateSessionsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.updateSessions"))
            .boxed()
        }

        fn _listSessions_impl(
            &self,
            arg_req: &crate::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSessions";
            }
            let args = self::Args_MetaService_listSessions {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listSessions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSessions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListSessionsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListSessionsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSessions"))
            .boxed()
        }

        fn _getSession_impl(
            &self,
            arg_req: &crate::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSession";
            }
            let args = self::Args_MetaService_getSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetSessionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSession"))
            .boxed()
        }

        fn _removeSession_impl(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeSession";
            }
            let args = self::Args_MetaService_removeSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::RemoveSessionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::RemoveSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeSession"))
            .boxed()
        }

        fn _killQuery_impl(
            &self,
            arg_req: &crate::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.killQuery";
            }
            let args = self::Args_MetaService_killQuery {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("killQuery", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.killQuery"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::KillQueryExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::KillQueryError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.killQuery"))
            .boxed()
        }

        fn _reportTaskFinish_impl(
            &self,
            arg_req: &crate::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.reportTaskFinish";
            }
            let args = self::Args_MetaService_reportTaskFinish {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("reportTaskFinish", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.reportTaskFinish"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ReportTaskFinishExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ReportTaskFinishError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.reportTaskFinish"))
            .boxed()
        }

        fn _listCluster_impl(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listCluster";
            }
            let args = self::Args_MetaService_listCluster {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listCluster", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listCluster"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::ListClusterExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::ListClusterError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listCluster"))
            .boxed()
        }

        fn _getMetaDirInfo_impl(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getMetaDirInfo";
            }
            let args = self::Args_MetaService_getMetaDirInfo {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getMetaDirInfo", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getMetaDirInfo"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::GetMetaDirInfoExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::GetMetaDirInfoError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getMetaDirInfo"))
            .boxed()
        }

        fn _verifyClientVersion_impl(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.verifyClientVersion";
            }
            let args = self::Args_MetaService_verifyClientVersion {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("verifyClientVersion", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.verifyClientVersion"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::meta_service::VerifyClientVersionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::meta_service::VerifyClientVersionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.verifyClientVersion"))
            .boxed()
        }
    }

    pub trait MetaService: ::std::marker::Send {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>>;

        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>>;

        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>>;

        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>>;

        fn createSpaceAs(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>>;

        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>>;

        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>>;

        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>>;

        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>>;

        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>>;

        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>>;

        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>>;

        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>>;

        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>>;

        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>>;

        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>>;

        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>>;

        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>>;

        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>>;

        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>>;

        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>>;

        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>>;

        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>>;

        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>>;

        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>>;

        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>>;

        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>>;

        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>>;

        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>>;

        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>>;

        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>>;

        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>>;

        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>>;

        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>>;

        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>>;

        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>>;

        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>>;

        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>>;

        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>>;

        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>>;

        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>>;

        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>>;

        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>>;

        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>>;

        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>>;

        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>>;

        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>>;

        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>>;

        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>>;

        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>>;

        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>>;

        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>>;

        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>>;

        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>>;

        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>>;

        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>>;

        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>>;

        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>>;

        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>>;

        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>>;

        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>>;

        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>>;

        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>>;

        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>>;

        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>>;

        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>>;

        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>>;

        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>>;

        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>>;

        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>>;

        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>>;

        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>>;

        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>>;

        fn getStats(
            &self,
            arg_req: &crate::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>>;

        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>>;

        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>>;

        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>>;

        fn createFTIndex(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>>;

        fn dropFTIndex(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>>;

        fn listFTIndexes(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>>;

        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>>;

        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>>;

        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>>;

        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>>;

        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>>;

        fn killQuery(
            &self,
            arg_req: &crate::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>>;

        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>>;

        fn listCluster(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>>;

        fn getMetaDirInfo(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>>;

        fn verifyClientVersion(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>>;
    }

    pub trait MetaServiceExt<T>: MetaService
    where
        T: ::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>>;
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>>;
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>>;
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>>;
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>>;
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>>;
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>>;
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>>;
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>>;
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>>;
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>>;
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>>;
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>>;
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>>;
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>>;
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>>;
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>>;
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>>;
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>>;
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>>;
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>>;
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>>;
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>>;
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>>;
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>>;
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>>;
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>>;
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>>;
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>>;
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>>;
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>>;
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>>;
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>>;
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>>;
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>>;
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>>;
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>>;
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>>;
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>>;
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>>;
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>>;
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>>;
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>>;
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>>;
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>>;
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>>;
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>>;
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>>;
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>>;
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>>;
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>>;
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>>;
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>>;
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>>;
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>>;
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>>;
        fn addZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>>;
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>>;
        fn addHostIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>>;
        fn dropHostFromZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>>;
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>>;
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>>;
        fn addGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>>;
        fn dropGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>>;
        fn addZoneIntoGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>>;
        fn dropZoneFromGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>>;
        fn getGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>>;
        fn listGroups_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListGroupsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>>;
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>>;
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>>;
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>>;
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>>;
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>>;
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>>;
        fn signInFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>>;
        fn signOutFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>>;
        fn listFTClients_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>>;
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>>;
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>>;
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>>;
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>>;
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>>;
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>>;
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>>;
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>>;
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>>;
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>>;
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>>;
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>>;
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>>;
    }

    struct Args_MetaService_createSpace<'a> {
        req: &'a crate::types::CreateSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSpace<'a> {
        req: &'a crate::types::DropSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSpace<'a> {
        req: &'a crate::types::GetSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSpaces<'a> {
        req: &'a crate::types::ListSpacesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listSpaces<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSpaces"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSpaceAs<'a> {
        req: &'a crate::types::CreateSpaceAsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSpaceAs<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSpaceAs"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTag<'a> {
        req: &'a crate::types::CreateTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterTag<'a> {
        req: &'a crate::types::AlterTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTag<'a> {
        req: &'a crate::types::DropTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTag<'a> {
        req: &'a crate::types::GetTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTags<'a> {
        req: &'a crate::types::ListTagsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTags<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTags"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdge<'a> {
        req: &'a crate::types::CreateEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterEdge<'a> {
        req: &'a crate::types::AlterEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdge<'a> {
        req: &'a crate::types::DropEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdge<'a> {
        req: &'a crate::types::GetEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdges<'a> {
        req: &'a crate::types::ListEdgesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listHosts<'a> {
        req: &'a crate::types::ListHostsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listHosts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listHosts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getPartsAlloc<'a> {
        req: &'a crate::types::GetPartsAllocReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getPartsAlloc<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listParts<'a> {
        req: &'a crate::types::ListPartsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listParts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listParts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_multiPut<'a> {
        req: &'a crate::types::MultiPutReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_multiPut<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.multiPut"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_get<'a> {
        req: &'a crate::types::GetReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_get<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.get"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_multiGet<'a> {
        req: &'a crate::types::MultiGetReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_multiGet<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.multiGet"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_remove<'a> {
        req: &'a crate::types::RemoveReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_remove<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.remove"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeRange<'a> {
        req: &'a crate::types::RemoveRangeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_removeRange<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeRange"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_scan<'a> {
        req: &'a crate::types::ScanReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_scan<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.scan"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTagIndex<'a> {
        req: &'a crate::types::CreateTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTagIndex<'a> {
        req: &'a crate::types::DropTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTagIndex<'a> {
        req: &'a crate::types::GetTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexes<'a> {
        req: &'a crate::types::ListTagIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildTagIndex<'a> {
        req: &'a crate::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_rebuildTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexStatus<'a> {
        req: &'a crate::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdgeIndex<'a> {
        req: &'a crate::types::CreateEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdgeIndex<'a> {
        req: &'a crate::types::DropEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdgeIndex<'a> {
        req: &'a crate::types::GetEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexes<'a> {
        req: &'a crate::types::ListEdgeIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildEdgeIndex<'a> {
        req: &'a crate::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_rebuildEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexStatus<'a> {
        req: &'a crate::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createUser<'a> {
        req: &'a crate::types::CreateUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropUser<'a> {
        req: &'a crate::types::DropUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterUser<'a> {
        req: &'a crate::types::AlterUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_alterUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_grantRole<'a> {
        req: &'a crate::types::GrantRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_grantRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.grantRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_revokeRole<'a> {
        req: &'a crate::types::RevokeRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_revokeRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.revokeRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listUsers<'a> {
        req: &'a crate::types::ListUsersReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listUsers<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listUsers"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listRoles<'a> {
        req: &'a crate::types::ListRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getUserRoles<'a> {
        req: &'a crate::types::GetUserRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getUserRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getUserRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_changePassword<'a> {
        req: &'a crate::types::ChangePasswordReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_changePassword<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.changePassword"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_heartBeat<'a> {
        req: &'a crate::types::HBReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_heartBeat<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.heartBeat"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_balance<'a> {
        req: &'a crate::types::BalanceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_balance<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.balance"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_leaderBalance<'a> {
        req: &'a crate::types::LeaderBalanceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_leaderBalance<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.leaderBalance"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_regConfig<'a> {
        req: &'a crate::types::RegConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_regConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.regConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getConfig<'a> {
        req: &'a crate::types::GetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_setConfig<'a> {
        req: &'a crate::types::SetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_setConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.setConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listConfigs<'a> {
        req: &'a crate::types::ListConfigsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listConfigs<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listConfigs"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSnapshot<'a> {
        req: &'a crate::types::CreateSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSnapshot<'a> {
        req: &'a crate::types::DropSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSnapshots<'a> {
        req: &'a crate::types::ListSnapshotsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listSnapshots<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSnapshots"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_runAdminJob<'a> {
        req: &'a crate::types::AdminJobReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_runAdminJob<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.runAdminJob"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addZone<'a> {
        req: &'a crate::types::AddZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_addZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropZone<'a> {
        req: &'a crate::types::DropZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addHostIntoZone<'a> {
        req: &'a crate::types::AddHostIntoZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_addHostIntoZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addHostIntoZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropHostFromZone<'a> {
        req: &'a crate::types::DropHostFromZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropHostFromZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropHostFromZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getZone<'a> {
        req: &'a crate::types::GetZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listZones<'a> {
        req: &'a crate::types::ListZonesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listZones<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listZones"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addGroup<'a> {
        req: &'a crate::types::AddGroupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_addGroup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addGroup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropGroup<'a> {
        req: &'a crate::types::DropGroupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropGroup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropGroup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addZoneIntoGroup<'a> {
        req: &'a crate::types::AddZoneIntoGroupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_addZoneIntoGroup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addZoneIntoGroup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropZoneFromGroup<'a> {
        req: &'a crate::types::DropZoneFromGroupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropZoneFromGroup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropZoneFromGroup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getGroup<'a> {
        req: &'a crate::types::GetGroupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getGroup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getGroup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listGroups<'a> {
        req: &'a crate::types::ListGroupsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listGroups<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listGroups"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createBackup<'a> {
        req: &'a crate::types::CreateBackupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createBackup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createBackup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_restoreMeta<'a> {
        req: &'a crate::types::RestoreMetaReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_restoreMeta<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.restoreMeta"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addListener<'a> {
        req: &'a crate::types::AddListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_addListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeListener<'a> {
        req: &'a crate::types::RemoveListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_removeListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listListener<'a> {
        req: &'a crate::types::ListListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getStats<'a> {
        req: &'a crate::types::GetStatsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getStats<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getStats"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_signInFTService<'a> {
        req: &'a crate::types::SignInFTServiceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_signInFTService<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.signInFTService"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_signOutFTService<'a> {
        req: &'a crate::types::SignOutFTServiceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_signOutFTService<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.signOutFTService"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listFTClients<'a> {
        req: &'a crate::types::ListFTClientsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listFTClients<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listFTClients"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createFTIndex<'a> {
        req: &'a crate::types::CreateFTIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createFTIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createFTIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropFTIndex<'a> {
        req: &'a crate::types::DropFTIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_dropFTIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropFTIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listFTIndexes<'a> {
        req: &'a crate::types::ListFTIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listFTIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listFTIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSession<'a> {
        req: &'a crate::types::CreateSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_createSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_updateSessions<'a> {
        req: &'a crate::types::UpdateSessionsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_updateSessions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.updateSessions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSessions<'a> {
        req: &'a crate::types::ListSessionsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listSessions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSessions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSession<'a> {
        req: &'a crate::types::GetSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeSession<'a> {
        req: &'a crate::types::RemoveSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_removeSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_killQuery<'a> {
        req: &'a crate::types::KillQueryReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_killQuery<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.killQuery"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_reportTaskFinish<'a> {
        req: &'a crate::types::ReportTaskReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_reportTaskFinish<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.reportTaskFinish"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listCluster<'a> {
        req: &'a crate::types::ListClusterInfoReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_listCluster<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listCluster"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getMetaDirInfo<'a> {
        req: &'a crate::types::GetMetaDirInfoReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_getMetaDirInfo<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getMetaDirInfo"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_verifyClientVersion<'a> {
        req: &'a crate::types::VerifyClientVersionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_MetaService_verifyClientVersion<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.verifyClientVersion"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> MetaService for MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSpaceAs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            let rpc_options = T::RpcOptions::default();
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            let rpc_options = T::RpcOptions::default();
            self._multiPut_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            let rpc_options = T::RpcOptions::default();
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            let rpc_options = T::RpcOptions::default();
            self._multiGet_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            let rpc_options = T::RpcOptions::default();
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            let rpc_options = T::RpcOptions::default();
            self._scan_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            let rpc_options = T::RpcOptions::default();
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            let rpc_options = T::RpcOptions::default();
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            let rpc_options = T::RpcOptions::default();
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            let rpc_options = T::RpcOptions::default();
            self._balance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            let rpc_options = T::RpcOptions::default();
            self._leaderBalance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            let rpc_options = T::RpcOptions::default();
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._addZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._addHostIntoZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropHostFromZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._getZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listZones_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            let rpc_options = T::RpcOptions::default();
            self._addGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            let rpc_options = T::RpcOptions::default();
            self._addZoneIntoGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropZoneFromGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            let rpc_options = T::RpcOptions::default();
            self._getGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listGroups_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            let rpc_options = T::RpcOptions::default();
            self._createBackup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            let rpc_options = T::RpcOptions::default();
            self._restoreMeta_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._addListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._listListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getStats(
            &self,
            arg_req: &crate::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            let rpc_options = T::RpcOptions::default();
            self._signInFTService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            let rpc_options = T::RpcOptions::default();
            self._signOutFTService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listFTClients_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listFTIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery(
            &self,
            arg_req: &crate::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            let rpc_options = T::RpcOptions::default();
            self._killQuery_impl(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            let rpc_options = T::RpcOptions::default();
            self._reportTaskFinish_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            let rpc_options = T::RpcOptions::default();
            self._listCluster_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            let rpc_options = T::RpcOptions::default();
            self._getMetaDirInfo_impl(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            let rpc_options = T::RpcOptions::default();
            self._verifyClientVersion_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> MetaServiceExt<T> for MetaServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            self._createSpaceAs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            self._multiPut_impl(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            self._multiGet_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            self._removeRange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            self._scan_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            self._balance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            self._leaderBalance_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            self._addZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            self._dropZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHostIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            self._addHostIntoZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropHostFromZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            self._dropHostFromZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            self._getZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            self._listZones_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            self._addGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            self._dropGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addZoneIntoGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            self._addZoneIntoGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZoneFromGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            self._dropZoneFromGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            self._getGroup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listGroups_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListGroupsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            self._listGroups_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            self._createBackup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            self._restoreMeta_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            self._addListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            self._removeListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            self._listListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            self._getStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signInFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            self._signInFTService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signOutFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            self._signOutFTService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTClients_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            self._listFTClients_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            self._createFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            self._dropFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            self._listFTIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            self._createSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            self._updateSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            self._listSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            self._getSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            self._removeSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            self._killQuery_impl(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            self._reportTaskFinish_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            self._listCluster_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            self._getMetaDirInfo_impl(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            self._verifyClientVersion_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> MetaService for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::marker::Send,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            self.as_ref().createSpace(
                arg_req,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            self.as_ref().dropSpace(
                arg_req,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            self.as_ref().getSpace(
                arg_req,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            self.as_ref().listSpaces(
                arg_req,
            )
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            self.as_ref().createSpaceAs(
                arg_req,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            self.as_ref().createTag(
                arg_req,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            self.as_ref().alterTag(
                arg_req,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            self.as_ref().dropTag(
                arg_req,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            self.as_ref().getTag(
                arg_req,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            self.as_ref().listTags(
                arg_req,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            self.as_ref().createEdge(
                arg_req,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            self.as_ref().alterEdge(
                arg_req,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            self.as_ref().dropEdge(
                arg_req,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            self.as_ref().getEdge(
                arg_req,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            self.as_ref().listEdges(
                arg_req,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            self.as_ref().listHosts(
                arg_req,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            self.as_ref().getPartsAlloc(
                arg_req,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            self.as_ref().listParts(
                arg_req,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            self.as_ref().multiPut(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            self.as_ref().multiGet(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            self.as_ref().scan(
                arg_req,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            self.as_ref().createTagIndex(
                arg_req,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            self.as_ref().dropTagIndex(
                arg_req,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            self.as_ref().getTagIndex(
                arg_req,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            self.as_ref().listTagIndexes(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            self.as_ref().listTagIndexStatus(
                arg_req,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            self.as_ref().createEdgeIndex(
                arg_req,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            self.as_ref().dropEdgeIndex(
                arg_req,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            self.as_ref().getEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            self.as_ref().listEdgeIndexes(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            self.as_ref().listEdgeIndexStatus(
                arg_req,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            self.as_ref().createUser(
                arg_req,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            self.as_ref().dropUser(
                arg_req,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            self.as_ref().alterUser(
                arg_req,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            self.as_ref().grantRole(
                arg_req,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            self.as_ref().revokeRole(
                arg_req,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            self.as_ref().listUsers(
                arg_req,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            self.as_ref().listRoles(
                arg_req,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            self.as_ref().getUserRoles(
                arg_req,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            self.as_ref().changePassword(
                arg_req,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            self.as_ref().heartBeat(
                arg_req,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            self.as_ref().balance(
                arg_req,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            self.as_ref().leaderBalance(
                arg_req,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            self.as_ref().regConfig(
                arg_req,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            self.as_ref().getConfig(
                arg_req,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            self.as_ref().setConfig(
                arg_req,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            self.as_ref().listConfigs(
                arg_req,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            self.as_ref().createSnapshot(
                arg_req,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            self.as_ref().dropSnapshot(
                arg_req,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            self.as_ref().listSnapshots(
                arg_req,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            self.as_ref().runAdminJob(
                arg_req,
            )
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            self.as_ref().addZone(
                arg_req,
            )
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            self.as_ref().dropZone(
                arg_req,
            )
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            self.as_ref().addHostIntoZone(
                arg_req,
            )
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            self.as_ref().dropHostFromZone(
                arg_req,
            )
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            self.as_ref().getZone(
                arg_req,
            )
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            self.as_ref().listZones(
                arg_req,
            )
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            self.as_ref().addGroup(
                arg_req,
            )
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            self.as_ref().dropGroup(
                arg_req,
            )
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            self.as_ref().addZoneIntoGroup(
                arg_req,
            )
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            self.as_ref().dropZoneFromGroup(
                arg_req,
            )
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            self.as_ref().getGroup(
                arg_req,
            )
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            self.as_ref().listGroups(
                arg_req,
            )
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            self.as_ref().createBackup(
                arg_req,
            )
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            self.as_ref().restoreMeta(
                arg_req,
            )
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            self.as_ref().addListener(
                arg_req,
            )
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            self.as_ref().removeListener(
                arg_req,
            )
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            self.as_ref().listListener(
                arg_req,
            )
        }
        fn getStats(
            &self,
            arg_req: &crate::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            self.as_ref().getStats(
                arg_req,
            )
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            self.as_ref().signInFTService(
                arg_req,
            )
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            self.as_ref().signOutFTService(
                arg_req,
            )
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            self.as_ref().listFTClients(
                arg_req,
            )
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            self.as_ref().createFTIndex(
                arg_req,
            )
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            self.as_ref().dropFTIndex(
                arg_req,
            )
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            self.as_ref().listFTIndexes(
                arg_req,
            )
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            self.as_ref().createSession(
                arg_req,
            )
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            self.as_ref().updateSessions(
                arg_req,
            )
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            self.as_ref().listSessions(
                arg_req,
            )
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            self.as_ref().getSession(
                arg_req,
            )
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            self.as_ref().removeSession(
                arg_req,
            )
        }
        fn killQuery(
            &self,
            arg_req: &crate::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            self.as_ref().killQuery(
                arg_req,
            )
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            self.as_ref().reportTaskFinish(
                arg_req,
            )
        }
        fn listCluster(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            self.as_ref().listCluster(
                arg_req,
            )
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            self.as_ref().getMetaDirInfo(
                arg_req,
            )
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            self.as_ref().verifyClientVersion(
                arg_req,
            )
        }
    }

    impl<'a, S, T> MetaServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::convert::AsRef<dyn MetaServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSpaces_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSpaceAs_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTags_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listHosts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getPartsAlloc_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listParts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn multiPut_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiPutReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).multiPut_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).get_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn multiGet_with_rpc_opts(
            &self,
            arg_req: &crate::types::MultiGetReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).multiGet_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).remove_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeRange_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeRange_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scan_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).scan_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).grantRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).revokeRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listUsers_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getUserRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).changePassword_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).heartBeat_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn balance_with_rpc_opts(
            &self,
            arg_req: &crate::types::BalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).balance_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn leaderBalance_with_rpc_opts(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).leaderBalance_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).regConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).setConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listConfigs_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSnapshots_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).runAdminJob_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addHostIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addHostIntoZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropHostFromZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropHostFromZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listZones_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addGroup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropGroup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addZoneIntoGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addZoneIntoGroup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropZoneFromGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropZoneFromGroup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getGroup_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetGroupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getGroup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listGroups_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListGroupsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listGroups_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createBackup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).restoreMeta_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getStats_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn signInFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).signInFTService_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn signOutFTService_with_rpc_opts(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).signOutFTService_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listFTClients_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listFTClients_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createFTIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropFTIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listFTIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).updateSessions_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSessions_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).killQuery_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).reportTaskFinish_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listCluster_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getMetaDirInfo_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).verifyClientVersion_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_MetaService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn MetaService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn MetaServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type MetaServiceDynClient = <make_MetaService as ::fbthrift::ClientFactory>::Api;
    pub type MetaServiceClient = ::std::sync::Arc<MetaServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_MetaService {
        type Api = dyn MetaService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn MetaService>::with_spawner(protocol, transport, spawner)
        }
    }

}

/// Server definitions for `meta`.
pub mod server {
    #[::async_trait::async_trait]
    pub trait MetaService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn createSpace(
            &self,
            _req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpace",
                ),
            ))
        }
        async fn dropSpace(
            &self,
            _req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSpace",
                ),
            ))
        }
        async fn getSpace(
            &self,
            _req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSpace",
                ),
            ))
        }
        async fn listSpaces(
            &self,
            _req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSpaces",
                ),
            ))
        }
        async fn createSpaceAs(
            &self,
            _req: crate::types::CreateSpaceAsReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceAsExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSpaceAsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpaceAs",
                ),
            ))
        }
        async fn createTag(
            &self,
            _req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTag",
                ),
            ))
        }
        async fn alterTag(
            &self,
            _req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterTag",
                ),
            ))
        }
        async fn dropTag(
            &self,
            _req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTag",
                ),
            ))
        }
        async fn getTag(
            &self,
            _req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTag",
                ),
            ))
        }
        async fn listTags(
            &self,
            _req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTags",
                ),
            ))
        }
        async fn createEdge(
            &self,
            _req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdge",
                ),
            ))
        }
        async fn alterEdge(
            &self,
            _req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterEdge",
                ),
            ))
        }
        async fn dropEdge(
            &self,
            _req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdge",
                ),
            ))
        }
        async fn getEdge(
            &self,
            _req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdge",
                ),
            ))
        }
        async fn listEdges(
            &self,
            _req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdges",
                ),
            ))
        }
        async fn listHosts(
            &self,
            _req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listHosts",
                ),
            ))
        }
        async fn getPartsAlloc(
            &self,
            _req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getPartsAlloc",
                ),
            ))
        }
        async fn listParts(
            &self,
            _req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listParts",
                ),
            ))
        }
        async fn multiPut(
            &self,
            _req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiPut",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "get",
                ),
            ))
        }
        async fn multiGet(
            &self,
            _req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiGet",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeRange",
                ),
            ))
        }
        async fn scan(
            &self,
            _req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "scan",
                ),
            ))
        }
        async fn createTagIndex(
            &self,
            _req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTagIndex",
                ),
            ))
        }
        async fn dropTagIndex(
            &self,
            _req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTagIndex",
                ),
            ))
        }
        async fn getTagIndex(
            &self,
            _req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTagIndex",
                ),
            ))
        }
        async fn listTagIndexes(
            &self,
            _req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexes",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn listTagIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexStatus",
                ),
            ))
        }
        async fn createEdgeIndex(
            &self,
            _req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdgeIndex",
                ),
            ))
        }
        async fn dropEdgeIndex(
            &self,
            _req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdgeIndex",
                ),
            ))
        }
        async fn getEdgeIndex(
            &self,
            _req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexes(
            &self,
            _req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexes",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexStatus",
                ),
            ))
        }
        async fn createUser(
            &self,
            _req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createUser",
                ),
            ))
        }
        async fn dropUser(
            &self,
            _req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropUser",
                ),
            ))
        }
        async fn alterUser(
            &self,
            _req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterUser",
                ),
            ))
        }
        async fn grantRole(
            &self,
            _req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "grantRole",
                ),
            ))
        }
        async fn revokeRole(
            &self,
            _req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "revokeRole",
                ),
            ))
        }
        async fn listUsers(
            &self,
            _req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listUsers",
                ),
            ))
        }
        async fn listRoles(
            &self,
            _req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listRoles",
                ),
            ))
        }
        async fn getUserRoles(
            &self,
            _req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getUserRoles",
                ),
            ))
        }
        async fn changePassword(
            &self,
            _req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "changePassword",
                ),
            ))
        }
        async fn heartBeat(
            &self,
            _req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "heartBeat",
                ),
            ))
        }
        async fn balance(
            &self,
            _req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "balance",
                ),
            ))
        }
        async fn leaderBalance(
            &self,
            _req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "leaderBalance",
                ),
            ))
        }
        async fn regConfig(
            &self,
            _req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "regConfig",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getConfig",
                ),
            ))
        }
        async fn setConfig(
            &self,
            _req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "setConfig",
                ),
            ))
        }
        async fn listConfigs(
            &self,
            _req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listConfigs",
                ),
            ))
        }
        async fn createSnapshot(
            &self,
            _req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSnapshot",
                ),
            ))
        }
        async fn dropSnapshot(
            &self,
            _req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSnapshot",
                ),
            ))
        }
        async fn listSnapshots(
            &self,
            _req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSnapshots",
                ),
            ))
        }
        async fn runAdminJob(
            &self,
            _req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "runAdminJob",
                ),
            ))
        }
        async fn addZone(
            &self,
            _req: crate::types::AddZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addZone",
                ),
            ))
        }
        async fn dropZone(
            &self,
            _req: crate::types::DropZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropZone",
                ),
            ))
        }
        async fn addHostIntoZone(
            &self,
            _req: crate::types::AddHostIntoZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddHostIntoZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addHostIntoZone",
                ),
            ))
        }
        async fn dropHostFromZone(
            &self,
            _req: crate::types::DropHostFromZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropHostFromZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropHostFromZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropHostFromZone",
                ),
            ))
        }
        async fn getZone(
            &self,
            _req: crate::types::GetZoneReq,
        ) -> ::std::result::Result<crate::types::GetZoneResp, crate::services::meta_service::GetZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getZone",
                ),
            ))
        }
        async fn listZones(
            &self,
            _req: crate::types::ListZonesReq,
        ) -> ::std::result::Result<crate::types::ListZonesResp, crate::services::meta_service::ListZonesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListZonesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listZones",
                ),
            ))
        }
        async fn addGroup(
            &self,
            _req: crate::types::AddGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addGroup",
                ),
            ))
        }
        async fn dropGroup(
            &self,
            _req: crate::types::DropGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropGroup",
                ),
            ))
        }
        async fn addZoneIntoGroup(
            &self,
            _req: crate::types::AddZoneIntoGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneIntoGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addZoneIntoGroup",
                ),
            ))
        }
        async fn dropZoneFromGroup(
            &self,
            _req: crate::types::DropZoneFromGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneFromGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropZoneFromGroup",
                ),
            ))
        }
        async fn getGroup(
            &self,
            _req: crate::types::GetGroupReq,
        ) -> ::std::result::Result<crate::types::GetGroupResp, crate::services::meta_service::GetGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getGroup",
                ),
            ))
        }
        async fn listGroups(
            &self,
            _req: crate::types::ListGroupsReq,
        ) -> ::std::result::Result<crate::types::ListGroupsResp, crate::services::meta_service::ListGroupsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListGroupsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listGroups",
                ),
            ))
        }
        async fn createBackup(
            &self,
            _req: crate::types::CreateBackupReq,
        ) -> ::std::result::Result<crate::types::CreateBackupResp, crate::services::meta_service::CreateBackupExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateBackupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createBackup",
                ),
            ))
        }
        async fn restoreMeta(
            &self,
            _req: crate::types::RestoreMetaReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RestoreMetaExn> {
            ::std::result::Result::Err(crate::services::meta_service::RestoreMetaExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "restoreMeta",
                ),
            ))
        }
        async fn addListener(
            &self,
            _req: crate::types::AddListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addListener",
                ),
            ))
        }
        async fn removeListener(
            &self,
            _req: crate::types::RemoveListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeListener",
                ),
            ))
        }
        async fn listListener(
            &self,
            _req: crate::types::ListListenerReq,
        ) -> ::std::result::Result<crate::types::ListListenerResp, crate::services::meta_service::ListListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listListener",
                ),
            ))
        }
        async fn getStats(
            &self,
            _req: crate::types::GetStatsReq,
        ) -> ::std::result::Result<crate::types::GetStatsResp, crate::services::meta_service::GetStatsExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetStatsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getStats",
                ),
            ))
        }
        async fn signInFTService(
            &self,
            _req: crate::types::SignInFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignInFTServiceExn> {
            ::std::result::Result::Err(crate::services::meta_service::SignInFTServiceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signInFTService",
                ),
            ))
        }
        async fn signOutFTService(
            &self,
            _req: crate::types::SignOutFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignOutFTServiceExn> {
            ::std::result::Result::Err(crate::services::meta_service::SignOutFTServiceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signOutFTService",
                ),
            ))
        }
        async fn listFTClients(
            &self,
            _req: crate::types::ListFTClientsReq,
        ) -> ::std::result::Result<crate::types::ListFTClientsResp, crate::services::meta_service::ListFTClientsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListFTClientsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listFTClients",
                ),
            ))
        }
        async fn createFTIndex(
            &self,
            _req: crate::types::CreateFTIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateFTIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateFTIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createFTIndex",
                ),
            ))
        }
        async fn dropFTIndex(
            &self,
            _req: crate::types::DropFTIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropFTIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropFTIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropFTIndex",
                ),
            ))
        }
        async fn listFTIndexes(
            &self,
            _req: crate::types::ListFTIndexesReq,
        ) -> ::std::result::Result<crate::types::ListFTIndexesResp, crate::services::meta_service::ListFTIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListFTIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listFTIndexes",
                ),
            ))
        }
        async fn createSession(
            &self,
            _req: crate::types::CreateSessionReq,
        ) -> ::std::result::Result<crate::types::CreateSessionResp, crate::services::meta_service::CreateSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSession",
                ),
            ))
        }
        async fn updateSessions(
            &self,
            _req: crate::types::UpdateSessionsReq,
        ) -> ::std::result::Result<crate::types::UpdateSessionsResp, crate::services::meta_service::UpdateSessionsExn> {
            ::std::result::Result::Err(crate::services::meta_service::UpdateSessionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "updateSessions",
                ),
            ))
        }
        async fn listSessions(
            &self,
            _req: crate::types::ListSessionsReq,
        ) -> ::std::result::Result<crate::types::ListSessionsResp, crate::services::meta_service::ListSessionsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSessionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSessions",
                ),
            ))
        }
        async fn getSession(
            &self,
            _req: crate::types::GetSessionReq,
        ) -> ::std::result::Result<crate::types::GetSessionResp, crate::services::meta_service::GetSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSession",
                ),
            ))
        }
        async fn removeSession(
            &self,
            _req: crate::types::RemoveSessionReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeSession",
                ),
            ))
        }
        async fn killQuery(
            &self,
            _req: crate::types::KillQueryReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::KillQueryExn> {
            ::std::result::Result::Err(crate::services::meta_service::KillQueryExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "killQuery",
                ),
            ))
        }
        async fn reportTaskFinish(
            &self,
            _req: crate::types::ReportTaskReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ReportTaskFinishExn> {
            ::std::result::Result::Err(crate::services::meta_service::ReportTaskFinishExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "reportTaskFinish",
                ),
            ))
        }
        async fn listCluster(
            &self,
            _req: crate::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::services::meta_service::ListClusterExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListClusterExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listCluster",
                ),
            ))
        }
        async fn getMetaDirInfo(
            &self,
            _req: crate::types::GetMetaDirInfoReq,
        ) -> ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::services::meta_service::GetMetaDirInfoExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetMetaDirInfoExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getMetaDirInfo",
                ),
            ))
        }
        async fn verifyClientVersion(
            &self,
            _req: crate::types::VerifyClientVersionReq,
        ) -> ::std::result::Result<crate::types::VerifyClientVersionResp, crate::services::meta_service::VerifyClientVersionExn> {
            ::std::result::Result::Err(crate::services::meta_service::VerifyClientVersionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "verifyClientVersion",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> MetaService for ::std::boxed::Box<T>
    where
        T: MetaService + Send + Sync + ?Sized,
    {
        async fn createSpace(
            &self,
            req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            (**self).createSpace(
                req,
            ).await
        }
        async fn dropSpace(
            &self,
            req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            (**self).dropSpace(
                req,
            ).await
        }
        async fn getSpace(
            &self,
            req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            (**self).getSpace(
                req,
            ).await
        }
        async fn listSpaces(
            &self,
            req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            (**self).listSpaces(
                req,
            ).await
        }
        async fn createSpaceAs(
            &self,
            req: crate::types::CreateSpaceAsReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceAsExn> {
            (**self).createSpaceAs(
                req,
            ).await
        }
        async fn createTag(
            &self,
            req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            (**self).createTag(
                req,
            ).await
        }
        async fn alterTag(
            &self,
            req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            (**self).alterTag(
                req,
            ).await
        }
        async fn dropTag(
            &self,
            req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            (**self).dropTag(
                req,
            ).await
        }
        async fn getTag(
            &self,
            req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            (**self).getTag(
                req,
            ).await
        }
        async fn listTags(
            &self,
            req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            (**self).listTags(
                req,
            ).await
        }
        async fn createEdge(
            &self,
            req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            (**self).createEdge(
                req,
            ).await
        }
        async fn alterEdge(
            &self,
            req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            (**self).alterEdge(
                req,
            ).await
        }
        async fn dropEdge(
            &self,
            req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            (**self).dropEdge(
                req,
            ).await
        }
        async fn getEdge(
            &self,
            req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            (**self).getEdge(
                req,
            ).await
        }
        async fn listEdges(
            &self,
            req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            (**self).listEdges(
                req,
            ).await
        }
        async fn listHosts(
            &self,
            req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            (**self).listHosts(
                req,
            ).await
        }
        async fn getPartsAlloc(
            &self,
            req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            (**self).getPartsAlloc(
                req,
            ).await
        }
        async fn listParts(
            &self,
            req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            (**self).listParts(
                req,
            ).await
        }
        async fn multiPut(
            &self,
            req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            (**self).multiPut(
                req,
            ).await
        }
        async fn get(
            &self,
            req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            (**self).get(
                req,
            ).await
        }
        async fn multiGet(
            &self,
            req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            (**self).multiGet(
                req,
            ).await
        }
        async fn remove(
            &self,
            req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            (**self).remove(
                req,
            ).await
        }
        async fn removeRange(
            &self,
            req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            (**self).removeRange(
                req,
            ).await
        }
        async fn scan(
            &self,
            req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            (**self).scan(
                req,
            ).await
        }
        async fn createTagIndex(
            &self,
            req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            (**self).createTagIndex(
                req,
            ).await
        }
        async fn dropTagIndex(
            &self,
            req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            (**self).dropTagIndex(
                req,
            ).await
        }
        async fn getTagIndex(
            &self,
            req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            (**self).getTagIndex(
                req,
            ).await
        }
        async fn listTagIndexes(
            &self,
            req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            (**self).listTagIndexes(
                req,
            ).await
        }
        async fn rebuildTagIndex(
            &self,
            req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            (**self).rebuildTagIndex(
                req,
            ).await
        }
        async fn listTagIndexStatus(
            &self,
            req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            (**self).listTagIndexStatus(
                req,
            ).await
        }
        async fn createEdgeIndex(
            &self,
            req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            (**self).createEdgeIndex(
                req,
            ).await
        }
        async fn dropEdgeIndex(
            &self,
            req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            (**self).dropEdgeIndex(
                req,
            ).await
        }
        async fn getEdgeIndex(
            &self,
            req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            (**self).getEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexes(
            &self,
            req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            (**self).listEdgeIndexes(
                req,
            ).await
        }
        async fn rebuildEdgeIndex(
            &self,
            req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            (**self).rebuildEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexStatus(
            &self,
            req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            (**self).listEdgeIndexStatus(
                req,
            ).await
        }
        async fn createUser(
            &self,
            req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            (**self).createUser(
                req,
            ).await
        }
        async fn dropUser(
            &self,
            req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            (**self).dropUser(
                req,
            ).await
        }
        async fn alterUser(
            &self,
            req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            (**self).alterUser(
                req,
            ).await
        }
        async fn grantRole(
            &self,
            req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            (**self).grantRole(
                req,
            ).await
        }
        async fn revokeRole(
            &self,
            req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            (**self).revokeRole(
                req,
            ).await
        }
        async fn listUsers(
            &self,
            req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            (**self).listUsers(
                req,
            ).await
        }
        async fn listRoles(
            &self,
            req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            (**self).listRoles(
                req,
            ).await
        }
        async fn getUserRoles(
            &self,
            req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            (**self).getUserRoles(
                req,
            ).await
        }
        async fn changePassword(
            &self,
            req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            (**self).changePassword(
                req,
            ).await
        }
        async fn heartBeat(
            &self,
            req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            (**self).heartBeat(
                req,
            ).await
        }
        async fn balance(
            &self,
            req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            (**self).balance(
                req,
            ).await
        }
        async fn leaderBalance(
            &self,
            req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            (**self).leaderBalance(
                req,
            ).await
        }
        async fn regConfig(
            &self,
            req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            (**self).regConfig(
                req,
            ).await
        }
        async fn getConfig(
            &self,
            req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            (**self).getConfig(
                req,
            ).await
        }
        async fn setConfig(
            &self,
            req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            (**self).setConfig(
                req,
            ).await
        }
        async fn listConfigs(
            &self,
            req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            (**self).listConfigs(
                req,
            ).await
        }
        async fn createSnapshot(
            &self,
            req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            (**self).createSnapshot(
                req,
            ).await
        }
        async fn dropSnapshot(
            &self,
            req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            (**self).dropSnapshot(
                req,
            ).await
        }
        async fn listSnapshots(
            &self,
            req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            (**self).listSnapshots(
                req,
            ).await
        }
        async fn runAdminJob(
            &self,
            req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            (**self).runAdminJob(
                req,
            ).await
        }
        async fn addZone(
            &self,
            req: crate::types::AddZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneExn> {
            (**self).addZone(
                req,
            ).await
        }
        async fn dropZone(
            &self,
            req: crate::types::DropZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneExn> {
            (**self).dropZone(
                req,
            ).await
        }
        async fn addHostIntoZone(
            &self,
            req: crate::types::AddHostIntoZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddHostIntoZoneExn> {
            (**self).addHostIntoZone(
                req,
            ).await
        }
        async fn dropHostFromZone(
            &self,
            req: crate::types::DropHostFromZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropHostFromZoneExn> {
            (**self).dropHostFromZone(
                req,
            ).await
        }
        async fn getZone(
            &self,
            req: crate::types::GetZoneReq,
        ) -> ::std::result::Result<crate::types::GetZoneResp, crate::services::meta_service::GetZoneExn> {
            (**self).getZone(
                req,
            ).await
        }
        async fn listZones(
            &self,
            req: crate::types::ListZonesReq,
        ) -> ::std::result::Result<crate::types::ListZonesResp, crate::services::meta_service::ListZonesExn> {
            (**self).listZones(
                req,
            ).await
        }
        async fn addGroup(
            &self,
            req: crate::types::AddGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddGroupExn> {
            (**self).addGroup(
                req,
            ).await
        }
        async fn dropGroup(
            &self,
            req: crate::types::DropGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropGroupExn> {
            (**self).dropGroup(
                req,
            ).await
        }
        async fn addZoneIntoGroup(
            &self,
            req: crate::types::AddZoneIntoGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneIntoGroupExn> {
            (**self).addZoneIntoGroup(
                req,
            ).await
        }
        async fn dropZoneFromGroup(
            &self,
            req: crate::types::DropZoneFromGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneFromGroupExn> {
            (**self).dropZoneFromGroup(
                req,
            ).await
        }
        async fn getGroup(
            &self,
            req: crate::types::GetGroupReq,
        ) -> ::std::result::Result<crate::types::GetGroupResp, crate::services::meta_service::GetGroupExn> {
            (**self).getGroup(
                req,
            ).await
        }
        async fn listGroups(
            &self,
            req: crate::types::ListGroupsReq,
        ) -> ::std::result::Result<crate::types::ListGroupsResp, crate::services::meta_service::ListGroupsExn> {
            (**self).listGroups(
                req,
            ).await
        }
        async fn createBackup(
            &self,
            req: crate::types::CreateBackupReq,
        ) -> ::std::result::Result<crate::types::CreateBackupResp, crate::services::meta_service::CreateBackupExn> {
            (**self).createBackup(
                req,
            ).await
        }
        async fn restoreMeta(
            &self,
            req: crate::types::RestoreMetaReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RestoreMetaExn> {
            (**self).restoreMeta(
                req,
            ).await
        }
        async fn addListener(
            &self,
            req: crate::types::AddListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddListenerExn> {
            (**self).addListener(
                req,
            ).await
        }
        async fn removeListener(
            &self,
            req: crate::types::RemoveListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveListenerExn> {
            (**self).removeListener(
                req,
            ).await
        }
        async fn listListener(
            &self,
            req: crate::types::ListListenerReq,
        ) -> ::std::result::Result<crate::types::ListListenerResp, crate::services::meta_service::ListListenerExn> {
            (**self).listListener(
                req,
            ).await
        }
        async fn getStats(
            &self,
            req: crate::types::GetStatsReq,
        ) -> ::std::result::Result<crate::types::GetStatsResp, crate::services::meta_service::GetStatsExn> {
            (**self).getStats(
                req,
            ).await
        }
        async fn signInFTService(
            &self,
            req: crate::types::SignInFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignInFTServiceExn> {
            (**self).signInFTService(
                req,
            ).await
        }
        async fn signOutFTService(
            &self,
            req: crate::types::SignOutFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignOutFTServiceExn> {
            (**self).signOutFTService(
                req,
            ).await
        }
        async fn listFTClients(
            &self,
            req: crate::types::ListFTClientsReq,
        ) -> ::std::result::Result<crate::types::ListFTClientsResp, crate::services::meta_service::ListFTClientsExn> {
            (**self).listFTClients(
                req,
            ).await
        }
        async fn createFTIndex(
            &self,
            req: crate::types::CreateFTIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateFTIndexExn> {
            (**self).createFTIndex(
                req,
            ).await
        }
        async fn dropFTIndex(
            &self,
            req: crate::types::DropFTIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropFTIndexExn> {
            (**self).dropFTIndex(
                req,
            ).await
        }
        async fn listFTIndexes(
            &self,
            req: crate::types::ListFTIndexesReq,
        ) -> ::std::result::Result<crate::types::ListFTIndexesResp, crate::services::meta_service::ListFTIndexesExn> {
            (**self).listFTIndexes(
                req,
            ).await
        }
        async fn createSession(
            &self,
            req: crate::types::CreateSessionReq,
        ) -> ::std::result::Result<crate::types::CreateSessionResp, crate::services::meta_service::CreateSessionExn> {
            (**self).createSession(
                req,
            ).await
        }
        async fn updateSessions(
            &self,
            req: crate::types::UpdateSessionsReq,
        ) -> ::std::result::Result<crate::types::UpdateSessionsResp, crate::services::meta_service::UpdateSessionsExn> {
            (**self).updateSessions(
                req,
            ).await
        }
        async fn listSessions(
            &self,
            req: crate::types::ListSessionsReq,
        ) -> ::std::result::Result<crate::types::ListSessionsResp, crate::services::meta_service::ListSessionsExn> {
            (**self).listSessions(
                req,
            ).await
        }
        async fn getSession(
            &self,
            req: crate::types::GetSessionReq,
        ) -> ::std::result::Result<crate::types::GetSessionResp, crate::services::meta_service::GetSessionExn> {
            (**self).getSession(
                req,
            ).await
        }
        async fn removeSession(
            &self,
            req: crate::types::RemoveSessionReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveSessionExn> {
            (**self).removeSession(
                req,
            ).await
        }
        async fn killQuery(
            &self,
            req: crate::types::KillQueryReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::KillQueryExn> {
            (**self).killQuery(
                req,
            ).await
        }
        async fn reportTaskFinish(
            &self,
            req: crate::types::ReportTaskReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ReportTaskFinishExn> {
            (**self).reportTaskFinish(
                req,
            ).await
        }
        async fn listCluster(
            &self,
            req: crate::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::services::meta_service::ListClusterExn> {
            (**self).listCluster(
                req,
            ).await
        }
        async fn getMetaDirInfo(
            &self,
            req: crate::types::GetMetaDirInfoReq,
        ) -> ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::services::meta_service::GetMetaDirInfoExn> {
            (**self).getMetaDirInfo(
                req,
            ).await
        }
        async fn verifyClientVersion(
            &self,
            req: crate::types::VerifyClientVersionReq,
        ) -> ::std::result::Result<crate::types::VerifyClientVersionResp, crate::services::meta_service::VerifyClientVersionExn> {
            (**self).verifyClientVersion(
                req,
            ).await
        }
    }

    /// Processor for MetaService's methods.
    #[derive(Clone, Debug)]
    pub struct MetaServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_MetaService_createSpace {
        req: crate::types::CreateSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSpace {
        req: crate::types::DropSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSpace {
        req: crate::types::GetSpaceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSpaces {
        req: crate::types::ListSpacesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listSpaces {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSpaces"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSpaces", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSpaceAs {
        req: crate::types::CreateSpaceAsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSpaceAs {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSpaceAs"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSpaceAs", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTag {
        req: crate::types::CreateTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterTag {
        req: crate::types::AlterTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTag {
        req: crate::types::DropTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTag {
        req: crate::types::GetTagReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTags {
        req: crate::types::ListTagsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTags {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTags"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTags", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdge {
        req: crate::types::CreateEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterEdge {
        req: crate::types::AlterEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdge {
        req: crate::types::DropEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdge {
        req: crate::types::GetEdgeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdges {
        req: crate::types::ListEdgesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdges", "req"))?,
            })
        }
    }

    struct Args_MetaService_listHosts {
        req: crate::types::ListHostsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listHosts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listHosts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listHosts", "req"))?,
            })
        }
    }

    struct Args_MetaService_getPartsAlloc {
        req: crate::types::GetPartsAllocReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getPartsAlloc {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getPartsAlloc", "req"))?,
            })
        }
    }

    struct Args_MetaService_listParts {
        req: crate::types::ListPartsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listParts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listParts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listParts", "req"))?,
            })
        }
    }

    struct Args_MetaService_multiPut {
        req: crate::types::MultiPutReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_multiPut {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.multiPut"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.multiPut", "req"))?,
            })
        }
    }

    struct Args_MetaService_get {
        req: crate::types::GetReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_get {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.get"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.get", "req"))?,
            })
        }
    }

    struct Args_MetaService_multiGet {
        req: crate::types::MultiGetReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_multiGet {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.multiGet"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.multiGet", "req"))?,
            })
        }
    }

    struct Args_MetaService_remove {
        req: crate::types::RemoveReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_remove {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.remove"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.remove", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeRange {
        req: crate::types::RemoveRangeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_removeRange {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeRange"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeRange", "req"))?,
            })
        }
    }

    struct Args_MetaService_scan {
        req: crate::types::ScanReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_scan {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.scan"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.scan", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTagIndex {
        req: crate::types::CreateTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTagIndex {
        req: crate::types::DropTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTagIndex {
        req: crate::types::GetTagIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexes {
        req: crate::types::ListTagIndexesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildTagIndex {
        req: crate::types::RebuildIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexStatus {
        req: crate::types::ListIndexStatusReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdgeIndex {
        req: crate::types::CreateEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdgeIndex {
        req: crate::types::DropEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdgeIndex {
        req: crate::types::GetEdgeIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexes {
        req: crate::types::ListEdgeIndexesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildEdgeIndex {
        req: crate::types::RebuildIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexStatus {
        req: crate::types::ListIndexStatusReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createUser {
        req: crate::types::CreateUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropUser {
        req: crate::types::DropUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterUser {
        req: crate::types::AlterUserReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_alterUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_grantRole {
        req: crate::types::GrantRoleReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_grantRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.grantRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.grantRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_revokeRole {
        req: crate::types::RevokeRoleReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_revokeRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.revokeRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.revokeRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_listUsers {
        req: crate::types::ListUsersReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listUsers {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listUsers"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listUsers", "req"))?,
            })
        }
    }

    struct Args_MetaService_listRoles {
        req: crate::types::ListRolesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_getUserRoles {
        req: crate::types::GetUserRolesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getUserRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getUserRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getUserRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_changePassword {
        req: crate::types::ChangePasswordReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_changePassword {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.changePassword"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.changePassword", "req"))?,
            })
        }
    }

    struct Args_MetaService_heartBeat {
        req: crate::types::HBReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_heartBeat {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.heartBeat"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.heartBeat", "req"))?,
            })
        }
    }

    struct Args_MetaService_balance {
        req: crate::types::BalanceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_balance {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.balance"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.balance", "req"))?,
            })
        }
    }

    struct Args_MetaService_leaderBalance {
        req: crate::types::LeaderBalanceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_leaderBalance {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.leaderBalance"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.leaderBalance", "req"))?,
            })
        }
    }

    struct Args_MetaService_regConfig {
        req: crate::types::RegConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_regConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.regConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.regConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_getConfig {
        req: crate::types::GetConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_setConfig {
        req: crate::types::SetConfigReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_setConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.setConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.setConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_listConfigs {
        req: crate::types::ListConfigsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listConfigs {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listConfigs"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listConfigs", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSnapshot {
        req: crate::types::CreateSnapshotReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSnapshot {
        req: crate::types::DropSnapshotReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSnapshots {
        req: crate::types::ListSnapshotsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listSnapshots {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSnapshots"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSnapshots", "req"))?,
            })
        }
    }

    struct Args_MetaService_runAdminJob {
        req: crate::types::AdminJobReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_runAdminJob {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.runAdminJob"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.runAdminJob", "req"))?,
            })
        }
    }

    struct Args_MetaService_addZone {
        req: crate::types::AddZoneReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_addZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropZone {
        req: crate::types::DropZoneReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_addHostIntoZone {
        req: crate::types::AddHostIntoZoneReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_addHostIntoZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addHostIntoZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addHostIntoZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropHostFromZone {
        req: crate::types::DropHostFromZoneReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropHostFromZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropHostFromZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropHostFromZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_getZone {
        req: crate::types::GetZoneReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_listZones {
        req: crate::types::ListZonesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listZones {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listZones"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listZones", "req"))?,
            })
        }
    }

    struct Args_MetaService_addGroup {
        req: crate::types::AddGroupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_addGroup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addGroup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addGroup", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropGroup {
        req: crate::types::DropGroupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropGroup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropGroup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropGroup", "req"))?,
            })
        }
    }

    struct Args_MetaService_addZoneIntoGroup {
        req: crate::types::AddZoneIntoGroupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_addZoneIntoGroup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addZoneIntoGroup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addZoneIntoGroup", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropZoneFromGroup {
        req: crate::types::DropZoneFromGroupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropZoneFromGroup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropZoneFromGroup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropZoneFromGroup", "req"))?,
            })
        }
    }

    struct Args_MetaService_getGroup {
        req: crate::types::GetGroupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getGroup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getGroup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getGroup", "req"))?,
            })
        }
    }

    struct Args_MetaService_listGroups {
        req: crate::types::ListGroupsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listGroups {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listGroups"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listGroups", "req"))?,
            })
        }
    }

    struct Args_MetaService_createBackup {
        req: crate::types::CreateBackupReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createBackup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createBackup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createBackup", "req"))?,
            })
        }
    }

    struct Args_MetaService_restoreMeta {
        req: crate::types::RestoreMetaReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_restoreMeta {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.restoreMeta"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.restoreMeta", "req"))?,
            })
        }
    }

    struct Args_MetaService_addListener {
        req: crate::types::AddListenerReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_addListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeListener {
        req: crate::types::RemoveListenerReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_removeListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_listListener {
        req: crate::types::ListListenerReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_getStats {
        req: crate::types::GetStatsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getStats {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getStats"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getStats", "req"))?,
            })
        }
    }

    struct Args_MetaService_signInFTService {
        req: crate::types::SignInFTServiceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_signInFTService {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.signInFTService"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.signInFTService", "req"))?,
            })
        }
    }

    struct Args_MetaService_signOutFTService {
        req: crate::types::SignOutFTServiceReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_signOutFTService {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.signOutFTService"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.signOutFTService", "req"))?,
            })
        }
    }

    struct Args_MetaService_listFTClients {
        req: crate::types::ListFTClientsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listFTClients {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listFTClients"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listFTClients", "req"))?,
            })
        }
    }

    struct Args_MetaService_createFTIndex {
        req: crate::types::CreateFTIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createFTIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createFTIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createFTIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropFTIndex {
        req: crate::types::DropFTIndexReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_dropFTIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropFTIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropFTIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listFTIndexes {
        req: crate::types::ListFTIndexesReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listFTIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listFTIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listFTIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSession {
        req: crate::types::CreateSessionReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_createSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_updateSessions {
        req: crate::types::UpdateSessionsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_updateSessions {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.updateSessions"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.updateSessions", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSessions {
        req: crate::types::ListSessionsReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listSessions {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSessions"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSessions", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSession {
        req: crate::types::GetSessionReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeSession {
        req: crate::types::RemoveSessionReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_removeSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_killQuery {
        req: crate::types::KillQueryReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_killQuery {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.killQuery"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.killQuery", "req"))?,
            })
        }
    }

    struct Args_MetaService_reportTaskFinish {
        req: crate::types::ReportTaskReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_reportTaskFinish {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.reportTaskFinish"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.reportTaskFinish", "req"))?,
            })
        }
    }

    struct Args_MetaService_listCluster {
        req: crate::types::ListClusterInfoReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_listCluster {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listCluster"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listCluster", "req"))?,
            })
        }
    }

    struct Args_MetaService_getMetaDirInfo {
        req: crate::types::GetMetaDirInfoReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_getMetaDirInfo {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getMetaDirInfo"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getMetaDirInfo", "req"))?,
            })
        }
    }

    struct Args_MetaService_verifyClientVersion {
        req: crate::types::VerifyClientVersionReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MetaService_verifyClientVersion {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.verifyClientVersion"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.verifyClientVersion", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSpace"))]
        async fn handle_createSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSpace", exn);
                    crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSpace"))]
        async fn handle_dropSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropSpace", exn);
                    crate::services::meta_service::DropSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSpace"))]
        async fn handle_getSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSpace = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getSpace", exn);
                    crate::services::meta_service::GetSpaceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSpaces"))]
        async fn handle_listSpaces<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSpaces = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSpaces(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListSpacesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSpaces",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listSpaces", exn);
                    crate::services::meta_service::ListSpacesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSpaces",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSpaceAs"))]
        async fn handle_createSpaceAs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpaceAs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSpaceAs = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSpaceAs(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSpaceAsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSpaceAsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpaceAs",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSpaceAs", exn);
                    crate::services::meta_service::CreateSpaceAsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSpaceAs",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTag"))]
        async fn handle_createTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createTag", exn);
                    crate::services::meta_service::CreateTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterTag"))]
        async fn handle_alterTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterTag", exn);
                    crate::services::meta_service::AlterTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTag"))]
        async fn handle_dropTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropTag", exn);
                    crate::services::meta_service::DropTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTag"))]
        async fn handle_getTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTag = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getTag", exn);
                    crate::services::meta_service::GetTagExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTags"))]
        async fn handle_listTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTags = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTags(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTags",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTags", exn);
                    crate::services::meta_service::ListTagsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTags",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdge"))]
        async fn handle_createEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createEdge", exn);
                    crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterEdge"))]
        async fn handle_alterEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterEdge", exn);
                    crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdge"))]
        async fn handle_dropEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropEdge", exn);
                    crate::services::meta_service::DropEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdge"))]
        async fn handle_getEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getEdge", exn);
                    crate::services::meta_service::GetEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdges"))]
        async fn handle_listEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdges", exn);
                    crate::services::meta_service::ListEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listHosts"))]
        async fn handle_listHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listHosts = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listHosts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListHostsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListHostsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listHosts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listHosts", exn);
                    crate::services::meta_service::ListHostsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listHosts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getPartsAlloc"))]
        async fn handle_getPartsAlloc<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getPartsAlloc = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getPartsAlloc(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetPartsAllocExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPartsAlloc",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getPartsAlloc", exn);
                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getPartsAlloc",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listParts"))]
        async fn handle_listParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listParts = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listParts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListPartsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListPartsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listParts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listParts", exn);
                    crate::services::meta_service::ListPartsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listParts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.multiPut"))]
        async fn handle_multiPut<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_multiPut = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.multiPut(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::MultiPutExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::MultiPutExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiPut",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.multiPut", exn);
                    crate::services::meta_service::MultiPutExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "multiPut",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.get"))]
        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_get = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.get(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.get", exn);
                    crate::services::meta_service::GetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "get",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.multiGet"))]
        async fn handle_multiGet<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_multiGet = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.multiGet(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::MultiGetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::MultiGetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiGet",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.multiGet", exn);
                    crate::services::meta_service::MultiGetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "multiGet",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.remove"))]
        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_remove = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.remove(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.remove", exn);
                    crate::services::meta_service::RemoveExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "remove",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeRange"))]
        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeRange = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeRange(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.removeRange", exn);
                    crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeRange",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.scan"))]
        async fn handle_scan<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_scan = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scan(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ScanExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ScanExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scan",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.scan", exn);
                    crate::services::meta_service::ScanExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scan",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTagIndex"))]
        async fn handle_createTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createTagIndex", exn);
                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTagIndex"))]
        async fn handle_dropTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropTagIndex", exn);
                    crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTagIndex"))]
        async fn handle_getTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getTagIndex", exn);
                    crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexes"))]
        async fn handle_listTagIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexes = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexes", exn);
                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildTagIndex"))]
        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.rebuildTagIndex", exn);
                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexStatus"))]
        async fn handle_listTagIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexStatus = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexStatus", exn);
                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdgeIndex"))]
        async fn handle_createEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createEdgeIndex", exn);
                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdgeIndex"))]
        async fn handle_dropEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropEdgeIndex", exn);
                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdgeIndex"))]
        async fn handle_getEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getEdgeIndex", exn);
                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexes"))]
        async fn handle_listEdgeIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexes = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexes", exn);
                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildEdgeIndex"))]
        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.rebuildEdgeIndex", exn);
                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexStatus"))]
        async fn handle_listEdgeIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexStatus = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexStatus", exn);
                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createUser"))]
        async fn handle_createUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createUser", exn);
                    crate::services::meta_service::CreateUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropUser"))]
        async fn handle_dropUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropUser", exn);
                    crate::services::meta_service::DropUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterUser"))]
        async fn handle_alterUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterUser = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AlterUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AlterUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.alterUser", exn);
                    crate::services::meta_service::AlterUserExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.grantRole"))]
        async fn handle_grantRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_grantRole = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.grantRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GrantRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "grantRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.grantRole", exn);
                    crate::services::meta_service::GrantRoleExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "grantRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.revokeRole"))]
        async fn handle_revokeRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_revokeRole = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.revokeRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RevokeRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "revokeRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.revokeRole", exn);
                    crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "revokeRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listUsers"))]
        async fn handle_listUsers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listUsers = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listUsers(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListUsersExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListUsersExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listUsers",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listUsers", exn);
                    crate::services::meta_service::ListUsersExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listUsers",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listRoles"))]
        async fn handle_listRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listRoles = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listRoles", exn);
                    crate::services::meta_service::ListRolesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getUserRoles"))]
        async fn handle_getUserRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getUserRoles = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getUserRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetUserRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUserRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getUserRoles", exn);
                    crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getUserRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.changePassword"))]
        async fn handle_changePassword<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_changePassword = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.changePassword(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ChangePasswordExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "changePassword",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.changePassword", exn);
                    crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "changePassword",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.heartBeat"))]
        async fn handle_heartBeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_heartBeat = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.heartBeat(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::HeartBeatExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "heartBeat",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.heartBeat", exn);
                    crate::services::meta_service::HeartBeatExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "heartBeat",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.balance"))]
        async fn handle_balance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_balance = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.balance(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::BalanceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::BalanceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "balance",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.balance", exn);
                    crate::services::meta_service::BalanceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "balance",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.leaderBalance"))]
        async fn handle_leaderBalance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_leaderBalance = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.leaderBalance(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::LeaderBalanceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "leaderBalance",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.leaderBalance", exn);
                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "leaderBalance",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.regConfig"))]
        async fn handle_regConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_regConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.regConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RegConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RegConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "regConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.regConfig", exn);
                    crate::services::meta_service::RegConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "regConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getConfig"))]
        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getConfig", exn);
                    crate::services::meta_service::GetConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.setConfig"))]
        async fn handle_setConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_setConfig = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.setConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::SetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::SetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.setConfig", exn);
                    crate::services::meta_service::SetConfigExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "setConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listConfigs"))]
        async fn handle_listConfigs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listConfigs = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listConfigs(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListConfigsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listConfigs",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listConfigs", exn);
                    crate::services::meta_service::ListConfigsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listConfigs",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSnapshot"))]
        async fn handle_createSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSnapshot = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSnapshot", exn);
                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSnapshot"))]
        async fn handle_dropSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSnapshot = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropSnapshot", exn);
                    crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSnapshots"))]
        async fn handle_listSnapshots<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSnapshots = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSnapshots(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListSnapshotsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSnapshots",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listSnapshots", exn);
                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSnapshots",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.runAdminJob"))]
        async fn handle_runAdminJob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_runAdminJob = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.runAdminJob(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RunAdminJobExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "runAdminJob",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.runAdminJob", exn);
                    crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "runAdminJob",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addZone"))]
        async fn handle_addZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addZone = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AddZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AddZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.addZone", exn);
                    crate::services::meta_service::AddZoneExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropZone"))]
        async fn handle_dropZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropZone = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropZone", exn);
                    crate::services::meta_service::DropZoneExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addHostIntoZone"))]
        async fn handle_addHostIntoZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHostIntoZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addHostIntoZone = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addHostIntoZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AddHostIntoZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AddHostIntoZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addHostIntoZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.addHostIntoZone", exn);
                    crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addHostIntoZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropHostFromZone"))]
        async fn handle_dropHostFromZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropHostFromZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropHostFromZone = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropHostFromZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropHostFromZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropHostFromZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropHostFromZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropHostFromZone", exn);
                    crate::services::meta_service::DropHostFromZoneExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropHostFromZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getZone"))]
        async fn handle_getZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getZone = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getZone", exn);
                    crate::services::meta_service::GetZoneExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listZones"))]
        async fn handle_listZones<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listZones";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listZones = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listZones(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListZonesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListZonesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listZones",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listZones", exn);
                    crate::services::meta_service::ListZonesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listZones",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addGroup"))]
        async fn handle_addGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addGroup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addGroup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AddGroupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AddGroupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addGroup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.addGroup", exn);
                    crate::services::meta_service::AddGroupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addGroup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropGroup"))]
        async fn handle_dropGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropGroup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropGroup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropGroupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropGroupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropGroup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropGroup", exn);
                    crate::services::meta_service::DropGroupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropGroup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addZoneIntoGroup"))]
        async fn handle_addZoneIntoGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZoneIntoGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addZoneIntoGroup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addZoneIntoGroup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AddZoneIntoGroupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AddZoneIntoGroupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addZoneIntoGroup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.addZoneIntoGroup", exn);
                    crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addZoneIntoGroup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropZoneFromGroup"))]
        async fn handle_dropZoneFromGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZoneFromGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropZoneFromGroup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropZoneFromGroup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropZoneFromGroupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropZoneFromGroupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropZoneFromGroup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropZoneFromGroup", exn);
                    crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropZoneFromGroup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getGroup"))]
        async fn handle_getGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getGroup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getGroup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetGroupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetGroupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getGroup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getGroup", exn);
                    crate::services::meta_service::GetGroupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getGroup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listGroups"))]
        async fn handle_listGroups<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listGroups";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listGroups = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listGroups(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListGroupsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListGroupsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listGroups",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listGroups", exn);
                    crate::services::meta_service::ListGroupsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listGroups",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createBackup"))]
        async fn handle_createBackup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createBackup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createBackup = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createBackup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateBackupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateBackupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createBackup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createBackup", exn);
                    crate::services::meta_service::CreateBackupExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createBackup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.restoreMeta"))]
        async fn handle_restoreMeta<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.restoreMeta";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_restoreMeta = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.restoreMeta(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RestoreMetaExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RestoreMetaExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "restoreMeta",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.restoreMeta", exn);
                    crate::services::meta_service::RestoreMetaExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "restoreMeta",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addListener"))]
        async fn handle_addListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addListener = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::AddListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::AddListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.addListener", exn);
                    crate::services::meta_service::AddListenerExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeListener"))]
        async fn handle_removeListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeListener = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.removeListener", exn);
                    crate::services::meta_service::RemoveListenerExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listListener"))]
        async fn handle_listListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listListener = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listListener", exn);
                    crate::services::meta_service::ListListenerExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getStats"))]
        async fn handle_getStats<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getStats";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getStats = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getStats(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetStatsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetStatsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStats",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getStats", exn);
                    crate::services::meta_service::GetStatsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getStats",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.signInFTService"))]
        async fn handle_signInFTService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signInFTService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_signInFTService = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.signInFTService(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::SignInFTServiceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::SignInFTServiceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signInFTService",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.signInFTService", exn);
                    crate::services::meta_service::SignInFTServiceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "signInFTService",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.signOutFTService"))]
        async fn handle_signOutFTService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signOutFTService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_signOutFTService = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.signOutFTService(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::SignOutFTServiceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::SignOutFTServiceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signOutFTService",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.signOutFTService", exn);
                    crate::services::meta_service::SignOutFTServiceExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "signOutFTService",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listFTClients"))]
        async fn handle_listFTClients<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTClients";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listFTClients = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listFTClients(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListFTClientsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListFTClientsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listFTClients",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listFTClients", exn);
                    crate::services::meta_service::ListFTClientsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listFTClients",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createFTIndex"))]
        async fn handle_createFTIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createFTIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createFTIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createFTIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateFTIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateFTIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createFTIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createFTIndex", exn);
                    crate::services::meta_service::CreateFTIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createFTIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropFTIndex"))]
        async fn handle_dropFTIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropFTIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropFTIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropFTIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::DropFTIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::DropFTIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropFTIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.dropFTIndex", exn);
                    crate::services::meta_service::DropFTIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropFTIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listFTIndexes"))]
        async fn handle_listFTIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listFTIndexes = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listFTIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListFTIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListFTIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listFTIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listFTIndexes", exn);
                    crate::services::meta_service::ListFTIndexesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listFTIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSession"))]
        async fn handle_createSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSession = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::CreateSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::CreateSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.createSession", exn);
                    crate::services::meta_service::CreateSessionExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.updateSessions"))]
        async fn handle_updateSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.updateSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_updateSessions = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateSessions(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::UpdateSessionsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::UpdateSessionsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateSessions",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.updateSessions", exn);
                    crate::services::meta_service::UpdateSessionsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateSessions",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSessions"))]
        async fn handle_listSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSessions = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSessions(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListSessionsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListSessionsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSessions",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listSessions", exn);
                    crate::services::meta_service::ListSessionsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSessions",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSession"))]
        async fn handle_getSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSession = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getSession", exn);
                    crate::services::meta_service::GetSessionExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeSession"))]
        async fn handle_removeSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeSession = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::RemoveSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::RemoveSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.removeSession", exn);
                    crate::services::meta_service::RemoveSessionExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.killQuery"))]
        async fn handle_killQuery<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.killQuery";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_killQuery = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.killQuery(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::KillQueryExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::KillQueryExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "killQuery",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.killQuery", exn);
                    crate::services::meta_service::KillQueryExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "killQuery",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.reportTaskFinish"))]
        async fn handle_reportTaskFinish<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.reportTaskFinish";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_reportTaskFinish = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.reportTaskFinish(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ReportTaskFinishExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ReportTaskFinishExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "reportTaskFinish",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.reportTaskFinish", exn);
                    crate::services::meta_service::ReportTaskFinishExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "reportTaskFinish",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listCluster"))]
        async fn handle_listCluster<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listCluster";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listCluster = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listCluster(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::ListClusterExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::ListClusterExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listCluster",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.listCluster", exn);
                    crate::services::meta_service::ListClusterExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listCluster",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getMetaDirInfo"))]
        async fn handle_getMetaDirInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getMetaDirInfo";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getMetaDirInfo = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getMetaDirInfo(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::GetMetaDirInfoExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::GetMetaDirInfoExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getMetaDirInfo",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.getMetaDirInfo", exn);
                    crate::services::meta_service::GetMetaDirInfoExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getMetaDirInfo",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.verifyClientVersion"))]
        async fn handle_verifyClientVersion<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.verifyClientVersion";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_verifyClientVersion = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.verifyClientVersion(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::meta_service::VerifyClientVersionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::meta_service::VerifyClientVersionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "verifyClientVersion",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MetaService.verifyClientVersion", exn);
                    crate::services::meta_service::VerifyClientVersionExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "verifyClientVersion",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"createSpace" => ::std::result::Result::Ok(0usize),
                b"dropSpace" => ::std::result::Result::Ok(1usize),
                b"getSpace" => ::std::result::Result::Ok(2usize),
                b"listSpaces" => ::std::result::Result::Ok(3usize),
                b"createSpaceAs" => ::std::result::Result::Ok(4usize),
                b"createTag" => ::std::result::Result::Ok(5usize),
                b"alterTag" => ::std::result::Result::Ok(6usize),
                b"dropTag" => ::std::result::Result::Ok(7usize),
                b"getTag" => ::std::result::Result::Ok(8usize),
                b"listTags" => ::std::result::Result::Ok(9usize),
                b"createEdge" => ::std::result::Result::Ok(10usize),
                b"alterEdge" => ::std::result::Result::Ok(11usize),
                b"dropEdge" => ::std::result::Result::Ok(12usize),
                b"getEdge" => ::std::result::Result::Ok(13usize),
                b"listEdges" => ::std::result::Result::Ok(14usize),
                b"listHosts" => ::std::result::Result::Ok(15usize),
                b"getPartsAlloc" => ::std::result::Result::Ok(16usize),
                b"listParts" => ::std::result::Result::Ok(17usize),
                b"multiPut" => ::std::result::Result::Ok(18usize),
                b"get" => ::std::result::Result::Ok(19usize),
                b"multiGet" => ::std::result::Result::Ok(20usize),
                b"remove" => ::std::result::Result::Ok(21usize),
                b"removeRange" => ::std::result::Result::Ok(22usize),
                b"scan" => ::std::result::Result::Ok(23usize),
                b"createTagIndex" => ::std::result::Result::Ok(24usize),
                b"dropTagIndex" => ::std::result::Result::Ok(25usize),
                b"getTagIndex" => ::std::result::Result::Ok(26usize),
                b"listTagIndexes" => ::std::result::Result::Ok(27usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(28usize),
                b"listTagIndexStatus" => ::std::result::Result::Ok(29usize),
                b"createEdgeIndex" => ::std::result::Result::Ok(30usize),
                b"dropEdgeIndex" => ::std::result::Result::Ok(31usize),
                b"getEdgeIndex" => ::std::result::Result::Ok(32usize),
                b"listEdgeIndexes" => ::std::result::Result::Ok(33usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(34usize),
                b"listEdgeIndexStatus" => ::std::result::Result::Ok(35usize),
                b"createUser" => ::std::result::Result::Ok(36usize),
                b"dropUser" => ::std::result::Result::Ok(37usize),
                b"alterUser" => ::std::result::Result::Ok(38usize),
                b"grantRole" => ::std::result::Result::Ok(39usize),
                b"revokeRole" => ::std::result::Result::Ok(40usize),
                b"listUsers" => ::std::result::Result::Ok(41usize),
                b"listRoles" => ::std::result::Result::Ok(42usize),
                b"getUserRoles" => ::std::result::Result::Ok(43usize),
                b"changePassword" => ::std::result::Result::Ok(44usize),
                b"heartBeat" => ::std::result::Result::Ok(45usize),
                b"balance" => ::std::result::Result::Ok(46usize),
                b"leaderBalance" => ::std::result::Result::Ok(47usize),
                b"regConfig" => ::std::result::Result::Ok(48usize),
                b"getConfig" => ::std::result::Result::Ok(49usize),
                b"setConfig" => ::std::result::Result::Ok(50usize),
                b"listConfigs" => ::std::result::Result::Ok(51usize),
                b"createSnapshot" => ::std::result::Result::Ok(52usize),
                b"dropSnapshot" => ::std::result::Result::Ok(53usize),
                b"listSnapshots" => ::std::result::Result::Ok(54usize),
                b"runAdminJob" => ::std::result::Result::Ok(55usize),
                b"addZone" => ::std::result::Result::Ok(56usize),
                b"dropZone" => ::std::result::Result::Ok(57usize),
                b"addHostIntoZone" => ::std::result::Result::Ok(58usize),
                b"dropHostFromZone" => ::std::result::Result::Ok(59usize),
                b"getZone" => ::std::result::Result::Ok(60usize),
                b"listZones" => ::std::result::Result::Ok(61usize),
                b"addGroup" => ::std::result::Result::Ok(62usize),
                b"dropGroup" => ::std::result::Result::Ok(63usize),
                b"addZoneIntoGroup" => ::std::result::Result::Ok(64usize),
                b"dropZoneFromGroup" => ::std::result::Result::Ok(65usize),
                b"getGroup" => ::std::result::Result::Ok(66usize),
                b"listGroups" => ::std::result::Result::Ok(67usize),
                b"createBackup" => ::std::result::Result::Ok(68usize),
                b"restoreMeta" => ::std::result::Result::Ok(69usize),
                b"addListener" => ::std::result::Result::Ok(70usize),
                b"removeListener" => ::std::result::Result::Ok(71usize),
                b"listListener" => ::std::result::Result::Ok(72usize),
                b"getStats" => ::std::result::Result::Ok(73usize),
                b"signInFTService" => ::std::result::Result::Ok(74usize),
                b"signOutFTService" => ::std::result::Result::Ok(75usize),
                b"listFTClients" => ::std::result::Result::Ok(76usize),
                b"createFTIndex" => ::std::result::Result::Ok(77usize),
                b"dropFTIndex" => ::std::result::Result::Ok(78usize),
                b"listFTIndexes" => ::std::result::Result::Ok(79usize),
                b"createSession" => ::std::result::Result::Ok(80usize),
                b"updateSessions" => ::std::result::Result::Ok(81usize),
                b"listSessions" => ::std::result::Result::Ok(82usize),
                b"getSession" => ::std::result::Result::Ok(83usize),
                b"removeSession" => ::std::result::Result::Ok(84usize),
                b"killQuery" => ::std::result::Result::Ok(85usize),
                b"reportTaskFinish" => ::std::result::Result::Ok(86usize),
                b"listCluster" => ::std::result::Result::Ok(87usize),
                b"getMetaDirInfo" => ::std::result::Result::Ok(88usize),
                b"verifyClientVersion" => ::std::result::Result::Ok(89usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_createSpace(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_dropSpace(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_getSpace(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_listSpaces(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_createSpaceAs(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_createTag(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_alterTag(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_dropTag(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_getTag(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_listTags(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_createEdge(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_alterEdge(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_dropEdge(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_getEdge(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_listEdges(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_listHosts(_p, _r, _reply_state, _seqid).await
                }
                16usize => {
                    self.handle_getPartsAlloc(_p, _r, _reply_state, _seqid).await
                }
                17usize => {
                    self.handle_listParts(_p, _r, _reply_state, _seqid).await
                }
                18usize => {
                    self.handle_multiPut(_p, _r, _reply_state, _seqid).await
                }
                19usize => {
                    self.handle_get(_p, _r, _reply_state, _seqid).await
                }
                20usize => {
                    self.handle_multiGet(_p, _r, _reply_state, _seqid).await
                }
                21usize => {
                    self.handle_remove(_p, _r, _reply_state, _seqid).await
                }
                22usize => {
                    self.handle_removeRange(_p, _r, _reply_state, _seqid).await
                }
                23usize => {
                    self.handle_scan(_p, _r, _reply_state, _seqid).await
                }
                24usize => {
                    self.handle_createTagIndex(_p, _r, _reply_state, _seqid).await
                }
                25usize => {
                    self.handle_dropTagIndex(_p, _r, _reply_state, _seqid).await
                }
                26usize => {
                    self.handle_getTagIndex(_p, _r, _reply_state, _seqid).await
                }
                27usize => {
                    self.handle_listTagIndexes(_p, _r, _reply_state, _seqid).await
                }
                28usize => {
                    self.handle_rebuildTagIndex(_p, _r, _reply_state, _seqid).await
                }
                29usize => {
                    self.handle_listTagIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                30usize => {
                    self.handle_createEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                31usize => {
                    self.handle_dropEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                32usize => {
                    self.handle_getEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                33usize => {
                    self.handle_listEdgeIndexes(_p, _r, _reply_state, _seqid).await
                }
                34usize => {
                    self.handle_rebuildEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                35usize => {
                    self.handle_listEdgeIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                36usize => {
                    self.handle_createUser(_p, _r, _reply_state, _seqid).await
                }
                37usize => {
                    self.handle_dropUser(_p, _r, _reply_state, _seqid).await
                }
                38usize => {
                    self.handle_alterUser(_p, _r, _reply_state, _seqid).await
                }
                39usize => {
                    self.handle_grantRole(_p, _r, _reply_state, _seqid).await
                }
                40usize => {
                    self.handle_revokeRole(_p, _r, _reply_state, _seqid).await
                }
                41usize => {
                    self.handle_listUsers(_p, _r, _reply_state, _seqid).await
                }
                42usize => {
                    self.handle_listRoles(_p, _r, _reply_state, _seqid).await
                }
                43usize => {
                    self.handle_getUserRoles(_p, _r, _reply_state, _seqid).await
                }
                44usize => {
                    self.handle_changePassword(_p, _r, _reply_state, _seqid).await
                }
                45usize => {
                    self.handle_heartBeat(_p, _r, _reply_state, _seqid).await
                }
                46usize => {
                    self.handle_balance(_p, _r, _reply_state, _seqid).await
                }
                47usize => {
                    self.handle_leaderBalance(_p, _r, _reply_state, _seqid).await
                }
                48usize => {
                    self.handle_regConfig(_p, _r, _reply_state, _seqid).await
                }
                49usize => {
                    self.handle_getConfig(_p, _r, _reply_state, _seqid).await
                }
                50usize => {
                    self.handle_setConfig(_p, _r, _reply_state, _seqid).await
                }
                51usize => {
                    self.handle_listConfigs(_p, _r, _reply_state, _seqid).await
                }
                52usize => {
                    self.handle_createSnapshot(_p, _r, _reply_state, _seqid).await
                }
                53usize => {
                    self.handle_dropSnapshot(_p, _r, _reply_state, _seqid).await
                }
                54usize => {
                    self.handle_listSnapshots(_p, _r, _reply_state, _seqid).await
                }
                55usize => {
                    self.handle_runAdminJob(_p, _r, _reply_state, _seqid).await
                }
                56usize => {
                    self.handle_addZone(_p, _r, _reply_state, _seqid).await
                }
                57usize => {
                    self.handle_dropZone(_p, _r, _reply_state, _seqid).await
                }
                58usize => {
                    self.handle_addHostIntoZone(_p, _r, _reply_state, _seqid).await
                }
                59usize => {
                    self.handle_dropHostFromZone(_p, _r, _reply_state, _seqid).await
                }
                60usize => {
                    self.handle_getZone(_p, _r, _reply_state, _seqid).await
                }
                61usize => {
                    self.handle_listZones(_p, _r, _reply_state, _seqid).await
                }
                62usize => {
                    self.handle_addGroup(_p, _r, _reply_state, _seqid).await
                }
                63usize => {
                    self.handle_dropGroup(_p, _r, _reply_state, _seqid).await
                }
                64usize => {
                    self.handle_addZoneIntoGroup(_p, _r, _reply_state, _seqid).await
                }
                65usize => {
                    self.handle_dropZoneFromGroup(_p, _r, _reply_state, _seqid).await
                }
                66usize => {
                    self.handle_getGroup(_p, _r, _reply_state, _seqid).await
                }
                67usize => {
                    self.handle_listGroups(_p, _r, _reply_state, _seqid).await
                }
                68usize => {
                    self.handle_createBackup(_p, _r, _reply_state, _seqid).await
                }
                69usize => {
                    self.handle_restoreMeta(_p, _r, _reply_state, _seqid).await
                }
                70usize => {
                    self.handle_addListener(_p, _r, _reply_state, _seqid).await
                }
                71usize => {
                    self.handle_removeListener(_p, _r, _reply_state, _seqid).await
                }
                72usize => {
                    self.handle_listListener(_p, _r, _reply_state, _seqid).await
                }
                73usize => {
                    self.handle_getStats(_p, _r, _reply_state, _seqid).await
                }
                74usize => {
                    self.handle_signInFTService(_p, _r, _reply_state, _seqid).await
                }
                75usize => {
                    self.handle_signOutFTService(_p, _r, _reply_state, _seqid).await
                }
                76usize => {
                    self.handle_listFTClients(_p, _r, _reply_state, _seqid).await
                }
                77usize => {
                    self.handle_createFTIndex(_p, _r, _reply_state, _seqid).await
                }
                78usize => {
                    self.handle_dropFTIndex(_p, _r, _reply_state, _seqid).await
                }
                79usize => {
                    self.handle_listFTIndexes(_p, _r, _reply_state, _seqid).await
                }
                80usize => {
                    self.handle_createSession(_p, _r, _reply_state, _seqid).await
                }
                81usize => {
                    self.handle_updateSessions(_p, _r, _reply_state, _seqid).await
                }
                82usize => {
                    self.handle_listSessions(_p, _r, _reply_state, _seqid).await
                }
                83usize => {
                    self.handle_getSession(_p, _r, _reply_state, _seqid).await
                }
                84usize => {
                    self.handle_removeSession(_p, _r, _reply_state, _seqid).await
                }
                85usize => {
                    self.handle_killQuery(_p, _r, _reply_state, _seqid).await
                }
                86usize => {
                    self.handle_reportTaskFinish(_p, _r, _reply_state, _seqid).await
                }
                87usize => {
                    self.handle_listCluster(_p, _r, _reply_state, _seqid).await
                }
                88usize => {
                    self.handle_getMetaDirInfo(_p, _r, _reply_state, _seqid).await
                }
                89usize => {
                    self.handle_verifyClientVersion(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MetaServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "MetaService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from MetaService
                "createSpace",
                "dropSpace",
                "getSpace",
                "listSpaces",
                "createSpaceAs",
                "createTag",
                "alterTag",
                "dropTag",
                "getTag",
                "listTags",
                "createEdge",
                "alterEdge",
                "dropEdge",
                "getEdge",
                "listEdges",
                "listHosts",
                "getPartsAlloc",
                "listParts",
                "multiPut",
                "get",
                "multiGet",
                "remove",
                "removeRange",
                "scan",
                "createTagIndex",
                "dropTagIndex",
                "getTagIndex",
                "listTagIndexes",
                "rebuildTagIndex",
                "listTagIndexStatus",
                "createEdgeIndex",
                "dropEdgeIndex",
                "getEdgeIndex",
                "listEdgeIndexes",
                "rebuildEdgeIndex",
                "listEdgeIndexStatus",
                "createUser",
                "dropUser",
                "alterUser",
                "grantRole",
                "revokeRole",
                "listUsers",
                "listRoles",
                "getUserRoles",
                "changePassword",
                "heartBeat",
                "balance",
                "leaderBalance",
                "regConfig",
                "getConfig",
                "setConfig",
                "listConfigs",
                "createSnapshot",
                "dropSnapshot",
                "listSnapshots",
                "runAdminJob",
                "addZone",
                "dropZone",
                "addHostIntoZone",
                "dropHostFromZone",
                "getZone",
                "listZones",
                "addGroup",
                "dropGroup",
                "addZoneIntoGroup",
                "dropZoneFromGroup",
                "getGroup",
                "listGroups",
                "createBackup",
                "restoreMeta",
                "addListener",
                "removeListener",
                "listListener",
                "getStats",
                "signInFTService",
                "signOutFTService",
                "listFTClients",
                "createFTIndex",
                "dropFTIndex",
                "listFTIndexes",
                "createSession",
                "updateSessions",
                "listSessions",
                "getSession",
                "removeSession",
                "killQuery",
                "reportTaskFinish",
                "listCluster",
                "getMetaDirInfo",
                "verifyClientVersion",
            ]
        }
    }

    /// Construct a new instance of a MetaService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_MetaService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "MetaService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct MetaService<'mock> {
        pub createSpace: r#impl::meta_service::createSpace<'mock>,
        pub dropSpace: r#impl::meta_service::dropSpace<'mock>,
        pub getSpace: r#impl::meta_service::getSpace<'mock>,
        pub listSpaces: r#impl::meta_service::listSpaces<'mock>,
        pub createSpaceAs: r#impl::meta_service::createSpaceAs<'mock>,
        pub createTag: r#impl::meta_service::createTag<'mock>,
        pub alterTag: r#impl::meta_service::alterTag<'mock>,
        pub dropTag: r#impl::meta_service::dropTag<'mock>,
        pub getTag: r#impl::meta_service::getTag<'mock>,
        pub listTags: r#impl::meta_service::listTags<'mock>,
        pub createEdge: r#impl::meta_service::createEdge<'mock>,
        pub alterEdge: r#impl::meta_service::alterEdge<'mock>,
        pub dropEdge: r#impl::meta_service::dropEdge<'mock>,
        pub getEdge: r#impl::meta_service::getEdge<'mock>,
        pub listEdges: r#impl::meta_service::listEdges<'mock>,
        pub listHosts: r#impl::meta_service::listHosts<'mock>,
        pub getPartsAlloc: r#impl::meta_service::getPartsAlloc<'mock>,
        pub listParts: r#impl::meta_service::listParts<'mock>,
        pub multiPut: r#impl::meta_service::multiPut<'mock>,
        pub get: r#impl::meta_service::get<'mock>,
        pub multiGet: r#impl::meta_service::multiGet<'mock>,
        pub remove: r#impl::meta_service::remove<'mock>,
        pub removeRange: r#impl::meta_service::removeRange<'mock>,
        pub scan: r#impl::meta_service::scan<'mock>,
        pub createTagIndex: r#impl::meta_service::createTagIndex<'mock>,
        pub dropTagIndex: r#impl::meta_service::dropTagIndex<'mock>,
        pub getTagIndex: r#impl::meta_service::getTagIndex<'mock>,
        pub listTagIndexes: r#impl::meta_service::listTagIndexes<'mock>,
        pub rebuildTagIndex: r#impl::meta_service::rebuildTagIndex<'mock>,
        pub listTagIndexStatus: r#impl::meta_service::listTagIndexStatus<'mock>,
        pub createEdgeIndex: r#impl::meta_service::createEdgeIndex<'mock>,
        pub dropEdgeIndex: r#impl::meta_service::dropEdgeIndex<'mock>,
        pub getEdgeIndex: r#impl::meta_service::getEdgeIndex<'mock>,
        pub listEdgeIndexes: r#impl::meta_service::listEdgeIndexes<'mock>,
        pub rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex<'mock>,
        pub listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus<'mock>,
        pub createUser: r#impl::meta_service::createUser<'mock>,
        pub dropUser: r#impl::meta_service::dropUser<'mock>,
        pub alterUser: r#impl::meta_service::alterUser<'mock>,
        pub grantRole: r#impl::meta_service::grantRole<'mock>,
        pub revokeRole: r#impl::meta_service::revokeRole<'mock>,
        pub listUsers: r#impl::meta_service::listUsers<'mock>,
        pub listRoles: r#impl::meta_service::listRoles<'mock>,
        pub getUserRoles: r#impl::meta_service::getUserRoles<'mock>,
        pub changePassword: r#impl::meta_service::changePassword<'mock>,
        pub heartBeat: r#impl::meta_service::heartBeat<'mock>,
        pub balance: r#impl::meta_service::balance<'mock>,
        pub leaderBalance: r#impl::meta_service::leaderBalance<'mock>,
        pub regConfig: r#impl::meta_service::regConfig<'mock>,
        pub getConfig: r#impl::meta_service::getConfig<'mock>,
        pub setConfig: r#impl::meta_service::setConfig<'mock>,
        pub listConfigs: r#impl::meta_service::listConfigs<'mock>,
        pub createSnapshot: r#impl::meta_service::createSnapshot<'mock>,
        pub dropSnapshot: r#impl::meta_service::dropSnapshot<'mock>,
        pub listSnapshots: r#impl::meta_service::listSnapshots<'mock>,
        pub runAdminJob: r#impl::meta_service::runAdminJob<'mock>,
        pub addZone: r#impl::meta_service::addZone<'mock>,
        pub dropZone: r#impl::meta_service::dropZone<'mock>,
        pub addHostIntoZone: r#impl::meta_service::addHostIntoZone<'mock>,
        pub dropHostFromZone: r#impl::meta_service::dropHostFromZone<'mock>,
        pub getZone: r#impl::meta_service::getZone<'mock>,
        pub listZones: r#impl::meta_service::listZones<'mock>,
        pub addGroup: r#impl::meta_service::addGroup<'mock>,
        pub dropGroup: r#impl::meta_service::dropGroup<'mock>,
        pub addZoneIntoGroup: r#impl::meta_service::addZoneIntoGroup<'mock>,
        pub dropZoneFromGroup: r#impl::meta_service::dropZoneFromGroup<'mock>,
        pub getGroup: r#impl::meta_service::getGroup<'mock>,
        pub listGroups: r#impl::meta_service::listGroups<'mock>,
        pub createBackup: r#impl::meta_service::createBackup<'mock>,
        pub restoreMeta: r#impl::meta_service::restoreMeta<'mock>,
        pub addListener: r#impl::meta_service::addListener<'mock>,
        pub removeListener: r#impl::meta_service::removeListener<'mock>,
        pub listListener: r#impl::meta_service::listListener<'mock>,
        pub getStats: r#impl::meta_service::getStats<'mock>,
        pub signInFTService: r#impl::meta_service::signInFTService<'mock>,
        pub signOutFTService: r#impl::meta_service::signOutFTService<'mock>,
        pub listFTClients: r#impl::meta_service::listFTClients<'mock>,
        pub createFTIndex: r#impl::meta_service::createFTIndex<'mock>,
        pub dropFTIndex: r#impl::meta_service::dropFTIndex<'mock>,
        pub listFTIndexes: r#impl::meta_service::listFTIndexes<'mock>,
        pub createSession: r#impl::meta_service::createSession<'mock>,
        pub updateSessions: r#impl::meta_service::updateSessions<'mock>,
        pub listSessions: r#impl::meta_service::listSessions<'mock>,
        pub getSession: r#impl::meta_service::getSession<'mock>,
        pub removeSession: r#impl::meta_service::removeSession<'mock>,
        pub killQuery: r#impl::meta_service::killQuery<'mock>,
        pub reportTaskFinish: r#impl::meta_service::reportTaskFinish<'mock>,
        pub listCluster: r#impl::meta_service::listCluster<'mock>,
        pub getMetaDirInfo: r#impl::meta_service::getMetaDirInfo<'mock>,
        pub verifyClientVersion: r#impl::meta_service::verifyClientVersion<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::MetaService {
        pub fn mock<'mock>() -> MetaService<'mock> {
            MetaService {
                createSpace: r#impl::meta_service::createSpace::unimplemented(),
                dropSpace: r#impl::meta_service::dropSpace::unimplemented(),
                getSpace: r#impl::meta_service::getSpace::unimplemented(),
                listSpaces: r#impl::meta_service::listSpaces::unimplemented(),
                createSpaceAs: r#impl::meta_service::createSpaceAs::unimplemented(),
                createTag: r#impl::meta_service::createTag::unimplemented(),
                alterTag: r#impl::meta_service::alterTag::unimplemented(),
                dropTag: r#impl::meta_service::dropTag::unimplemented(),
                getTag: r#impl::meta_service::getTag::unimplemented(),
                listTags: r#impl::meta_service::listTags::unimplemented(),
                createEdge: r#impl::meta_service::createEdge::unimplemented(),
                alterEdge: r#impl::meta_service::alterEdge::unimplemented(),
                dropEdge: r#impl::meta_service::dropEdge::unimplemented(),
                getEdge: r#impl::meta_service::getEdge::unimplemented(),
                listEdges: r#impl::meta_service::listEdges::unimplemented(),
                listHosts: r#impl::meta_service::listHosts::unimplemented(),
                getPartsAlloc: r#impl::meta_service::getPartsAlloc::unimplemented(),
                listParts: r#impl::meta_service::listParts::unimplemented(),
                multiPut: r#impl::meta_service::multiPut::unimplemented(),
                get: r#impl::meta_service::get::unimplemented(),
                multiGet: r#impl::meta_service::multiGet::unimplemented(),
                remove: r#impl::meta_service::remove::unimplemented(),
                removeRange: r#impl::meta_service::removeRange::unimplemented(),
                scan: r#impl::meta_service::scan::unimplemented(),
                createTagIndex: r#impl::meta_service::createTagIndex::unimplemented(),
                dropTagIndex: r#impl::meta_service::dropTagIndex::unimplemented(),
                getTagIndex: r#impl::meta_service::getTagIndex::unimplemented(),
                listTagIndexes: r#impl::meta_service::listTagIndexes::unimplemented(),
                rebuildTagIndex: r#impl::meta_service::rebuildTagIndex::unimplemented(),
                listTagIndexStatus: r#impl::meta_service::listTagIndexStatus::unimplemented(),
                createEdgeIndex: r#impl::meta_service::createEdgeIndex::unimplemented(),
                dropEdgeIndex: r#impl::meta_service::dropEdgeIndex::unimplemented(),
                getEdgeIndex: r#impl::meta_service::getEdgeIndex::unimplemented(),
                listEdgeIndexes: r#impl::meta_service::listEdgeIndexes::unimplemented(),
                rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex::unimplemented(),
                listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus::unimplemented(),
                createUser: r#impl::meta_service::createUser::unimplemented(),
                dropUser: r#impl::meta_service::dropUser::unimplemented(),
                alterUser: r#impl::meta_service::alterUser::unimplemented(),
                grantRole: r#impl::meta_service::grantRole::unimplemented(),
                revokeRole: r#impl::meta_service::revokeRole::unimplemented(),
                listUsers: r#impl::meta_service::listUsers::unimplemented(),
                listRoles: r#impl::meta_service::listRoles::unimplemented(),
                getUserRoles: r#impl::meta_service::getUserRoles::unimplemented(),
                changePassword: r#impl::meta_service::changePassword::unimplemented(),
                heartBeat: r#impl::meta_service::heartBeat::unimplemented(),
                balance: r#impl::meta_service::balance::unimplemented(),
                leaderBalance: r#impl::meta_service::leaderBalance::unimplemented(),
                regConfig: r#impl::meta_service::regConfig::unimplemented(),
                getConfig: r#impl::meta_service::getConfig::unimplemented(),
                setConfig: r#impl::meta_service::setConfig::unimplemented(),
                listConfigs: r#impl::meta_service::listConfigs::unimplemented(),
                createSnapshot: r#impl::meta_service::createSnapshot::unimplemented(),
                dropSnapshot: r#impl::meta_service::dropSnapshot::unimplemented(),
                listSnapshots: r#impl::meta_service::listSnapshots::unimplemented(),
                runAdminJob: r#impl::meta_service::runAdminJob::unimplemented(),
                addZone: r#impl::meta_service::addZone::unimplemented(),
                dropZone: r#impl::meta_service::dropZone::unimplemented(),
                addHostIntoZone: r#impl::meta_service::addHostIntoZone::unimplemented(),
                dropHostFromZone: r#impl::meta_service::dropHostFromZone::unimplemented(),
                getZone: r#impl::meta_service::getZone::unimplemented(),
                listZones: r#impl::meta_service::listZones::unimplemented(),
                addGroup: r#impl::meta_service::addGroup::unimplemented(),
                dropGroup: r#impl::meta_service::dropGroup::unimplemented(),
                addZoneIntoGroup: r#impl::meta_service::addZoneIntoGroup::unimplemented(),
                dropZoneFromGroup: r#impl::meta_service::dropZoneFromGroup::unimplemented(),
                getGroup: r#impl::meta_service::getGroup::unimplemented(),
                listGroups: r#impl::meta_service::listGroups::unimplemented(),
                createBackup: r#impl::meta_service::createBackup::unimplemented(),
                restoreMeta: r#impl::meta_service::restoreMeta::unimplemented(),
                addListener: r#impl::meta_service::addListener::unimplemented(),
                removeListener: r#impl::meta_service::removeListener::unimplemented(),
                listListener: r#impl::meta_service::listListener::unimplemented(),
                getStats: r#impl::meta_service::getStats::unimplemented(),
                signInFTService: r#impl::meta_service::signInFTService::unimplemented(),
                signOutFTService: r#impl::meta_service::signOutFTService::unimplemented(),
                listFTClients: r#impl::meta_service::listFTClients::unimplemented(),
                createFTIndex: r#impl::meta_service::createFTIndex::unimplemented(),
                dropFTIndex: r#impl::meta_service::dropFTIndex::unimplemented(),
                listFTIndexes: r#impl::meta_service::listFTIndexes::unimplemented(),
                createSession: r#impl::meta_service::createSession::unimplemented(),
                updateSessions: r#impl::meta_service::updateSessions::unimplemented(),
                listSessions: r#impl::meta_service::listSessions::unimplemented(),
                getSession: r#impl::meta_service::getSession::unimplemented(),
                removeSession: r#impl::meta_service::removeSession::unimplemented(),
                killQuery: r#impl::meta_service::killQuery::unimplemented(),
                reportTaskFinish: r#impl::meta_service::reportTaskFinish::unimplemented(),
                listCluster: r#impl::meta_service::listCluster::unimplemented(),
                getMetaDirInfo: r#impl::meta_service::getMetaDirInfo::unimplemented(),
                verifyClientVersion: r#impl::meta_service::verifyClientVersion::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::MetaService for MetaService<'mock> {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> {
            let mut closure = self.createSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> {
            let mut closure = self.dropSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> {
            let mut closure = self.getSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> {
            let mut closure = self.listSpaces.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError>> {
            let mut closure = self.createSpaceAs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSpaceAsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> {
            let mut closure = self.createTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> {
            let mut closure = self.alterTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> {
            let mut closure = self.dropTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> {
            let mut closure = self.getTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> {
            let mut closure = self.listTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> {
            let mut closure = self.createEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> {
            let mut closure = self.alterEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> {
            let mut closure = self.dropEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> {
            let mut closure = self.getEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> {
            let mut closure = self.listEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> {
            let mut closure = self.listHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> {
            let mut closure = self.getPartsAlloc.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> {
            let mut closure = self.listParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> {
            let mut closure = self.multiPut.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> {
            let mut closure = self.multiGet.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> {
            let mut closure = self.scan.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> {
            let mut closure = self.createTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> {
            let mut closure = self.dropTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> {
            let mut closure = self.getTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> {
            let mut closure = self.listTagIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> {
            let mut closure = self.listTagIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> {
            let mut closure = self.createEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> {
            let mut closure = self.dropEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> {
            let mut closure = self.getEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> {
            let mut closure = self.listEdgeIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> {
            let mut closure = self.listEdgeIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> {
            let mut closure = self.createUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> {
            let mut closure = self.dropUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> {
            let mut closure = self.alterUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> {
            let mut closure = self.grantRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> {
            let mut closure = self.revokeRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> {
            let mut closure = self.listUsers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> {
            let mut closure = self.listRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> {
            let mut closure = self.getUserRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> {
            let mut closure = self.changePassword.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> {
            let mut closure = self.heartBeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::HBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> {
            let mut closure = self.balance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> {
            let mut closure = self.leaderBalance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> {
            let mut closure = self.regConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> {
            let mut closure = self.setConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> {
            let mut closure = self.listConfigs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> {
            let mut closure = self.createSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> {
            let mut closure = self.dropSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> {
            let mut closure = self.listSnapshots.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> {
            let mut closure = self.runAdminJob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> {
            let mut closure = self.addZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> {
            let mut closure = self.dropZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> {
            let mut closure = self.addHostIntoZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> {
            let mut closure = self.dropHostFromZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> {
            let mut closure = self.getZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> {
            let mut closure = self.listZones.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListZonesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> {
            let mut closure = self.addGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> {
            let mut closure = self.dropGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> {
            let mut closure = self.addZoneIntoGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> {
            let mut closure = self.dropZoneFromGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> {
            let mut closure = self.getGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> {
            let mut closure = self.listGroups.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListGroupsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> {
            let mut closure = self.createBackup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateBackupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> {
            let mut closure = self.restoreMeta.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RestoreMetaReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> {
            let mut closure = self.addListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> {
            let mut closure = self.removeListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> {
            let mut closure = self.listListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getStats(
            &self,
            arg_req: &crate::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError>> {
            let mut closure = self.getStats.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetStatsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> {
            let mut closure = self.signInFTService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> {
            let mut closure = self.signOutFTService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> {
            let mut closure = self.listFTClients.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListFTClientsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError>> {
            let mut closure = self.createFTIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateFTIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError>> {
            let mut closure = self.dropFTIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropFTIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError>> {
            let mut closure = self.listFTIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListFTIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> {
            let mut closure = self.createSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError>> {
            let mut closure = self.updateSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> {
            let mut closure = self.listSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> {
            let mut closure = self.getSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> {
            let mut closure = self.removeSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn killQuery(
            &self,
            arg_req: &crate::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError>> {
            let mut closure = self.killQuery.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KillQueryReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> {
            let mut closure = self.reportTaskFinish.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ReportTaskReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listCluster(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError>> {
            let mut closure = self.listCluster.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError>> {
            let mut closure = self.getMetaDirInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetMetaDirInfoReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError>> {
            let mut closure = self.verifyClientVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::VerifyClientVersionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod meta_service {

            pub struct createSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<
                        crate::types::GetSpaceResp,
                        crate::errors::meta_service::GetSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSpaceResp) {
                    self.mock(move |_: crate::types::GetSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> crate::types::GetSpaceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSpaces<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<
                        crate::types::ListSpacesResp,
                        crate::errors::meta_service::ListSpacesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSpaces<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSpacesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSpaces",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSpacesResp) {
                    self.mock(move |_: crate::types::ListSpacesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> crate::types::ListSpacesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSpacesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSpacesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSpaceAs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSpaceAsReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSpaceAsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSpaceAs<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSpaceAsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpaceAs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSpaceAsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceAsReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceAsReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceAsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSpaceAsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSpaceAsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<
                        crate::types::GetTagResp,
                        crate::errors::meta_service::GetTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagResp) {
                    self.mock(move |_: crate::types::GetTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> crate::types::GetTagResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<
                        crate::types::ListTagsResp,
                        crate::errors::meta_service::ListTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTags<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagsResp) {
                    self.mock(move |_: crate::types::ListTagsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> crate::types::ListTagsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<
                        crate::types::GetEdgeResp,
                        crate::errors::meta_service::GetEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeResp) {
                    self.mock(move |_: crate::types::GetEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> crate::types::GetEdgeResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<
                        crate::types::ListEdgesResp,
                        crate::errors::meta_service::ListEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgesResp) {
                    self.mock(move |_: crate::types::ListEdgesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> crate::types::ListEdgesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<
                        crate::types::ListHostsResp,
                        crate::errors::meta_service::ListHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listHosts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListHostsResp) {
                    self.mock(move |_: crate::types::ListHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> crate::types::ListHostsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPartsAlloc<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<
                        crate::types::GetPartsAllocResp,
                        crate::errors::meta_service::GetPartsAllocError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getPartsAlloc<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPartsAllocReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getPartsAlloc",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPartsAllocResp) {
                    self.mock(move |_: crate::types::GetPartsAllocReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> crate::types::GetPartsAllocResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetPartsAllocError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPartsAllocReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<
                        crate::types::ListPartsResp,
                        crate::errors::meta_service::ListPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listParts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListPartsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListPartsResp) {
                    self.mock(move |_: crate::types::ListPartsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> crate::types::ListPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListPartsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiPut<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::MultiPutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> multiPut<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiPutReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiPut",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::MultiPutReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiPutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiPutReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<
                        crate::types::GetResp,
                        crate::errors::meta_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetResp) {
                    self.mock(move |_: crate::types::GetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> crate::types::GetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiGet<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<
                        crate::types::MultiGetResp,
                        crate::errors::meta_service::MultiGetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> multiGet<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiGetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiGet",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::MultiGetResp) {
                    self.mock(move |_: crate::types::MultiGetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> crate::types::MultiGetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiGetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiGetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveRangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scan<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<
                        crate::types::ScanResp,
                        crate::errors::meta_service::ScanError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scan<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "scan",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanResp) {
                    self.mock(move |_: crate::types::ScanReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> crate::types::ScanResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ScanError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<
                        crate::types::GetTagIndexResp,
                        crate::errors::meta_service::GetTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagIndexResp) {
                    self.mock(move |_: crate::types::GetTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> crate::types::GetTagIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<
                        crate::types::ListTagIndexesResp,
                        crate::errors::meta_service::ListTagIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagIndexesResp) {
                    self.mock(move |_: crate::types::ListTagIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> crate::types::ListTagIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListTagIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<
                        crate::types::GetEdgeIndexResp,
                        crate::errors::meta_service::GetEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeIndexResp) {
                    self.mock(move |_: crate::types::GetEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> crate::types::GetEdgeIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<
                        crate::types::ListEdgeIndexesResp,
                        crate::errors::meta_service::ListEdgeIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgeIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgeIndexesResp) {
                    self.mock(move |_: crate::types::ListEdgeIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> crate::types::ListEdgeIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgeIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListEdgeIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct grantRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::GrantRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> grantRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GrantRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "grantRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::GrantRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GrantRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GrantRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct revokeRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RevokeRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> revokeRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RevokeRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "revokeRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RevokeRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RevokeRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RevokeRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listUsers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<
                        crate::types::ListUsersResp,
                        crate::errors::meta_service::ListUsersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listUsers<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListUsersReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listUsers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListUsersResp) {
                    self.mock(move |_: crate::types::ListUsersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> crate::types::ListUsersResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListUsersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListUsersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::ListRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::ListRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUserRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::GetUserRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getUserRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUserRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getUserRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::GetUserRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetUserRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUserRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct changePassword<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ChangePasswordError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> changePassword<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChangePasswordReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "changePassword",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ChangePasswordReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ChangePasswordError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChangePasswordReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct heartBeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<
                        crate::types::HBResp,
                        crate::errors::meta_service::HeartBeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> heartBeat<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::HBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "heartBeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::HBResp) {
                    self.mock(move |_: crate::types::HBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> crate::types::HBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::HeartBeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::HBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct balance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<
                        crate::types::BalanceResp,
                        crate::errors::meta_service::BalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> balance<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "balance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::BalanceResp) {
                    self.mock(move |_: crate::types::BalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> crate::types::BalanceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::BalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct leaderBalance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::LeaderBalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> leaderBalance<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LeaderBalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "leaderBalance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::LeaderBalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::LeaderBalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LeaderBalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct regConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RegConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> regConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RegConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "regConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RegConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RegConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RegConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<
                        crate::types::GetConfigResp,
                        crate::errors::meta_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetConfigResp) {
                    self.mock(move |_: crate::types::GetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> crate::types::GetConfigResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> setConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "setConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listConfigs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<
                        crate::types::ListConfigsResp,
                        crate::errors::meta_service::ListConfigsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listConfigs<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListConfigsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listConfigs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListConfigsResp) {
                    self.mock(move |_: crate::types::ListConfigsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> crate::types::ListConfigsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListConfigsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListConfigsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSnapshots<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<
                        crate::types::ListSnapshotsResp,
                        crate::errors::meta_service::ListSnapshotsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSnapshots<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSnapshotsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSnapshots",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSnapshotsResp) {
                    self.mock(move |_: crate::types::ListSnapshotsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> crate::types::ListSnapshotsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSnapshotsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSnapshotsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct runAdminJob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<
                        crate::types::AdminJobResp,
                        crate::errors::meta_service::RunAdminJobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> runAdminJob<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AdminJobReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "runAdminJob",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminJobResp) {
                    self.mock(move |_: crate::types::AdminJobReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> crate::types::AdminJobResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RunAdminJobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AdminJobReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addHostIntoZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddHostIntoZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addHostIntoZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddHostIntoZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addHostIntoZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddHostIntoZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddHostIntoZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddHostIntoZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropHostFromZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropHostFromZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropHostFromZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropHostFromZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropHostFromZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropHostFromZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropHostFromZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropHostFromZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetZoneReq) -> ::std::result::Result<
                        crate::types::GetZoneResp,
                        crate::errors::meta_service::GetZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetZoneResp) {
                    self.mock(move |_: crate::types::GetZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetZoneReq) -> crate::types::GetZoneResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetZoneReq) -> ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listZones<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListZonesReq) -> ::std::result::Result<
                        crate::types::ListZonesResp,
                        crate::errors::meta_service::ListZonesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listZones<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListZonesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listZones",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListZonesResp) {
                    self.mock(move |_: crate::types::ListZonesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListZonesReq) -> crate::types::ListZonesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListZonesReq) -> ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListZonesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListZonesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addGroup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropGroup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addZoneIntoGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddZoneIntoGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addZoneIntoGroup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddZoneIntoGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addZoneIntoGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddZoneIntoGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddZoneIntoGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddZoneIntoGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropZoneFromGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropZoneFromGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropZoneFromGroup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropZoneFromGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropZoneFromGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropZoneFromGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropZoneFromGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropZoneFromGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetGroupReq) -> ::std::result::Result<
                        crate::types::GetGroupResp,
                        crate::errors::meta_service::GetGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getGroup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetGroupResp) {
                    self.mock(move |_: crate::types::GetGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetGroupReq) -> crate::types::GetGroupResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetGroupReq) -> ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listGroups<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListGroupsReq) -> ::std::result::Result<
                        crate::types::ListGroupsResp,
                        crate::errors::meta_service::ListGroupsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listGroups<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListGroupsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listGroups",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListGroupsResp) {
                    self.mock(move |_: crate::types::ListGroupsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListGroupsReq) -> crate::types::ListGroupsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListGroupsReq) -> ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListGroupsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListGroupsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createBackup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateBackupReq) -> ::std::result::Result<
                        crate::types::CreateBackupResp,
                        crate::errors::meta_service::CreateBackupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createBackup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateBackupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createBackup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::CreateBackupResp) {
                    self.mock(move |_: crate::types::CreateBackupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateBackupReq) -> crate::types::CreateBackupResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateBackupReq) -> ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateBackupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateBackupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct restoreMeta<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RestoreMetaReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RestoreMetaError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> restoreMeta<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RestoreMetaReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "restoreMeta",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RestoreMetaReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RestoreMetaReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RestoreMetaReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RestoreMetaError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RestoreMetaReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddListenerReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddListenerReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddListenerReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveListenerReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveListenerReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveListenerReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListListenerReq) -> ::std::result::Result<
                        crate::types::ListListenerResp,
                        crate::errors::meta_service::ListListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListListenerResp) {
                    self.mock(move |_: crate::types::ListListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListListenerReq) -> crate::types::ListListenerResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListListenerReq) -> ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStats<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetStatsReq) -> ::std::result::Result<
                        crate::types::GetStatsResp,
                        crate::errors::meta_service::GetStatsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getStats<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetStatsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getStats",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetStatsResp) {
                    self.mock(move |_: crate::types::GetStatsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatsReq) -> crate::types::GetStatsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatsReq) -> ::std::result::Result<crate::types::GetStatsResp, crate::errors::meta_service::GetStatsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetStatsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetStatsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signInFTService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SignInFTServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> signInFTService<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SignInFTServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signInFTService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SignInFTServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SignInFTServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SignInFTServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signOutFTService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SignOutFTServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> signOutFTService<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SignOutFTServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signOutFTService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SignOutFTServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SignOutFTServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SignOutFTServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listFTClients<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListFTClientsReq) -> ::std::result::Result<
                        crate::types::ListFTClientsResp,
                        crate::errors::meta_service::ListFTClientsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listFTClients<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListFTClientsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listFTClients",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListFTClientsResp) {
                    self.mock(move |_: crate::types::ListFTClientsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTClientsReq) -> crate::types::ListFTClientsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTClientsReq) -> ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListFTClientsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListFTClientsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createFTIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateFTIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateFTIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createFTIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateFTIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createFTIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateFTIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateFTIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateFTIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateFTIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateFTIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateFTIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropFTIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropFTIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropFTIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropFTIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropFTIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropFTIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropFTIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropFTIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropFTIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropFTIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropFTIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropFTIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listFTIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListFTIndexesReq) -> ::std::result::Result<
                        crate::types::ListFTIndexesResp,
                        crate::errors::meta_service::ListFTIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listFTIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListFTIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listFTIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListFTIndexesResp) {
                    self.mock(move |_: crate::types::ListFTIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTIndexesReq) -> crate::types::ListFTIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTIndexesReq) -> ::std::result::Result<crate::types::ListFTIndexesResp, crate::errors::meta_service::ListFTIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListFTIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListFTIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSessionReq) -> ::std::result::Result<
                        crate::types::CreateSessionResp,
                        crate::errors::meta_service::CreateSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::CreateSessionResp) {
                    self.mock(move |_: crate::types::CreateSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSessionReq) -> crate::types::CreateSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSessionReq) -> ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> ::std::result::Result<
                        crate::types::UpdateSessionsResp,
                        crate::errors::meta_service::UpdateSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateSessions<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "updateSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateSessionsResp) {
                    self.mock(move |_: crate::types::UpdateSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> crate::types::UpdateSessionsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> ::std::result::Result<crate::types::UpdateSessionsResp, crate::errors::meta_service::UpdateSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::UpdateSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSessionsReq) -> ::std::result::Result<
                        crate::types::ListSessionsResp,
                        crate::errors::meta_service::ListSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSessions<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSessionsResp) {
                    self.mock(move |_: crate::types::ListSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSessionsReq) -> crate::types::ListSessionsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSessionsReq) -> ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSessionReq) -> ::std::result::Result<
                        crate::types::GetSessionResp,
                        crate::errors::meta_service::GetSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSessionResp) {
                    self.mock(move |_: crate::types::GetSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSessionReq) -> crate::types::GetSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSessionReq) -> ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveSessionReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveSessionReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveSessionReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct killQuery<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KillQueryReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::KillQueryError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> killQuery<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KillQueryReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "killQuery",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::KillQueryReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KillQueryReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::KillQueryReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::KillQueryError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::KillQueryError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KillQueryReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct reportTaskFinish<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ReportTaskReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ReportTaskFinishError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> reportTaskFinish<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ReportTaskReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "reportTaskFinish",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ReportTaskReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ReportTaskReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ReportTaskReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ReportTaskFinishError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ReportTaskReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listCluster<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> ::std::result::Result<
                        crate::types::ListClusterInfoResp,
                        crate::errors::meta_service::ListClusterError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listCluster<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListClusterInfoReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listCluster",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListClusterInfoResp) {
                    self.mock(move |_: crate::types::ListClusterInfoReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> crate::types::ListClusterInfoResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::meta_service::ListClusterError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListClusterError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListClusterInfoReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getMetaDirInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetMetaDirInfoReq) -> ::std::result::Result<
                        crate::types::GetMetaDirInfoResp,
                        crate::errors::meta_service::GetMetaDirInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getMetaDirInfo<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetMetaDirInfoReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getMetaDirInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetMetaDirInfoResp) {
                    self.mock(move |_: crate::types::GetMetaDirInfoReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetMetaDirInfoReq) -> crate::types::GetMetaDirInfoResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetMetaDirInfoReq) -> ::std::result::Result<crate::types::GetMetaDirInfoResp, crate::errors::meta_service::GetMetaDirInfoError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetMetaDirInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetMetaDirInfoReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct verifyClientVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::VerifyClientVersionReq) -> ::std::result::Result<
                        crate::types::VerifyClientVersionResp,
                        crate::errors::meta_service::VerifyClientVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> verifyClientVersion<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::VerifyClientVersionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "verifyClientVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::VerifyClientVersionResp) {
                    self.mock(move |_: crate::types::VerifyClientVersionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::VerifyClientVersionReq) -> crate::types::VerifyClientVersionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::VerifyClientVersionReq) -> ::std::result::Result<crate::types::VerifyClientVersionResp, crate::errors::meta_service::VerifyClientVersionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::VerifyClientVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::VerifyClientVersionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for MetaService functions.
    pub mod meta_service {

        pub type CreateSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSpaceExn> for
            ::std::result::Result<crate::types::ExecResp, CreateSpaceError>
        {
            fn from(e: crate::services::meta_service::CreateSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropSpaceExn> for
            ::std::result::Result<crate::types::ExecResp, DropSpaceError>
        {
            fn from(e: crate::services::meta_service::DropSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::DropSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSpaceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetSpaceExn> for
            ::std::result::Result<crate::types::GetSpaceResp, GetSpaceError>
        {
            fn from(e: crate::services::meta_service::GetSpaceExn) -> Self {
                match e {
                    crate::services::meta_service::GetSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSpacesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListSpacesExn> for
            ::std::result::Result<crate::types::ListSpacesResp, ListSpacesError>
        {
            fn from(e: crate::services::meta_service::ListSpacesExn) -> Self {
                match e {
                    crate::services::meta_service::ListSpacesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListSpacesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSpacesError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSpaceAsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSpaceAsExn> for
            ::std::result::Result<crate::types::ExecResp, CreateSpaceAsError>
        {
            fn from(e: crate::services::meta_service::CreateSpaceAsExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSpaceAsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSpaceAsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSpaceAsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateTagExn> for
            ::std::result::Result<crate::types::ExecResp, CreateTagError>
        {
            fn from(e: crate::services::meta_service::CreateTagExn) -> Self {
                match e {
                    crate::services::meta_service::CreateTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterTagExn> for
            ::std::result::Result<crate::types::ExecResp, AlterTagError>
        {
            fn from(e: crate::services::meta_service::AlterTagExn) -> Self {
                match e {
                    crate::services::meta_service::AlterTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropTagExn> for
            ::std::result::Result<crate::types::ExecResp, DropTagError>
        {
            fn from(e: crate::services::meta_service::DropTagExn) -> Self {
                match e {
                    crate::services::meta_service::DropTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetTagExn> for
            ::std::result::Result<crate::types::GetTagResp, GetTagError>
        {
            fn from(e: crate::services::meta_service::GetTagExn) -> Self {
                match e {
                    crate::services::meta_service::GetTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagsExn> for
            ::std::result::Result<crate::types::ListTagsResp, ListTagsError>
        {
            fn from(e: crate::services::meta_service::ListTagsExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, CreateEdgeError>
        {
            fn from(e: crate::services::meta_service::CreateEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::CreateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, AlterEdgeError>
        {
            fn from(e: crate::services::meta_service::AlterEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::AlterEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropEdgeExn> for
            ::std::result::Result<crate::types::ExecResp, DropEdgeError>
        {
            fn from(e: crate::services::meta_service::DropEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::DropEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetEdgeExn> for
            ::std::result::Result<crate::types::GetEdgeResp, GetEdgeError>
        {
            fn from(e: crate::services::meta_service::GetEdgeExn) -> Self {
                match e {
                    crate::services::meta_service::GetEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgesExn> for
            ::std::result::Result<crate::types::ListEdgesResp, ListEdgesError>
        {
            fn from(e: crate::services::meta_service::ListEdgesExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListHostsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListHostsExn> for
            ::std::result::Result<crate::types::ListHostsResp, ListHostsError>
        {
            fn from(e: crate::services::meta_service::ListHostsExn) -> Self {
                match e {
                    crate::services::meta_service::ListHostsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListHostsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListHostsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetPartsAllocError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetPartsAllocExn> for
            ::std::result::Result<crate::types::GetPartsAllocResp, GetPartsAllocError>
        {
            fn from(e: crate::services::meta_service::GetPartsAllocExn) -> Self {
                match e {
                    crate::services::meta_service::GetPartsAllocExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPartsAllocError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListPartsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListPartsExn> for
            ::std::result::Result<crate::types::ListPartsResp, ListPartsError>
        {
            fn from(e: crate::services::meta_service::ListPartsExn) -> Self {
                match e {
                    crate::services::meta_service::ListPartsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListPartsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListPartsError::ApplicationException(aexn)),
                }
            }
        }

        pub type MultiPutError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::MultiPutExn> for
            ::std::result::Result<crate::types::ExecResp, MultiPutError>
        {
            fn from(e: crate::services::meta_service::MultiPutExn) -> Self {
                match e {
                    crate::services::meta_service::MultiPutExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::MultiPutExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MultiPutError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetExn> for
            ::std::result::Result<crate::types::GetResp, GetError>
        {
            fn from(e: crate::services::meta_service::GetExn) -> Self {
                match e {
                    crate::services::meta_service::GetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetError::ApplicationException(aexn)),
                }
            }
        }

        pub type MultiGetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::MultiGetExn> for
            ::std::result::Result<crate::types::MultiGetResp, MultiGetError>
        {
            fn from(e: crate::services::meta_service::MultiGetExn) -> Self {
                match e {
                    crate::services::meta_service::MultiGetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::MultiGetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MultiGetError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveError>
        {
            fn from(e: crate::services::meta_service::RemoveExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveRangeExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveRangeError>
        {
            fn from(e: crate::services::meta_service::RemoveRangeExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveRangeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveRangeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ScanExn> for
            ::std::result::Result<crate::types::ScanResp, ScanError>
        {
            fn from(e: crate::services::meta_service::ScanExn) -> Self {
                match e {
                    crate::services::meta_service::ScanExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ScanExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, CreateTagIndexError>
        {
            fn from(e: crate::services::meta_service::CreateTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::CreateTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, DropTagIndexError>
        {
            fn from(e: crate::services::meta_service::DropTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::DropTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetTagIndexExn> for
            ::std::result::Result<crate::types::GetTagIndexResp, GetTagIndexError>
        {
            fn from(e: crate::services::meta_service::GetTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::GetTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagIndexesExn> for
            ::std::result::Result<crate::types::ListTagIndexesResp, ListTagIndexesError>
        {
            fn from(e: crate::services::meta_service::ListTagIndexesExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RebuildTagIndexExn> for
            ::std::result::Result<crate::types::ExecResp, RebuildTagIndexError>
        {
            fn from(e: crate::services::meta_service::RebuildTagIndexExn) -> Self {
                match e {
                    crate::services::meta_service::RebuildTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListTagIndexStatusExn> for
            ::std::result::Result<crate::types::ListIndexStatusResp, ListTagIndexStatusError>
        {
            fn from(e: crate::services::meta_service::ListTagIndexStatusExn) -> Self {
                match e {
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, CreateEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::CreateEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, DropEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::DropEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::DropEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetEdgeIndexExn> for
            ::std::result::Result<crate::types::GetEdgeIndexResp, GetEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::GetEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::GetEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgeIndexesExn> for
            ::std::result::Result<crate::types::ListEdgeIndexesResp, ListEdgeIndexesError>
        {
            fn from(e: crate::services::meta_service::ListEdgeIndexesExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RebuildEdgeIndexExn> for
            ::std::result::Result<crate::types::ExecResp, RebuildEdgeIndexError>
        {
            fn from(e: crate::services::meta_service::RebuildEdgeIndexExn) -> Self {
                match e {
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListEdgeIndexStatusExn> for
            ::std::result::Result<crate::types::ListIndexStatusResp, ListEdgeIndexStatusError>
        {
            fn from(e: crate::services::meta_service::ListEdgeIndexStatusExn) -> Self {
                match e {
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateUserExn> for
            ::std::result::Result<crate::types::ExecResp, CreateUserError>
        {
            fn from(e: crate::services::meta_service::CreateUserExn) -> Self {
                match e {
                    crate::services::meta_service::CreateUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropUserExn> for
            ::std::result::Result<crate::types::ExecResp, DropUserError>
        {
            fn from(e: crate::services::meta_service::DropUserExn) -> Self {
                match e {
                    crate::services::meta_service::DropUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterUserError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AlterUserExn> for
            ::std::result::Result<crate::types::ExecResp, AlterUserError>
        {
            fn from(e: crate::services::meta_service::AlterUserExn) -> Self {
                match e {
                    crate::services::meta_service::AlterUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AlterUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type GrantRoleError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GrantRoleExn> for
            ::std::result::Result<crate::types::ExecResp, GrantRoleError>
        {
            fn from(e: crate::services::meta_service::GrantRoleExn) -> Self {
                match e {
                    crate::services::meta_service::GrantRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GrantRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GrantRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type RevokeRoleError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RevokeRoleExn> for
            ::std::result::Result<crate::types::ExecResp, RevokeRoleError>
        {
            fn from(e: crate::services::meta_service::RevokeRoleExn) -> Self {
                match e {
                    crate::services::meta_service::RevokeRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RevokeRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListUsersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListUsersExn> for
            ::std::result::Result<crate::types::ListUsersResp, ListUsersError>
        {
            fn from(e: crate::services::meta_service::ListUsersExn) -> Self {
                match e {
                    crate::services::meta_service::ListUsersExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListUsersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListUsersError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListRolesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListRolesExn> for
            ::std::result::Result<crate::types::ListRolesResp, ListRolesError>
        {
            fn from(e: crate::services::meta_service::ListRolesExn) -> Self {
                match e {
                    crate::services::meta_service::ListRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetUserRolesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetUserRolesExn> for
            ::std::result::Result<crate::types::ListRolesResp, GetUserRolesError>
        {
            fn from(e: crate::services::meta_service::GetUserRolesExn) -> Self {
                match e {
                    crate::services::meta_service::GetUserRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetUserRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChangePasswordError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ChangePasswordExn> for
            ::std::result::Result<crate::types::ExecResp, ChangePasswordError>
        {
            fn from(e: crate::services::meta_service::ChangePasswordExn) -> Self {
                match e {
                    crate::services::meta_service::ChangePasswordExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChangePasswordError::ApplicationException(aexn)),
                }
            }
        }

        pub type HeartBeatError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::HeartBeatExn> for
            ::std::result::Result<crate::types::HBResp, HeartBeatError>
        {
            fn from(e: crate::services::meta_service::HeartBeatExn) -> Self {
                match e {
                    crate::services::meta_service::HeartBeatExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::HeartBeatExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(HeartBeatError::ApplicationException(aexn)),
                }
            }
        }

        pub type BalanceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::BalanceExn> for
            ::std::result::Result<crate::types::BalanceResp, BalanceError>
        {
            fn from(e: crate::services::meta_service::BalanceExn) -> Self {
                match e {
                    crate::services::meta_service::BalanceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::BalanceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(BalanceError::ApplicationException(aexn)),
                }
            }
        }

        pub type LeaderBalanceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::LeaderBalanceExn> for
            ::std::result::Result<crate::types::ExecResp, LeaderBalanceError>
        {
            fn from(e: crate::services::meta_service::LeaderBalanceExn) -> Self {
                match e {
                    crate::services::meta_service::LeaderBalanceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(LeaderBalanceError::ApplicationException(aexn)),
                }
            }
        }

        pub type RegConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RegConfigExn> for
            ::std::result::Result<crate::types::ExecResp, RegConfigError>
        {
            fn from(e: crate::services::meta_service::RegConfigExn) -> Self {
                match e {
                    crate::services::meta_service::RegConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RegConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RegConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetConfigExn> for
            ::std::result::Result<crate::types::GetConfigResp, GetConfigError>
        {
            fn from(e: crate::services::meta_service::GetConfigExn) -> Self {
                match e {
                    crate::services::meta_service::GetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type SetConfigError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::SetConfigExn> for
            ::std::result::Result<crate::types::ExecResp, SetConfigError>
        {
            fn from(e: crate::services::meta_service::SetConfigExn) -> Self {
                match e {
                    crate::services::meta_service::SetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::SetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListConfigsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListConfigsExn> for
            ::std::result::Result<crate::types::ListConfigsResp, ListConfigsError>
        {
            fn from(e: crate::services::meta_service::ListConfigsExn) -> Self {
                match e {
                    crate::services::meta_service::ListConfigsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListConfigsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListConfigsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSnapshotError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSnapshotExn> for
            ::std::result::Result<crate::types::ExecResp, CreateSnapshotError>
        {
            fn from(e: crate::services::meta_service::CreateSnapshotExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSnapshotError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropSnapshotExn> for
            ::std::result::Result<crate::types::ExecResp, DropSnapshotError>
        {
            fn from(e: crate::services::meta_service::DropSnapshotExn) -> Self {
                match e {
                    crate::services::meta_service::DropSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSnapshotsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListSnapshotsExn> for
            ::std::result::Result<crate::types::ListSnapshotsResp, ListSnapshotsError>
        {
            fn from(e: crate::services::meta_service::ListSnapshotsExn) -> Self {
                match e {
                    crate::services::meta_service::ListSnapshotsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSnapshotsError::ApplicationException(aexn)),
                }
            }
        }

        pub type RunAdminJobError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RunAdminJobExn> for
            ::std::result::Result<crate::types::AdminJobResp, RunAdminJobError>
        {
            fn from(e: crate::services::meta_service::RunAdminJobExn) -> Self {
                match e {
                    crate::services::meta_service::RunAdminJobExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RunAdminJobError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddZoneError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AddZoneExn> for
            ::std::result::Result<crate::types::ExecResp, AddZoneError>
        {
            fn from(e: crate::services::meta_service::AddZoneExn) -> Self {
                match e {
                    crate::services::meta_service::AddZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AddZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropZoneError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropZoneExn> for
            ::std::result::Result<crate::types::ExecResp, DropZoneError>
        {
            fn from(e: crate::services::meta_service::DropZoneExn) -> Self {
                match e {
                    crate::services::meta_service::DropZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddHostIntoZoneError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AddHostIntoZoneExn> for
            ::std::result::Result<crate::types::ExecResp, AddHostIntoZoneError>
        {
            fn from(e: crate::services::meta_service::AddHostIntoZoneExn) -> Self {
                match e {
                    crate::services::meta_service::AddHostIntoZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddHostIntoZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropHostFromZoneError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropHostFromZoneExn> for
            ::std::result::Result<crate::types::ExecResp, DropHostFromZoneError>
        {
            fn from(e: crate::services::meta_service::DropHostFromZoneExn) -> Self {
                match e {
                    crate::services::meta_service::DropHostFromZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropHostFromZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropHostFromZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetZoneError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetZoneExn> for
            ::std::result::Result<crate::types::GetZoneResp, GetZoneError>
        {
            fn from(e: crate::services::meta_service::GetZoneExn) -> Self {
                match e {
                    crate::services::meta_service::GetZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListZonesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListZonesExn> for
            ::std::result::Result<crate::types::ListZonesResp, ListZonesError>
        {
            fn from(e: crate::services::meta_service::ListZonesExn) -> Self {
                match e {
                    crate::services::meta_service::ListZonesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListZonesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListZonesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddGroupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AddGroupExn> for
            ::std::result::Result<crate::types::ExecResp, AddGroupError>
        {
            fn from(e: crate::services::meta_service::AddGroupExn) -> Self {
                match e {
                    crate::services::meta_service::AddGroupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AddGroupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddGroupError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropGroupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropGroupExn> for
            ::std::result::Result<crate::types::ExecResp, DropGroupError>
        {
            fn from(e: crate::services::meta_service::DropGroupExn) -> Self {
                match e {
                    crate::services::meta_service::DropGroupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropGroupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropGroupError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddZoneIntoGroupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AddZoneIntoGroupExn> for
            ::std::result::Result<crate::types::ExecResp, AddZoneIntoGroupError>
        {
            fn from(e: crate::services::meta_service::AddZoneIntoGroupExn) -> Self {
                match e {
                    crate::services::meta_service::AddZoneIntoGroupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddZoneIntoGroupError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropZoneFromGroupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropZoneFromGroupExn> for
            ::std::result::Result<crate::types::ExecResp, DropZoneFromGroupError>
        {
            fn from(e: crate::services::meta_service::DropZoneFromGroupExn) -> Self {
                match e {
                    crate::services::meta_service::DropZoneFromGroupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropZoneFromGroupError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetGroupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetGroupExn> for
            ::std::result::Result<crate::types::GetGroupResp, GetGroupError>
        {
            fn from(e: crate::services::meta_service::GetGroupExn) -> Self {
                match e {
                    crate::services::meta_service::GetGroupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetGroupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetGroupError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListGroupsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListGroupsExn> for
            ::std::result::Result<crate::types::ListGroupsResp, ListGroupsError>
        {
            fn from(e: crate::services::meta_service::ListGroupsExn) -> Self {
                match e {
                    crate::services::meta_service::ListGroupsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListGroupsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListGroupsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateBackupError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateBackupExn> for
            ::std::result::Result<crate::types::CreateBackupResp, CreateBackupError>
        {
            fn from(e: crate::services::meta_service::CreateBackupExn) -> Self {
                match e {
                    crate::services::meta_service::CreateBackupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateBackupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateBackupError::ApplicationException(aexn)),
                }
            }
        }

        pub type RestoreMetaError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RestoreMetaExn> for
            ::std::result::Result<crate::types::ExecResp, RestoreMetaError>
        {
            fn from(e: crate::services::meta_service::RestoreMetaExn) -> Self {
                match e {
                    crate::services::meta_service::RestoreMetaExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RestoreMetaExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RestoreMetaError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddListenerError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::AddListenerExn> for
            ::std::result::Result<crate::types::ExecResp, AddListenerError>
        {
            fn from(e: crate::services::meta_service::AddListenerExn) -> Self {
                match e {
                    crate::services::meta_service::AddListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::AddListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveListenerError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveListenerExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveListenerError>
        {
            fn from(e: crate::services::meta_service::RemoveListenerExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListListenerError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListListenerExn> for
            ::std::result::Result<crate::types::ListListenerResp, ListListenerError>
        {
            fn from(e: crate::services::meta_service::ListListenerExn) -> Self {
                match e {
                    crate::services::meta_service::ListListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetStatsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetStatsExn> for
            ::std::result::Result<crate::types::GetStatsResp, GetStatsError>
        {
            fn from(e: crate::services::meta_service::GetStatsExn) -> Self {
                match e {
                    crate::services::meta_service::GetStatsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetStatsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetStatsError::ApplicationException(aexn)),
                }
            }
        }

        pub type SignInFTServiceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::SignInFTServiceExn> for
            ::std::result::Result<crate::types::ExecResp, SignInFTServiceError>
        {
            fn from(e: crate::services::meta_service::SignInFTServiceExn) -> Self {
                match e {
                    crate::services::meta_service::SignInFTServiceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::SignInFTServiceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SignInFTServiceError::ApplicationException(aexn)),
                }
            }
        }

        pub type SignOutFTServiceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::SignOutFTServiceExn> for
            ::std::result::Result<crate::types::ExecResp, SignOutFTServiceError>
        {
            fn from(e: crate::services::meta_service::SignOutFTServiceExn) -> Self {
                match e {
                    crate::services::meta_service::SignOutFTServiceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::SignOutFTServiceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SignOutFTServiceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListFTClientsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListFTClientsExn> for
            ::std::result::Result<crate::types::ListFTClientsResp, ListFTClientsError>
        {
            fn from(e: crate::services::meta_service::ListFTClientsExn) -> Self {
                match e {
                    crate::services::meta_service::ListFTClientsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListFTClientsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListFTClientsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateFTIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateFTIndexExn> for
            ::std::result::Result<crate::types::ExecResp, CreateFTIndexError>
        {
            fn from(e: crate::services::meta_service::CreateFTIndexExn) -> Self {
                match e {
                    crate::services::meta_service::CreateFTIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateFTIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateFTIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropFTIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::DropFTIndexExn> for
            ::std::result::Result<crate::types::ExecResp, DropFTIndexError>
        {
            fn from(e: crate::services::meta_service::DropFTIndexExn) -> Self {
                match e {
                    crate::services::meta_service::DropFTIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::DropFTIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropFTIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListFTIndexesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListFTIndexesExn> for
            ::std::result::Result<crate::types::ListFTIndexesResp, ListFTIndexesError>
        {
            fn from(e: crate::services::meta_service::ListFTIndexesExn) -> Self {
                match e {
                    crate::services::meta_service::ListFTIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListFTIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListFTIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSessionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::CreateSessionExn> for
            ::std::result::Result<crate::types::CreateSessionResp, CreateSessionError>
        {
            fn from(e: crate::services::meta_service::CreateSessionExn) -> Self {
                match e {
                    crate::services::meta_service::CreateSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::CreateSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateSessionsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::UpdateSessionsExn> for
            ::std::result::Result<crate::types::UpdateSessionsResp, UpdateSessionsError>
        {
            fn from(e: crate::services::meta_service::UpdateSessionsExn) -> Self {
                match e {
                    crate::services::meta_service::UpdateSessionsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::UpdateSessionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateSessionsError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSessionsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListSessionsExn> for
            ::std::result::Result<crate::types::ListSessionsResp, ListSessionsError>
        {
            fn from(e: crate::services::meta_service::ListSessionsExn) -> Self {
                match e {
                    crate::services::meta_service::ListSessionsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListSessionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSessionsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSessionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetSessionExn> for
            ::std::result::Result<crate::types::GetSessionResp, GetSessionError>
        {
            fn from(e: crate::services::meta_service::GetSessionExn) -> Self {
                match e {
                    crate::services::meta_service::GetSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveSessionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::RemoveSessionExn> for
            ::std::result::Result<crate::types::ExecResp, RemoveSessionError>
        {
            fn from(e: crate::services::meta_service::RemoveSessionExn) -> Self {
                match e {
                    crate::services::meta_service::RemoveSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::RemoveSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type KillQueryError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::KillQueryExn> for
            ::std::result::Result<crate::types::ExecResp, KillQueryError>
        {
            fn from(e: crate::services::meta_service::KillQueryExn) -> Self {
                match e {
                    crate::services::meta_service::KillQueryExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::KillQueryExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(KillQueryError::ApplicationException(aexn)),
                }
            }
        }

        pub type ReportTaskFinishError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ReportTaskFinishExn> for
            ::std::result::Result<crate::types::ExecResp, ReportTaskFinishError>
        {
            fn from(e: crate::services::meta_service::ReportTaskFinishExn) -> Self {
                match e {
                    crate::services::meta_service::ReportTaskFinishExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ReportTaskFinishExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ReportTaskFinishError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListClusterError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::ListClusterExn> for
            ::std::result::Result<crate::types::ListClusterInfoResp, ListClusterError>
        {
            fn from(e: crate::services::meta_service::ListClusterExn) -> Self {
                match e {
                    crate::services::meta_service::ListClusterExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::ListClusterExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListClusterError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetMetaDirInfoError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::GetMetaDirInfoExn> for
            ::std::result::Result<crate::types::GetMetaDirInfoResp, GetMetaDirInfoError>
        {
            fn from(e: crate::services::meta_service::GetMetaDirInfoExn) -> Self {
                match e {
                    crate::services::meta_service::GetMetaDirInfoExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::GetMetaDirInfoExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetMetaDirInfoError::ApplicationException(aexn)),
                }
            }
        }

        pub type VerifyClientVersionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::meta_service::VerifyClientVersionExn> for
            ::std::result::Result<crate::types::VerifyClientVersionResp, VerifyClientVersionError>
        {
            fn from(e: crate::services::meta_service::VerifyClientVersionExn) -> Self {
                match e {
                    crate::services::meta_service::VerifyClientVersionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::meta_service::VerifyClientVersionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(VerifyClientVersionError::ApplicationException(aexn)),
                }
            }
        }

    }

}
