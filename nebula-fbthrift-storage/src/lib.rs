// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum EntryId {
        tag_id(common::types::TagID),
        edge_type(common::types::EdgeType),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PropDef {
        pub owner: crate::types::PropOwner,
        pub id: crate::types::EntryId,
        pub name: ::std::string::String,
        pub stat: crate::types::StatType,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ResultCode {
        pub code: crate::types::ErrorCode,
        pub part_id: common::types::PartitionID,
        pub leader: ::std::option::Option<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct EdgeKey {
        pub src: common::types::VertexID,
        pub edge_type: common::types::EdgeType,
        pub ranking: common::types::EdgeRanking,
        pub dst: common::types::VertexID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Edge {
        pub key: crate::types::EdgeKey,
        pub props: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct IdAndProp {
        pub dst: common::types::VertexID,
        pub props: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdgeData {
        pub type_: common::types::EdgeType,
        pub edges: ::std::vec::Vec<crate::types::IdAndProp>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct TagData {
        pub tag_id: common::types::TagID,
        pub data: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct VertexData {
        pub vertex_id: common::types::VertexID,
        pub tag_data: ::std::vec::Vec<crate::types::TagData>,
        pub edge_data: ::std::vec::Vec<crate::types::EdgeData>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct VertexIndexData {
        pub vertex_id: common::types::VertexID,
        pub props: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ResponseCommon {
        pub failed_codes: ::std::vec::Vec<crate::types::ResultCode>,
        pub latency_in_us: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct QueryResponse {
        pub result: crate::types::ResponseCommon,
        pub vertex_schema: ::std::option::Option<::std::collections::BTreeMap<common::types::TagID, common::types::Schema>>,
        pub edge_schema: ::std::option::Option<::std::collections::BTreeMap<common::types::EdgeType, common::types::Schema>>,
        pub vertices: ::std::option::Option<::std::vec::Vec<crate::types::VertexData>>,
        pub total_edges: ::std::option::Option<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ExecResponse {
        pub result: crate::types::ResponseCommon,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdgePropResponse {
        pub result: crate::types::ResponseCommon,
        pub schema: ::std::option::Option<common::types::Schema>,
        pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct QueryStatsResponse {
        pub result: crate::types::ResponseCommon,
        pub schema: ::std::option::Option<common::types::Schema>,
        pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Tag {
        pub tag_id: common::types::TagID,
        pub props: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Vertex {
        pub id: common::types::VertexID,
        pub tags: ::std::vec::Vec<crate::types::Tag>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetNeighborsRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
        pub edge_types: ::std::vec::Vec<common::types::EdgeType>,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct VertexPropRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
        pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdgePropRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
        pub edge_type: common::types::EdgeType,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub return_columns: ::std::vec::Vec<crate::types::PropDef>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddVerticesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Vertex>>,
        pub overwritable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddEdgesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Edge>>,
        pub overwritable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DeleteVerticesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DeleteEdgesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminExecResp {
        pub result: crate::types::ResponseCommon,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddPartReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub as_learner: ::std::primitive::bool,
        pub peers: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemovePartReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MemberChangeReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub peer: common::types::HostAddr,
        pub add: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TransLeaderReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub new_leader: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddLearnerReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub learner: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CatchUpDataReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub target: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CheckPeersReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub peers: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetLeaderReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetLeaderResp {
        pub result: crate::types::ResponseCommon,
        pub leader_parts: ::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateResponse {
        pub result: crate::types::ResponseCommon,
        pub schema: ::std::option::Option<common::types::Schema>,
        pub data: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub upsert: ::std::option::Option<::std::primitive::bool>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct UpdateItem {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub prop: ::std::vec::Vec<::std::primitive::u8>,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateVertexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub vertex_id: common::types::VertexID,
        pub part_id: common::types::PartitionID,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub update_items: ::std::vec::Vec<crate::types::UpdateItem>,
        pub return_columns: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub insertable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateEdgeRequest {
        pub space_id: common::types::GraphSpaceID,
        pub edge_key: crate::types::EdgeKey,
        pub part_id: common::types::PartitionID,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub update_items: ::std::vec::Vec<crate::types::UpdateItem>,
        pub return_columns: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub insertable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanEdgeRequest {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub cursor: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub return_columns: ::std::collections::BTreeMap<common::types::EdgeType, ::std::vec::Vec<crate::types::PropDef>>,
        pub all_columns: ::std::primitive::bool,
        pub limit: ::std::primitive::i32,
        pub start_time: ::std::primitive::i64,
        pub end_time: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanEdgeResponse {
        pub result: crate::types::ResponseCommon,
        pub edge_schema: ::std::collections::BTreeMap<common::types::EdgeType, common::types::Schema>,
        pub edge_data: ::std::vec::Vec<crate::types::ScanEdge>,
        pub has_next: ::std::primitive::bool,
        pub next_cursor: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScanEdge {
        pub src: common::types::VertexID,
        pub type_: common::types::EdgeType,
        pub dst: common::types::VertexID,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanVertexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub cursor: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub return_columns: ::std::collections::BTreeMap<common::types::TagID, ::std::vec::Vec<crate::types::PropDef>>,
        pub all_columns: ::std::primitive::bool,
        pub limit: ::std::primitive::i32,
        pub start_time: ::std::primitive::i64,
        pub end_time: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScanVertex {
        pub vertexId: common::types::VertexID,
        pub tagId: common::types::TagID,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanVertexResponse {
        pub result: crate::types::ResponseCommon,
        pub vertex_schema: ::std::collections::BTreeMap<common::types::TagID, common::types::Schema>,
        pub vertex_data: ::std::vec::Vec<crate::types::ScanVertex>,
        pub has_next: ::std::primitive::bool,
        pub next_cursor: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PutRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Pair>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RemoveRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::string::String>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RemoveRangeRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Pair>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::string::String>>,
        pub return_partly: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PrefixRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, common::types::Pair>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GeneralResponse {
        pub result: crate::types::ResponseCommon,
        pub values: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetUUIDReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetUUIDResp {
        pub result: crate::types::ResponseCommon,
        pub id: common::types::VertexID,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct BlockingSignRequest {
        pub space_id: common::types::GraphSpaceID,
        pub sign: crate::types::EngineSignType,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateCPRequest {
        pub space_id: common::types::GraphSpaceID,
        pub name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropCPRequest {
        pub space_id: common::types::GraphSpaceID,
        pub name: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RebuildIndexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::vec::Vec<common::types::PartitionID>,
        pub index_id: common::types::IndexID,
        pub is_offline: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LookUpIndexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::vec::Vec<common::types::PartitionID>,
        pub index_id: common::types::IndexID,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub return_columns: ::std::vec::Vec<::std::string::String>,
        pub is_edge: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct LookUpIndexResp {
        pub result: crate::types::ResponseCommon,
        pub schema: ::std::option::Option<common::types::Schema>,
        pub vertices: ::std::option::Option<::std::vec::Vec<crate::types::VertexIndexData>>,
        pub edges: ::std::option::Option<::std::vec::Vec<crate::types::Edge>>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ErrorCode(pub ::std::primitive::i32);

    impl ErrorCode {
        pub const SUCCEEDED: Self = ErrorCode(0i32);
        pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
        pub const E_FAILED_TO_CONNECT: Self = ErrorCode(-2i32);
        pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
        pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
        pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-12i32);
        pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-13i32);
        pub const E_PART_NOT_FOUND: Self = ErrorCode(-14i32);
        pub const E_KEY_NOT_FOUND: Self = ErrorCode(-15i32);
        pub const E_CONSENSUS_ERROR: Self = ErrorCode(-16i32);
        pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-21i32);
        pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-22i32);
        pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-23i32);
        pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-24i32);
        pub const E_TAG_NOT_FOUND: Self = ErrorCode(-25i32);
        pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-26i32);
        pub const E_INVALID_FILTER: Self = ErrorCode(-31i32);
        pub const E_INVALID_UPDATER: Self = ErrorCode(-32i32);
        pub const E_INVALID_STORE: Self = ErrorCode(-33i32);
        pub const E_INVALID_PEER: Self = ErrorCode(-34i32);
        pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-35i32);
        pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-36i32);
        pub const E_LOAD_META_FAILED: Self = ErrorCode(-41i32);
        pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-50i32);
        pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-51i32);
        pub const E_FILTER_OUT: Self = ErrorCode(-60i32);
        pub const E_PARTIAL_RESULT: Self = ErrorCode(-99i32);
        pub const E_UNKNOWN: Self = ErrorCode(-100i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "E_DISCONNECTED",
                "E_FAILED_TO_CONNECT",
                "E_RPC_FAILURE",
                "E_LEADER_CHANGED",
                "E_KEY_HAS_EXISTS",
                "E_SPACE_NOT_FOUND",
                "E_PART_NOT_FOUND",
                "E_KEY_NOT_FOUND",
                "E_CONSENSUS_ERROR",
                "E_EDGE_PROP_NOT_FOUND",
                "E_TAG_PROP_NOT_FOUND",
                "E_IMPROPER_DATA_TYPE",
                "E_EDGE_NOT_FOUND",
                "E_TAG_NOT_FOUND",
                "E_INDEX_NOT_FOUND",
                "E_INVALID_FILTER",
                "E_INVALID_UPDATER",
                "E_INVALID_STORE",
                "E_INVALID_PEER",
                "E_RETRY_EXHAUSTED",
                "E_TRANSFER_LEADER_FAILED",
                "E_LOAD_META_FAILED",
                "E_FAILED_TO_CHECKPOINT",
                "E_CHECKPOINT_BLOCKED",
                "E_FILTER_OUT",
                "E_PARTIAL_RESULT",
                "E_UNKNOWN",
            ]
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ErrorCode::SUCCEEDED => "SUCCEEDED",
                ErrorCode::E_DISCONNECTED => "E_DISCONNECTED",
                ErrorCode::E_FAILED_TO_CONNECT => "E_FAILED_TO_CONNECT",
                ErrorCode::E_RPC_FAILURE => "E_RPC_FAILURE",
                ErrorCode::E_LEADER_CHANGED => "E_LEADER_CHANGED",
                ErrorCode::E_KEY_HAS_EXISTS => "E_KEY_HAS_EXISTS",
                ErrorCode::E_SPACE_NOT_FOUND => "E_SPACE_NOT_FOUND",
                ErrorCode::E_PART_NOT_FOUND => "E_PART_NOT_FOUND",
                ErrorCode::E_KEY_NOT_FOUND => "E_KEY_NOT_FOUND",
                ErrorCode::E_CONSENSUS_ERROR => "E_CONSENSUS_ERROR",
                ErrorCode::E_EDGE_PROP_NOT_FOUND => "E_EDGE_PROP_NOT_FOUND",
                ErrorCode::E_TAG_PROP_NOT_FOUND => "E_TAG_PROP_NOT_FOUND",
                ErrorCode::E_IMPROPER_DATA_TYPE => "E_IMPROPER_DATA_TYPE",
                ErrorCode::E_EDGE_NOT_FOUND => "E_EDGE_NOT_FOUND",
                ErrorCode::E_TAG_NOT_FOUND => "E_TAG_NOT_FOUND",
                ErrorCode::E_INDEX_NOT_FOUND => "E_INDEX_NOT_FOUND",
                ErrorCode::E_INVALID_FILTER => "E_INVALID_FILTER",
                ErrorCode::E_INVALID_UPDATER => "E_INVALID_UPDATER",
                ErrorCode::E_INVALID_STORE => "E_INVALID_STORE",
                ErrorCode::E_INVALID_PEER => "E_INVALID_PEER",
                ErrorCode::E_RETRY_EXHAUSTED => "E_RETRY_EXHAUSTED",
                ErrorCode::E_TRANSFER_LEADER_FAILED => "E_TRANSFER_LEADER_FAILED",
                ErrorCode::E_LOAD_META_FAILED => "E_LOAD_META_FAILED",
                ErrorCode::E_FAILED_TO_CHECKPOINT => "E_FAILED_TO_CHECKPOINT",
                ErrorCode::E_CHECKPOINT_BLOCKED => "E_CHECKPOINT_BLOCKED",
                ErrorCode::E_FILTER_OUT => "E_FILTER_OUT",
                ErrorCode::E_PARTIAL_RESULT => "E_PARTIAL_RESULT",
                ErrorCode::E_UNKNOWN => "E_UNKNOWN",
                ErrorCode(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ErrorCode::{}", self)
        }
    }

    impl ::std::str::FromStr for ErrorCode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "SUCCEEDED" => ::std::result::Result::Ok(ErrorCode::SUCCEEDED),
                "E_DISCONNECTED" => ::std::result::Result::Ok(ErrorCode::E_DISCONNECTED),
                "E_FAILED_TO_CONNECT" => ::std::result::Result::Ok(ErrorCode::E_FAILED_TO_CONNECT),
                "E_RPC_FAILURE" => ::std::result::Result::Ok(ErrorCode::E_RPC_FAILURE),
                "E_LEADER_CHANGED" => ::std::result::Result::Ok(ErrorCode::E_LEADER_CHANGED),
                "E_KEY_HAS_EXISTS" => ::std::result::Result::Ok(ErrorCode::E_KEY_HAS_EXISTS),
                "E_SPACE_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_SPACE_NOT_FOUND),
                "E_PART_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_PART_NOT_FOUND),
                "E_KEY_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_KEY_NOT_FOUND),
                "E_CONSENSUS_ERROR" => ::std::result::Result::Ok(ErrorCode::E_CONSENSUS_ERROR),
                "E_EDGE_PROP_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_EDGE_PROP_NOT_FOUND),
                "E_TAG_PROP_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_TAG_PROP_NOT_FOUND),
                "E_IMPROPER_DATA_TYPE" => ::std::result::Result::Ok(ErrorCode::E_IMPROPER_DATA_TYPE),
                "E_EDGE_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_EDGE_NOT_FOUND),
                "E_TAG_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_TAG_NOT_FOUND),
                "E_INDEX_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_INDEX_NOT_FOUND),
                "E_INVALID_FILTER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_FILTER),
                "E_INVALID_UPDATER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_UPDATER),
                "E_INVALID_STORE" => ::std::result::Result::Ok(ErrorCode::E_INVALID_STORE),
                "E_INVALID_PEER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_PEER),
                "E_RETRY_EXHAUSTED" => ::std::result::Result::Ok(ErrorCode::E_RETRY_EXHAUSTED),
                "E_TRANSFER_LEADER_FAILED" => ::std::result::Result::Ok(ErrorCode::E_TRANSFER_LEADER_FAILED),
                "E_LOAD_META_FAILED" => ::std::result::Result::Ok(ErrorCode::E_LOAD_META_FAILED),
                "E_FAILED_TO_CHECKPOINT" => ::std::result::Result::Ok(ErrorCode::E_FAILED_TO_CHECKPOINT),
                "E_CHECKPOINT_BLOCKED" => ::std::result::Result::Ok(ErrorCode::E_CHECKPOINT_BLOCKED),
                "E_FILTER_OUT" => ::std::result::Result::Ok(ErrorCode::E_FILTER_OUT),
                "E_PARTIAL_RESULT" => ::std::result::Result::Ok(ErrorCode::E_PARTIAL_RESULT),
                "E_UNKNOWN" => ::std::result::Result::Ok(ErrorCode::E_UNKNOWN),
                _ => ::anyhow::bail!("Unable to parse {} as ErrorCode", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ErrorCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ErrorCode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct PropOwner(pub ::std::primitive::i32);

    impl PropOwner {
        pub const SOURCE: Self = PropOwner(1i32);
        pub const DEST: Self = PropOwner(2i32);
        pub const EDGE: Self = PropOwner(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "SOURCE",
                "DEST",
                "EDGE",
            ]
        }
    }

    impl ::std::default::Default for PropOwner {
        fn default() -> Self {
            PropOwner(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a PropOwner> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a PropOwner) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<PropOwner> for ::std::primitive::i32 {
        #[inline]
        fn from(x: PropOwner) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for PropOwner {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for PropOwner {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                PropOwner::SOURCE => "SOURCE",
                PropOwner::DEST => "DEST",
                PropOwner::EDGE => "EDGE",
                PropOwner(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for PropOwner {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "PropOwner::{}", self)
        }
    }

    impl ::std::str::FromStr for PropOwner {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "SOURCE" => ::std::result::Result::Ok(PropOwner::SOURCE),
                "DEST" => ::std::result::Result::Ok(PropOwner::DEST),
                "EDGE" => ::std::result::Result::Ok(PropOwner::EDGE),
                _ => ::anyhow::bail!("Unable to parse {} as PropOwner", string),
            }
        }
    }

    impl ::fbthrift::GetTType for PropOwner {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for PropOwner
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for PropOwner
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(PropOwner::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EngineSignType(pub ::std::primitive::i32);

    impl EngineSignType {
        pub const BLOCK_ON: Self = EngineSignType(1i32);
        pub const BLOCK_OFF: Self = EngineSignType(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "BLOCK_ON",
                "BLOCK_OFF",
            ]
        }
    }

    impl ::std::default::Default for EngineSignType {
        fn default() -> Self {
            EngineSignType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EngineSignType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EngineSignType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EngineSignType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EngineSignType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EngineSignType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EngineSignType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                EngineSignType::BLOCK_ON => "BLOCK_ON",
                EngineSignType::BLOCK_OFF => "BLOCK_OFF",
                EngineSignType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for EngineSignType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EngineSignType::{}", self)
        }
    }

    impl ::std::str::FromStr for EngineSignType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "BLOCK_ON" => ::std::result::Result::Ok(EngineSignType::BLOCK_ON),
                "BLOCK_OFF" => ::std::result::Result::Ok(EngineSignType::BLOCK_OFF),
                _ => ::anyhow::bail!("Unable to parse {} as EngineSignType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EngineSignType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EngineSignType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EngineSignType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EngineSignType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct StatType(pub ::std::primitive::i32);

    impl StatType {
        pub const SUM: Self = StatType(1i32);
        pub const COUNT: Self = StatType(2i32);
        pub const AVG: Self = StatType(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "SUM",
                "COUNT",
                "AVG",
            ]
        }
    }

    impl ::std::default::Default for StatType {
        fn default() -> Self {
            StatType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a StatType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a StatType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<StatType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: StatType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for StatType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for StatType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                StatType::SUM => "SUM",
                StatType::COUNT => "COUNT",
                StatType::AVG => "AVG",
                StatType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for StatType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "StatType::{}", self)
        }
    }

    impl ::std::str::FromStr for StatType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "SUM" => ::std::result::Result::Ok(StatType::SUM),
                "COUNT" => ::std::result::Result::Ok(StatType::COUNT),
                "AVG" => ::std::result::Result::Ok(StatType::AVG),
                _ => ::anyhow::bail!("Unable to parse {} as StatType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for StatType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for StatType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for StatType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(StatType::from(p.read_i32()?))
        }
    }


    impl ::std::default::Default for EntryId {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for EntryId {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for EntryId
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EntryId");
            match self {
                EntryId::tag_id(inner) => {
                    p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryId::edge_type(inner) => {
                    p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryId::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EntryId
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryId::tag_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryId::edge_type(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "EntryId",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::PropDef {
        fn default() -> Self {
            Self {
                owner: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                stat: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PropDef {}
    unsafe impl ::std::marker::Sync for self::PropDef {}

    impl ::fbthrift::GetTType for self::PropDef {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PropDef
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PropDef");
            p.write_field_begin("owner", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.owner, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("stat", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.stat, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PropDef
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_owner = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_stat = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_owner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_stat = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                owner: field_owner.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                stat: field_stat.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ResultCode {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                leader: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ResultCode {}
    unsafe impl ::std::marker::Sync for self::ResultCode {}

    impl ::fbthrift::GetTType for self::ResultCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ResultCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ResultCode");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader {
                p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ResultCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_code = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                leader: field_leader,
            })
        }
    }


    impl ::std::default::Default for self::EdgeKey {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                edge_type: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeKey {}
    unsafe impl ::std::marker::Sync for self::EdgeKey {}

    impl ::fbthrift::GetTType for self::EdgeKey {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeKey
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeKey");
            p.write_field_begin("src", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.edge_type, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeKey
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_src = ::std::option::Option::None;
            let mut field_edge_type = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                edge_type: field_edge_type.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Edge {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Edge {}
    unsafe impl ::std::marker::Sync for self::Edge {}

    impl ::fbthrift::GetTType for self::Edge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Edge");
            p.write_field_begin("key", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_key = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IdAndProp {
        fn default() -> Self {
            Self {
                dst: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IdAndProp {}
    unsafe impl ::std::marker::Sync for self::IdAndProp {}

    impl ::fbthrift::GetTType for self::IdAndProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IdAndProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IdAndProp");
            p.write_field_begin("dst", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IdAndProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_dst = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dst: field_dst.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgeData {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
                edges: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeData {}
    unsafe impl ::std::marker::Sync for self::EdgeData {}

    impl ::fbthrift::GetTType for self::EdgeData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeData");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("edges", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edges, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_type = ::std::option::Option::None;
            let mut field_edges = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
                edges: field_edges.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TagData {
        fn default() -> Self {
            Self {
                tag_id: ::std::default::Default::default(),
                data: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TagData {}
    unsafe impl ::std::marker::Sync for self::TagData {}

    impl ::fbthrift::GetTType for self::TagData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TagData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TagData");
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("data", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.data, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TagData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_id: field_tag_id.unwrap_or_default(),
                data: field_data.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::VertexData {
        fn default() -> Self {
            Self {
                vertex_id: ::std::default::Default::default(),
                tag_data: ::std::default::Default::default(),
                edge_data: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::VertexData {}
    unsafe impl ::std::marker::Sync for self::VertexData {}

    impl ::fbthrift::GetTType for self::VertexData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::VertexData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("VertexData");
            p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.vertex_id, p);
            p.write_field_end();
            p.write_field_begin("tag_data", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tag_data, p);
            p.write_field_end();
            p.write_field_begin("edge_data", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edge_data, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::VertexData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_vertex_id = ::std::option::Option::None;
            let mut field_tag_data = ::std::option::Option::None;
            let mut field_edge_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tag_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edge_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vertex_id: field_vertex_id.unwrap_or_default(),
                tag_data: field_tag_data.unwrap_or_default(),
                edge_data: field_edge_data.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::VertexIndexData {
        fn default() -> Self {
            Self {
                vertex_id: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::VertexIndexData {}
    unsafe impl ::std::marker::Sync for self::VertexIndexData {}

    impl ::fbthrift::GetTType for self::VertexIndexData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::VertexIndexData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("VertexIndexData");
            p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.vertex_id, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::VertexIndexData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_vertex_id = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vertex_id: field_vertex_id.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ResponseCommon {
        fn default() -> Self {
            Self {
                failed_codes: ::std::default::Default::default(),
                latency_in_us: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ResponseCommon {}
    unsafe impl ::std::marker::Sync for self::ResponseCommon {}

    impl ::fbthrift::GetTType for self::ResponseCommon {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ResponseCommon
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ResponseCommon");
            p.write_field_begin("failed_codes", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.failed_codes, p);
            p.write_field_end();
            p.write_field_begin("latency_in_us", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.latency_in_us, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ResponseCommon
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_failed_codes = ::std::option::Option::None;
            let mut field_latency_in_us = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_failed_codes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_latency_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                failed_codes: field_failed_codes.unwrap_or_default(),
                latency_in_us: field_latency_in_us.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::QueryResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                vertex_schema: ::std::option::Option::None,
                edge_schema: ::std::option::Option::None,
                vertices: ::std::option::Option::None,
                total_edges: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::QueryResponse {}
    unsafe impl ::std::marker::Sync for self::QueryResponse {}

    impl ::fbthrift::GetTType for self::QueryResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::QueryResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("QueryResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.vertex_schema {
                p.write_field_begin("vertex_schema", ::fbthrift::TType::Map, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.edge_schema {
                p.write_field_begin("edge_schema", ::fbthrift::TType::Map, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vertices {
                p.write_field_begin("vertices", ::fbthrift::TType::List, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.total_edges {
                p.write_field_begin("total_edges", ::fbthrift::TType::I32, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::QueryResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_vertex_schema = ::std::option::Option::None;
            let mut field_edge_schema = ::std::option::Option::None;
            let mut field_vertices = ::std::option::Option::None;
            let mut field_total_edges = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_vertex_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_edge_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_total_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                vertex_schema: field_vertex_schema,
                edge_schema: field_edge_schema,
                vertices: field_vertices,
                total_edges: field_total_edges,
            })
        }
    }


    impl ::std::default::Default for self::ExecResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ExecResponse {}
    unsafe impl ::std::marker::Sync for self::ExecResponse {}

    impl ::fbthrift::GetTType for self::ExecResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ExecResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ExecResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ExecResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgePropResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                schema: ::std::option::Option::None,
                data: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgePropResponse {}
    unsafe impl ::std::marker::Sync for self::EdgePropResponse {}

    impl ::fbthrift::GetTType for self::EdgePropResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgePropResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgePropResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.schema {
                p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.data {
                p.write_field_begin("data", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgePropResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                schema: field_schema,
                data: field_data,
            })
        }
    }


    impl ::std::default::Default for self::QueryStatsResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                schema: ::std::option::Option::None,
                data: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::QueryStatsResponse {}
    unsafe impl ::std::marker::Sync for self::QueryStatsResponse {}

    impl ::fbthrift::GetTType for self::QueryStatsResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::QueryStatsResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("QueryStatsResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.schema {
                p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.data {
                p.write_field_begin("data", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::QueryStatsResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                schema: field_schema,
                data: field_data,
            })
        }
    }


    impl ::std::default::Default for self::Tag {
        fn default() -> Self {
            Self {
                tag_id: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Tag {}
    unsafe impl ::std::marker::Sync for self::Tag {}

    impl ::fbthrift::GetTType for self::Tag {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Tag");
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_id: field_tag_id.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Vertex {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Vertex {}
    unsafe impl ::std::marker::Sync for self::Vertex {}

    impl ::fbthrift::GetTType for self::Vertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Vertex");
            p.write_field_begin("id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_id = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetNeighborsRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                edge_types: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetNeighborsRequest {}
    unsafe impl ::std::marker::Sync for self::GetNeighborsRequest {}

    impl ::fbthrift::GetTType for self::GetNeighborsRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetNeighborsRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("edge_types", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edge_types, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_edge_types = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edge_types = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                edge_types: field_edge_types.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::VertexPropRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::VertexPropRequest {}
    unsafe impl ::std::marker::Sync for self::VertexPropRequest {}

    impl ::fbthrift::GetTType for self::VertexPropRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::VertexPropRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("VertexPropRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::VertexPropRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgePropRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                edge_type: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgePropRequest {}
    unsafe impl ::std::marker::Sync for self::EdgePropRequest {}

    impl ::fbthrift::GetTType for self::EdgePropRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgePropRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgePropRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.edge_type, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgePropRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_edge_type = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                edge_type: field_edge_type.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddVerticesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                overwritable: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddVerticesRequest {}
    unsafe impl ::std::marker::Sync for self::AddVerticesRequest {}

    impl ::fbthrift::GetTType for self::AddVerticesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddVerticesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddVerticesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.overwritable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddVerticesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_overwritable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                overwritable: field_overwritable.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddEdgesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                overwritable: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddEdgesRequest {}
    unsafe impl ::std::marker::Sync for self::AddEdgesRequest {}

    impl ::fbthrift::GetTType for self::AddEdgesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddEdgesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddEdgesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.overwritable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddEdgesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_overwritable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                overwritable: field_overwritable.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DeleteVerticesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DeleteVerticesRequest {}
    unsafe impl ::std::marker::Sync for self::DeleteVerticesRequest {}

    impl ::fbthrift::GetTType for self::DeleteVerticesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DeleteVerticesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DeleteVerticesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DeleteVerticesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DeleteEdgesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DeleteEdgesRequest {}
    unsafe impl ::std::marker::Sync for self::DeleteEdgesRequest {}

    impl ::fbthrift::GetTType for self::DeleteEdgesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DeleteEdgesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DeleteEdgesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DeleteEdgesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminExecResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminExecResp {}
    unsafe impl ::std::marker::Sync for self::AdminExecResp {}

    impl ::fbthrift::GetTType for self::AdminExecResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminExecResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminExecResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminExecResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddPartReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                as_learner: ::std::default::Default::default(),
                peers: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddPartReq {}
    unsafe impl ::std::marker::Sync for self::AddPartReq {}

    impl ::fbthrift::GetTType for self::AddPartReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddPartReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddPartReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("as_learner", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.as_learner, p);
            p.write_field_end();
            p.write_field_begin("peers", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.peers, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddPartReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_as_learner = ::std::option::Option::None;
            let mut field_peers = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_as_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                as_learner: field_as_learner.unwrap_or_default(),
                peers: field_peers.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemovePartReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemovePartReq {}
    unsafe impl ::std::marker::Sync for self::RemovePartReq {}

    impl ::fbthrift::GetTType for self::RemovePartReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemovePartReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemovePartReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemovePartReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MemberChangeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                peer: ::std::default::Default::default(),
                add: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MemberChangeReq {}
    unsafe impl ::std::marker::Sync for self::MemberChangeReq {}

    impl ::fbthrift::GetTType for self::MemberChangeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MemberChangeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MemberChangeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("peer", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.peer, p);
            p.write_field_end();
            p.write_field_begin("add", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.add, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MemberChangeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_peer = ::std::option::Option::None;
            let mut field_add = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_peer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                peer: field_peer.unwrap_or_default(),
                add: field_add.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TransLeaderReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                new_leader: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TransLeaderReq {}
    unsafe impl ::std::marker::Sync for self::TransLeaderReq {}

    impl ::fbthrift::GetTType for self::TransLeaderReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TransLeaderReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TransLeaderReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("new_leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.new_leader, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TransLeaderReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_new_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_new_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                new_leader: field_new_leader.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddLearnerReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                learner: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddLearnerReq {}
    unsafe impl ::std::marker::Sync for self::AddLearnerReq {}

    impl ::fbthrift::GetTType for self::AddLearnerReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddLearnerReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddLearnerReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("learner", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.learner, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddLearnerReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_learner = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                learner: field_learner.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CatchUpDataReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                target: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CatchUpDataReq {}
    unsafe impl ::std::marker::Sync for self::CatchUpDataReq {}

    impl ::fbthrift::GetTType for self::CatchUpDataReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CatchUpDataReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CatchUpDataReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("target", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.target, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CatchUpDataReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_target = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_target = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                target: field_target.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CheckPeersReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                peers: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CheckPeersReq {}
    unsafe impl ::std::marker::Sync for self::CheckPeersReq {}

    impl ::fbthrift::GetTType for self::CheckPeersReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckPeersReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckPeersReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("peers", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.peers, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckPeersReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_peers = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                peers: field_peers.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetLeaderReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetLeaderReq {}
    unsafe impl ::std::marker::Sync for self::GetLeaderReq {}

    impl ::fbthrift::GetTType for self::GetLeaderReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetLeaderReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetLeaderReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::GetLeaderResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                leader_parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetLeaderResp {}
    unsafe impl ::std::marker::Sync for self::GetLeaderResp {}

    impl ::fbthrift::GetTType for self::GetLeaderResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetLeaderResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetLeaderResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.leader_parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_leader_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                leader_parts: field_leader_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                schema: ::std::option::Option::None,
                data: ::std::option::Option::None,
                upsert: ::std::option::Option::Some(false),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateResponse {}
    unsafe impl ::std::marker::Sync for self::UpdateResponse {}

    impl ::fbthrift::GetTType for self::UpdateResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.schema {
                p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.data {
                p.write_field_begin("data", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.upsert {
                p.write_field_begin("upsert", ::fbthrift::TType::Bool, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let mut field_upsert = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_upsert = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                schema: field_schema,
                data: field_data,
                upsert: field_upsert,
            })
        }
    }


    impl ::std::default::Default for self::UpdateItem {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                prop: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateItem {}
    unsafe impl ::std::marker::Sync for self::UpdateItem {}

    impl ::fbthrift::GetTType for self::UpdateItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateItem");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("prop", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.prop, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_name = ::std::option::Option::None;
            let mut field_prop = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                prop: field_prop.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateVertexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                vertex_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                update_items: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
                insertable: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateVertexRequest {}
    unsafe impl ::std::marker::Sync for self::UpdateVertexRequest {}

    impl ::fbthrift::GetTType for self::UpdateVertexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateVertexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateVertexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("vertex_id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.vertex_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("update_items", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.update_items, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_begin("insertable", ::fbthrift::TType::Bool, 7);
            ::fbthrift::Serialize::write(&self.insertable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateVertexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_vertex_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_update_items = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let mut field_insertable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_update_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 7) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                vertex_id: field_vertex_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                update_items: field_update_items.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
                insertable: field_insertable.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateEdgeRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_key: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                update_items: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
                insertable: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateEdgeRequest {}
    unsafe impl ::std::marker::Sync for self::UpdateEdgeRequest {}

    impl ::fbthrift::GetTType for self::UpdateEdgeRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateEdgeRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateEdgeRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_key", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.edge_key, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("update_items", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.update_items, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_begin("insertable", ::fbthrift::TType::Bool, 7);
            ::fbthrift::Serialize::write(&self.insertable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateEdgeRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_key = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_update_items = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let mut field_insertable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_edge_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_update_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 7) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_key: field_edge_key.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                update_items: field_update_items.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
                insertable: field_insertable.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanEdgeRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                cursor: ::std::option::Option::None,
                return_columns: ::std::default::Default::default(),
                all_columns: ::std::default::Default::default(),
                limit: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                end_time: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanEdgeRequest {}
    unsafe impl ::std::marker::Sync for self::ScanEdgeRequest {}

    impl ::fbthrift::GetTType for self::ScanEdgeRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanEdgeRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanEdgeRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.cursor {
                p.write_field_begin("cursor", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("return_columns", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_begin("all_columns", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.all_columns, p);
            p.write_field_end();
            p.write_field_begin("limit", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.limit, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 7);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("end_time", ::fbthrift::TType::I64, 8);
            ::fbthrift::Serialize::write(&self.end_time, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanEdgeRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_cursor = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let mut field_all_columns = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_end_time = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_all_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 8) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                cursor: field_cursor,
                return_columns: field_return_columns.unwrap_or_default(),
                all_columns: field_all_columns.unwrap_or_default(),
                limit: field_limit.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                end_time: field_end_time.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanEdgeResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                edge_schema: ::std::default::Default::default(),
                edge_data: ::std::default::Default::default(),
                has_next: ::std::default::Default::default(),
                next_cursor: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanEdgeResponse {}
    unsafe impl ::std::marker::Sync for self::ScanEdgeResponse {}

    impl ::fbthrift::GetTType for self::ScanEdgeResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanEdgeResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanEdgeResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("edge_schema", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.edge_schema, p);
            p.write_field_end();
            p.write_field_begin("edge_data", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edge_data, p);
            p.write_field_end();
            p.write_field_begin("has_next", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.has_next, p);
            p.write_field_end();
            p.write_field_begin("next_cursor", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.next_cursor, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanEdgeResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_edge_schema = ::std::option::Option::None;
            let mut field_edge_data = ::std::option::Option::None;
            let mut field_has_next = ::std::option::Option::None;
            let mut field_next_cursor = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_edge_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edge_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_has_next = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_next_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                edge_schema: field_edge_schema.unwrap_or_default(),
                edge_data: field_edge_data.unwrap_or_default(),
                has_next: field_has_next.unwrap_or_default(),
                next_cursor: field_next_cursor.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanEdge {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanEdge {}
    unsafe impl ::std::marker::Sync for self::ScanEdge {}

    impl ::fbthrift::GetTType for self::ScanEdge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanEdge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanEdge");
            p.write_field_begin("src", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanEdge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_src = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanVertexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                cursor: ::std::option::Option::None,
                return_columns: ::std::default::Default::default(),
                all_columns: ::std::default::Default::default(),
                limit: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                end_time: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanVertexRequest {}
    unsafe impl ::std::marker::Sync for self::ScanVertexRequest {}

    impl ::fbthrift::GetTType for self::ScanVertexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanVertexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanVertexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.cursor {
                p.write_field_begin("cursor", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("return_columns", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_begin("all_columns", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.all_columns, p);
            p.write_field_end();
            p.write_field_begin("limit", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.limit, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 7);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("end_time", ::fbthrift::TType::I64, 8);
            ::fbthrift::Serialize::write(&self.end_time, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanVertexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_cursor = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let mut field_all_columns = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_end_time = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_all_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 8) => field_end_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                cursor: field_cursor,
                return_columns: field_return_columns.unwrap_or_default(),
                all_columns: field_all_columns.unwrap_or_default(),
                limit: field_limit.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                end_time: field_end_time.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanVertex {
        fn default() -> Self {
            Self {
                vertexId: ::std::default::Default::default(),
                tagId: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanVertex {}
    unsafe impl ::std::marker::Sync for self::ScanVertex {}

    impl ::fbthrift::GetTType for self::ScanVertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanVertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanVertex");
            p.write_field_begin("vertexId", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.vertexId, p);
            p.write_field_end();
            p.write_field_begin("tagId", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.tagId, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanVertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_vertexId = ::std::option::Option::None;
            let mut field_tagId = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_vertexId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_tagId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vertexId: field_vertexId.unwrap_or_default(),
                tagId: field_tagId.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanVertexResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                vertex_schema: ::std::default::Default::default(),
                vertex_data: ::std::default::Default::default(),
                has_next: ::std::default::Default::default(),
                next_cursor: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanVertexResponse {}
    unsafe impl ::std::marker::Sync for self::ScanVertexResponse {}

    impl ::fbthrift::GetTType for self::ScanVertexResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanVertexResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanVertexResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("vertex_schema", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.vertex_schema, p);
            p.write_field_end();
            p.write_field_begin("vertex_data", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.vertex_data, p);
            p.write_field_end();
            p.write_field_begin("has_next", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.has_next, p);
            p.write_field_end();
            p.write_field_begin("next_cursor", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.next_cursor, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanVertexResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_vertex_schema = ::std::option::Option::None;
            let mut field_vertex_data = ::std::option::Option::None;
            let mut field_has_next = ::std::option::Option::None;
            let mut field_next_cursor = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_vertex_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_vertex_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_has_next = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_next_cursor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                vertex_schema: field_vertex_schema.unwrap_or_default(),
                vertex_data: field_vertex_data.unwrap_or_default(),
                has_next: field_has_next.unwrap_or_default(),
                next_cursor: field_next_cursor.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PutRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PutRequest {}
    unsafe impl ::std::marker::Sync for self::PutRequest {}

    impl ::fbthrift::GetTType for self::PutRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PutRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PutRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PutRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveRequest {}
    unsafe impl ::std::marker::Sync for self::RemoveRequest {}

    impl ::fbthrift::GetTType for self::RemoveRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveRangeRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveRangeRequest {}
    unsafe impl ::std::marker::Sync for self::RemoveRangeRequest {}

    impl ::fbthrift::GetTType for self::RemoveRangeRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveRangeRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                return_partly: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetRequest {}
    unsafe impl ::std::marker::Sync for self::GetRequest {}

    impl ::fbthrift::GetTType for self::GetRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("return_partly", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.return_partly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_return_partly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_return_partly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                return_partly: field_return_partly.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PrefixRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PrefixRequest {}
    unsafe impl ::std::marker::Sync for self::PrefixRequest {}

    impl ::fbthrift::GetTType for self::PrefixRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PrefixRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PrefixRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PrefixRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanRequest {}
    unsafe impl ::std::marker::Sync for self::ScanRequest {}

    impl ::fbthrift::GetTType for self::ScanRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GeneralResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GeneralResponse {}
    unsafe impl ::std::marker::Sync for self::GeneralResponse {}

    impl ::fbthrift::GetTType for self::GeneralResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GeneralResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GeneralResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("values", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GeneralResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetUUIDReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUUIDReq {}
    unsafe impl ::std::marker::Sync for self::GetUUIDReq {}

    impl ::fbthrift::GetTType for self::GetUUIDReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUUIDReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUUIDReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetUUIDResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUUIDResp {}
    unsafe impl ::std::marker::Sync for self::GetUUIDResp {}

    impl ::fbthrift::GetTType for self::GetUUIDResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUUIDResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUUIDResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BlockingSignRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                sign: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BlockingSignRequest {}
    unsafe impl ::std::marker::Sync for self::BlockingSignRequest {}

    impl ::fbthrift::GetTType for self::BlockingSignRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BlockingSignRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BlockingSignRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("sign", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.sign, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BlockingSignRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_sign = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_sign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                sign: field_sign.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateCPRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateCPRequest {}
    unsafe impl ::std::marker::Sync for self::CreateCPRequest {}

    impl ::fbthrift::GetTType for self::CreateCPRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateCPRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateCPRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateCPRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropCPRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropCPRequest {}
    unsafe impl ::std::marker::Sync for self::DropCPRequest {}

    impl ::fbthrift::GetTType for self::DropCPRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropCPRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropCPRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropCPRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RebuildIndexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                index_id: ::std::default::Default::default(),
                is_offline: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RebuildIndexRequest {}
    unsafe impl ::std::marker::Sync for self::RebuildIndexRequest {}

    impl ::fbthrift::GetTType for self::RebuildIndexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RebuildIndexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.index_id, p);
            p.write_field_end();
            p.write_field_begin("is_offline", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.is_offline, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_index_id = ::std::option::Option::None;
            let mut field_is_offline = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_is_offline = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                index_id: field_index_id.unwrap_or_default(),
                is_offline: field_is_offline.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LookUpIndexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                index_id: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                return_columns: ::std::default::Default::default(),
                is_edge: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LookUpIndexRequest {}
    unsafe impl ::std::marker::Sync for self::LookUpIndexRequest {}

    impl ::fbthrift::GetTType for self::LookUpIndexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LookUpIndexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LookUpIndexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.index_id, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("return_columns", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.return_columns, p);
            p.write_field_end();
            p.write_field_begin("is_edge", ::fbthrift::TType::Bool, 6);
            ::fbthrift::Serialize::write(&self.is_edge, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LookUpIndexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_index_id = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let mut field_is_edge = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 6) => field_is_edge = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                index_id: field_index_id.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                return_columns: field_return_columns.unwrap_or_default(),
                is_edge: field_is_edge.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LookUpIndexResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                schema: ::std::option::Option::None,
                vertices: ::std::option::Option::None,
                edges: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LookUpIndexResp {}
    unsafe impl ::std::marker::Sync for self::LookUpIndexResp {}

    impl ::fbthrift::GetTType for self::LookUpIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LookUpIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LookUpIndexResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.schema {
                p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vertices {
                p.write_field_begin("vertices", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.edges {
                p.write_field_begin("edges", ::fbthrift::TType::List, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LookUpIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_vertices = ::std::option::Option::None;
            let mut field_edges = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                schema: field_schema,
                vertices: field_vertices,
                edges: field_edges,
            })
        }
    }

}

pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod storage_service {

        #[derive(Clone, Debug)]
        pub enum GetBoundExn {
            Success(crate::types::QueryResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBoundExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetBoundExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetBoundExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetBoundExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetBound");
                match self {
                    GetBoundExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBoundExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetBoundExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetBoundExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetBoundExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetBoundExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BoundStatsExn {
            Success(crate::types::QueryStatsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BoundStatsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                BoundStatsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for BoundStatsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BoundStatsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("BoundStats");
                match self {
                    BoundStatsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    BoundStatsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BoundStatsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(BoundStatsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BoundStatsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BoundStatsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPropsExn {
            Success(crate::types::QueryResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPropsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetPropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetProps");
                match self {
                    GetPropsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPropsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPropsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgePropsExn {
            Success(crate::types::EdgePropResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgePropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEdgePropsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEdgePropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgePropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEdgeProps");
                match self {
                    GetEdgePropsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEdgePropsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgePropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEdgePropsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgePropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgePropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddVerticesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddVerticesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddVertices");
                match self {
                    AddVerticesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddVerticesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddVerticesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddEdgesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddEdges");
                match self {
                    AddEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteEdgesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DeleteEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DeleteEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DeleteEdges");
                match self {
                    DeleteEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DeleteEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DeleteEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteVerticesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DeleteVerticesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DeleteVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DeleteVertices");
                match self {
                    DeleteVerticesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DeleteVerticesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DeleteVerticesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateVertexExn {
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UpdateVertexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UpdateVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UpdateVertex");
                match self {
                    UpdateVertexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UpdateVertexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UpdateVertexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateEdgeExn {
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UpdateEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UpdateEdge");
                match self {
                    UpdateEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UpdateEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UpdateEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanEdgeExn {
            Success(crate::types::ScanEdgeResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ScanEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ScanEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ScanEdge");
                match self {
                    ScanEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ScanEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ScanEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanVertexExn {
            Success(crate::types::ScanVertexResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ScanVertexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ScanVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ScanVertex");
                match self {
                    ScanVertexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ScanVertexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ScanVertexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum TransLeaderExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for TransLeaderExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                TransLeaderExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for TransLeaderExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("TransLeader");
                match self {
                    TransLeaderExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    TransLeaderExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(TransLeaderExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "TransLeaderExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "TransLeaderExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddPartExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddPartExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddPart");
                match self {
                    AddPartExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddPartExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddPartExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddLearnerExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddLearnerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddLearnerExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddLearnerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddLearner");
                match self {
                    AddLearnerExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddLearnerExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddLearnerExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddLearnerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddLearnerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum WaitingForCatchUpDataExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for WaitingForCatchUpDataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                WaitingForCatchUpDataExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for WaitingForCatchUpDataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("WaitingForCatchUpData");
                match self {
                    WaitingForCatchUpDataExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    WaitingForCatchUpDataExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(WaitingForCatchUpDataExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "WaitingForCatchUpDataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "WaitingForCatchUpDataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemovePartExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemovePartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemovePartExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemovePartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemovePart");
                match self {
                    RemovePartExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemovePartExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemovePartExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemovePartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemovePartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MemberChangeExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MemberChangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MemberChangeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MemberChangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MemberChange");
                match self {
                    MemberChangeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MemberChangeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MemberChangeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MemberChangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MemberChangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckPeersExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPeersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CheckPeersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CheckPeersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CheckPeers");
                match self {
                    CheckPeersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckPeersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckPeersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckPeersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckPeersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetLeaderPartExn {
            Success(crate::types::GetLeaderResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetLeaderPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetLeaderPartExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetLeaderPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetLeaderPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetLeaderPart");
                match self {
                    GetLeaderPartExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetLeaderPartExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetLeaderPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetLeaderPartExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetLeaderPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetLeaderPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateCheckpointExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateCheckpointExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateCheckpoint");
                match self {
                    CreateCheckpointExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateCheckpointExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateCheckpointExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropCheckpointExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropCheckpointExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropCheckpoint");
                match self {
                    DropCheckpointExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropCheckpointExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropCheckpointExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BlockingWritesExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BlockingWritesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                BlockingWritesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for BlockingWritesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("BlockingWrites");
                match self {
                    BlockingWritesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    BlockingWritesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(BlockingWritesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BlockingWritesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BlockingWritesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    RebuildTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    RebuildEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum PutExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                PutExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for PutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Put");
                match self {
                    PutExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    PutExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(PutExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "PutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "PutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            Success(crate::types::GeneralResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Get");
                match self {
                    GetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Remove");
                match self {
                    RemoveExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveRangeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveRange");
                match self {
                    RemoveRangeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveRangeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveRangeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUUIDExn {
            Success(crate::types::GetUUIDResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUUIDExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetUUIDExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetUUIDExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetUUID");
                match self {
                    GetUUIDExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetUUIDExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetUUIDExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUUIDExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUUIDExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookUpIndexExn {
            Success(crate::types::LookUpIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookUpIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                LookUpIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for LookUpIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookUpIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("LookUpIndex");
                match self {
                    LookUpIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    LookUpIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookUpIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(LookUpIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookUpIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookUpIndexExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct StorageServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> StorageServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait StorageService: ::std::marker::Send {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> + ::std::marker::Send + 'static>>;
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> + ::std::marker::Send + 'static>>;
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> + ::std::marker::Send + 'static>>;
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> + ::std::marker::Send + 'static>>;
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> + ::std::marker::Send + 'static>>;
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> + ::std::marker::Send + 'static>>;
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>>;
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>>;
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>>;
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>>;
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> + ::std::marker::Send + 'static>>;
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> + ::std::marker::Send + 'static>>;
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> + ::std::marker::Send + 'static>>;
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> + ::std::marker::Send + 'static>>;
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> + ::std::marker::Send + 'static>>;
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>>;
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> + ::std::marker::Send + 'static>>;
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> + ::std::marker::Send + 'static>>;
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> + ::std::marker::Send + 'static>>;
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> + ::std::marker::Send + 'static>>;
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> + ::std::marker::Send + 'static>>;
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> + ::std::marker::Send + 'static>>;
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> + ::std::marker::Send + 'static>>;
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>>;
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> + ::std::marker::Send + 'static>>;
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> + ::std::marker::Send + 'static>>;
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> + ::std::marker::Send + 'static>>;
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> + ::std::marker::Send + 'static>>;
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> + ::std::marker::Send + 'static>>;
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> StorageService for StorageServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getBound",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetBoundExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetBoundExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetBoundExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetBoundError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetBoundError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetBoundError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "boundStats",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::BoundStatsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::BoundStatsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::BoundStatsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::BoundStatsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::BoundStatsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::BoundStatsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getProps",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetPropsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetPropsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetPropsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetPropsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetPropsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetPropsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeProps",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetEdgePropsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetEdgePropsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetEdgePropsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetEdgePropsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetEdgePropsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetEdgePropsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addVertices",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::AddVerticesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::AddVerticesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::AddVerticesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::AddVerticesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::AddVerticesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::AddVerticesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::AddEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::AddEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::AddEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::AddEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::AddEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::AddEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::DeleteEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::DeleteEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::DeleteEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::DeleteEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::DeleteEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::DeleteEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteVertices",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::DeleteVerticesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::DeleteVerticesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::DeleteVerticesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::DeleteVerticesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::DeleteVerticesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::DeleteVerticesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateVertex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::UpdateVertexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::UpdateVertexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::UpdateVertexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::UpdateVertexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::UpdateVertexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::UpdateVertexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::UpdateEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::UpdateEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::UpdateEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::UpdateEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::UpdateEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::UpdateEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scanEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::ScanEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::ScanEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::ScanEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::ScanEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::ScanEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::ScanEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scanVertex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::ScanVertexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::ScanVertexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::ScanVertexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::ScanVertexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::ScanVertexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::ScanVertexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "transLeader",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::TransLeaderExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::TransLeaderExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::TransLeaderExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::TransLeaderError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::TransLeaderError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::TransLeaderError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addPart",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::AddPartExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::AddPartExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::AddPartExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::AddPartError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::AddPartError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::AddPartError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addLearner",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::AddLearnerExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::AddLearnerExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::AddLearnerExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::AddLearnerError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::AddLearnerError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::AddLearnerError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "waitingForCatchUpData",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::WaitingForCatchUpDataExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::WaitingForCatchUpDataExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::WaitingForCatchUpDataError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::WaitingForCatchUpDataError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::WaitingForCatchUpDataError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removePart",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::RemovePartExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::RemovePartExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::RemovePartExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::RemovePartError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::RemovePartError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::RemovePartError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "memberChange",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::MemberChangeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::MemberChangeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::MemberChangeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::MemberChangeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::MemberChangeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::MemberChangeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkPeers",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::CheckPeersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::CheckPeersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::CheckPeersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::CheckPeersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::CheckPeersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::CheckPeersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getLeaderPart",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetLeaderPartExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetLeaderPartExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetLeaderPartExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetLeaderPartError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetLeaderPartError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetLeaderPartError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createCheckpoint",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::CreateCheckpointExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::CreateCheckpointExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::CreateCheckpointExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::CreateCheckpointError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::CreateCheckpointError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::CreateCheckpointError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropCheckpoint",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::DropCheckpointExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::DropCheckpointExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::DropCheckpointExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::DropCheckpointError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::DropCheckpointError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::DropCheckpointError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "blockingWrites",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::BlockingWritesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::BlockingWritesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::BlockingWritesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::BlockingWritesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::BlockingWritesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::BlockingWritesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::RebuildTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::RebuildTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::RebuildTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::RebuildTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::RebuildTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::RebuildTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::RebuildEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::RebuildEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::RebuildEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::RebuildEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::RebuildEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "put",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::PutExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::PutExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::PutExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::PutError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::PutError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::PutError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::RemoveExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::RemoveExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::RemoveExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::RemoveError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::RemoveError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::RemoveError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::RemoveRangeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::RemoveRangeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::RemoveRangeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::RemoveRangeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::RemoveRangeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::RemoveRangeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUUID",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::GetUUIDExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::GetUUIDExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::GetUUIDExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::GetUUIDError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::GetUUIDError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::GetUUIDError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookUpIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_service::LookUpIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_service::LookUpIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_service::LookUpIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_service::LookUpIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_service::LookUpIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_service::LookUpIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> StorageService for T
    where
        T: ::std::convert::AsRef<dyn StorageService + 'a>,
        T: ::std::marker::Send,
    {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getBound(
                arg_req,
            )
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().boundStats(
                arg_req,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getProps(
                arg_req,
            )
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEdgeProps(
                arg_req,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addVertices(
                arg_req,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addEdges(
                arg_req,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().deleteEdges(
                arg_req,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().deleteVertices(
                arg_req,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().updateVertex(
                arg_req,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().updateEdge(
                arg_req,
            )
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().scanEdge(
                arg_req,
            )
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().scanVertex(
                arg_req,
            )
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            self.as_ref().transLeader(
                arg_req,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addPart(
                arg_req,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addLearner(
                arg_req,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            self.as_ref().waitingForCatchUpData(
                arg_req,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removePart(
                arg_req,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().memberChange(
                arg_req,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().checkPeers(
                arg_req,
            )
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getLeaderPart(
                arg_req,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createCheckpoint(
                arg_req,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropCheckpoint(
                arg_req,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().blockingWrites(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> + ::std::marker::Send + 'static>> {
            self.as_ref().put(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getUUID(
                arg_req,
            )
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().lookUpIndex(
                arg_req,
            )
        }
    }

    pub struct make_StorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn StorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(StorageServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_StorageService {
        type Api = dyn StorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            StorageService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait StorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn getBound(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetBoundExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetBoundExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getBound",
                ),
            ))
        }
        async fn boundStats(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::QueryStatsResponse, crate::services::storage_service::BoundStatsExn> {
            ::std::result::Result::Err(crate::services::storage_service::BoundStatsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "boundStats",
                ),
            ))
        }
        async fn getProps(
            &self,
            _req: crate::types::VertexPropRequest,
        ) -> ::std::result::Result<crate::types::QueryResponse, crate::services::storage_service::GetPropsExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetPropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getProps",
                ),
            ))
        }
        async fn getEdgeProps(
            &self,
            _req: crate::types::EdgePropRequest,
        ) -> ::std::result::Result<crate::types::EdgePropResponse, crate::services::storage_service::GetEdgePropsExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetEdgePropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getEdgeProps",
                ),
            ))
        }
        async fn addVertices(
            &self,
            _req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddVerticesExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addVertices",
                ),
            ))
        }
        async fn addEdges(
            &self,
            _req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::AddEdgesExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addEdges",
                ),
            ))
        }
        async fn deleteEdges(
            &self,
            _req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteEdgesExn> {
            ::std::result::Result::Err(crate::services::storage_service::DeleteEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "deleteEdges",
                ),
            ))
        }
        async fn deleteVertices(
            &self,
            _req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::DeleteVerticesExn> {
            ::std::result::Result::Err(crate::services::storage_service::DeleteVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "deleteVertices",
                ),
            ))
        }
        async fn updateVertex(
            &self,
            _req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateVertexExn> {
            ::std::result::Result::Err(crate::services::storage_service::UpdateVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "updateVertex",
                ),
            ))
        }
        async fn updateEdge(
            &self,
            _req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::storage_service::UpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::storage_service::UpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "updateEdge",
                ),
            ))
        }
        async fn scanEdge(
            &self,
            _req: crate::types::ScanEdgeRequest,
        ) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::services::storage_service::ScanEdgeExn> {
            ::std::result::Result::Err(crate::services::storage_service::ScanEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "scanEdge",
                ),
            ))
        }
        async fn scanVertex(
            &self,
            _req: crate::types::ScanVertexRequest,
        ) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::services::storage_service::ScanVertexExn> {
            ::std::result::Result::Err(crate::services::storage_service::ScanVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "scanVertex",
                ),
            ))
        }
        async fn transLeader(
            &self,
            _req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::TransLeaderExn> {
            ::std::result::Result::Err(crate::services::storage_service::TransLeaderExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "transLeader",
                ),
            ))
        }
        async fn addPart(
            &self,
            _req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddPartExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addPart",
                ),
            ))
        }
        async fn addLearner(
            &self,
            _req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::AddLearnerExn> {
            ::std::result::Result::Err(crate::services::storage_service::AddLearnerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "addLearner",
                ),
            ))
        }
        async fn waitingForCatchUpData(
            &self,
            _req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::WaitingForCatchUpDataExn> {
            ::std::result::Result::Err(crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "waitingForCatchUpData",
                ),
            ))
        }
        async fn removePart(
            &self,
            _req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RemovePartExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemovePartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "removePart",
                ),
            ))
        }
        async fn memberChange(
            &self,
            _req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::MemberChangeExn> {
            ::std::result::Result::Err(crate::services::storage_service::MemberChangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "memberChange",
                ),
            ))
        }
        async fn checkPeers(
            &self,
            _req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CheckPeersExn> {
            ::std::result::Result::Err(crate::services::storage_service::CheckPeersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "checkPeers",
                ),
            ))
        }
        async fn getLeaderPart(
            &self,
            _req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderResp, crate::services::storage_service::GetLeaderPartExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetLeaderPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getLeaderPart",
                ),
            ))
        }
        async fn createCheckpoint(
            &self,
            _req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::CreateCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_service::CreateCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "createCheckpoint",
                ),
            ))
        }
        async fn dropCheckpoint(
            &self,
            _req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::DropCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_service::DropCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "dropCheckpoint",
                ),
            ))
        }
        async fn blockingWrites(
            &self,
            _req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::BlockingWritesExn> {
            ::std::result::Result::Err(crate::services::storage_service::BlockingWritesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "blockingWrites",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn put(
            &self,
            _req: crate::types::PutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::PutExn> {
            ::std::result::Result::Err(crate::services::storage_service::PutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "put",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetRequest,
        ) -> ::std::result::Result<crate::types::GeneralResponse, crate::services::storage_service::GetExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "get",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::storage_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::storage_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "removeRange",
                ),
            ))
        }
        async fn getUUID(
            &self,
            _req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::storage_service::GetUUIDExn> {
            ::std::result::Result::Err(crate::services::storage_service::GetUUIDExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "getUUID",
                ),
            ))
        }
        async fn lookUpIndex(
            &self,
            _req: crate::types::LookUpIndexRequest,
        ) -> ::std::result::Result<crate::types::LookUpIndexResp, crate::services::storage_service::LookUpIndexExn> {
            ::std::result::Result::Err(crate::services::storage_service::LookUpIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageService",
                    "lookUpIndex",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct StorageServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> StorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_getBound<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getBound(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getBound",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetBoundExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetBoundExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetBoundExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getBound",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getBound",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_boundStats<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.boundStats(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "boundStats",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::BoundStatsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::BoundStatsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::BoundStatsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "boundStats",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "boundStats",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getProps(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getProps",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetPropsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetPropsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetPropsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getProps",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getProps",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEdgeProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getEdgeProps(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEdgeProps",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetEdgePropsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetEdgePropsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetEdgePropsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeProps",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeProps",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addVertices(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addVertices",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::AddVerticesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::AddVerticesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::AddVerticesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addVertices",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addVertices",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::AddEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::AddEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::AddEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addEdges",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_deleteEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.deleteEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "deleteEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::DeleteEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::DeleteEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::DeleteEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteEdges",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_deleteVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.deleteVertices(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "deleteVertices",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::DeleteVerticesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::DeleteVerticesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::DeleteVerticesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteVertices",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteVertices",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_updateVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.updateVertex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "updateVertex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::UpdateVertexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::UpdateVertexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::UpdateVertexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateVertex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateVertex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_updateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.updateEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "updateEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::UpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::UpdateEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::UpdateEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateEdge",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_scanEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.scanEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "scanEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::ScanEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::ScanEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::ScanEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanEdge",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scanEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_scanVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.scanVertex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "scanVertex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::ScanVertexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::ScanVertexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::ScanVertexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanVertex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scanVertex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_transLeader<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.transLeader(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "transLeader",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::TransLeaderExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::TransLeaderExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::TransLeaderExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "transLeader",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "transLeader",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addPart(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addPart",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::AddPartExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::AddPartExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::AddPartExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addPart",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addPart",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addLearner<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addLearner(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addLearner",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::AddLearnerExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::AddLearnerExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::AddLearnerExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addLearner",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addLearner",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_waitingForCatchUpData<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.waitingForCatchUpData(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "waitingForCatchUpData",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::WaitingForCatchUpDataExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::WaitingForCatchUpDataExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::WaitingForCatchUpDataExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "waitingForCatchUpData",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "waitingForCatchUpData",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_removePart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removePart(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removePart",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::RemovePartExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::RemovePartExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::RemovePartExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removePart",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removePart",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_memberChange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.memberChange(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "memberChange",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::MemberChangeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::MemberChangeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::MemberChangeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "memberChange",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "memberChange",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_checkPeers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.checkPeers(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "checkPeers",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::CheckPeersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::CheckPeersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::CheckPeersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkPeers",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkPeers",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getLeaderPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getLeaderPart(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getLeaderPart",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetLeaderPartExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetLeaderPartExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetLeaderPartExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getLeaderPart",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getLeaderPart",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_createCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.createCheckpoint(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createCheckpoint",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::CreateCheckpointExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::CreateCheckpointExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::CreateCheckpointExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createCheckpoint",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createCheckpoint",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.dropCheckpoint(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropCheckpoint",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::DropCheckpointExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::DropCheckpointExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::DropCheckpointExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropCheckpoint",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropCheckpoint",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_blockingWrites<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.blockingWrites(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "blockingWrites",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::BlockingWritesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::BlockingWritesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::BlockingWritesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "blockingWrites",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "blockingWrites",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.rebuildTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::RebuildTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::RebuildTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.rebuildEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::RebuildEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::RebuildEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_put<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.put(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "put",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::PutExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::PutExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::PutExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "put",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "put",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.get(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "get",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.remove(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "remove",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::RemoveExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::RemoveExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removeRange(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeRange",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::RemoveRangeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::RemoveRangeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getUUID<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getUUID(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getUUID",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::GetUUIDExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::GetUUIDExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::GetUUIDExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUUID",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUUID",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_lookUpIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.lookUpIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "lookUpIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_service::LookUpIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_service::LookUpIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_service::LookUpIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookUpIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookUpIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for StorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"getBound" => ::std::result::Result::Ok(0usize),
                b"boundStats" => ::std::result::Result::Ok(1usize),
                b"getProps" => ::std::result::Result::Ok(2usize),
                b"getEdgeProps" => ::std::result::Result::Ok(3usize),
                b"addVertices" => ::std::result::Result::Ok(4usize),
                b"addEdges" => ::std::result::Result::Ok(5usize),
                b"deleteEdges" => ::std::result::Result::Ok(6usize),
                b"deleteVertices" => ::std::result::Result::Ok(7usize),
                b"updateVertex" => ::std::result::Result::Ok(8usize),
                b"updateEdge" => ::std::result::Result::Ok(9usize),
                b"scanEdge" => ::std::result::Result::Ok(10usize),
                b"scanVertex" => ::std::result::Result::Ok(11usize),
                b"transLeader" => ::std::result::Result::Ok(12usize),
                b"addPart" => ::std::result::Result::Ok(13usize),
                b"addLearner" => ::std::result::Result::Ok(14usize),
                b"waitingForCatchUpData" => ::std::result::Result::Ok(15usize),
                b"removePart" => ::std::result::Result::Ok(16usize),
                b"memberChange" => ::std::result::Result::Ok(17usize),
                b"checkPeers" => ::std::result::Result::Ok(18usize),
                b"getLeaderPart" => ::std::result::Result::Ok(19usize),
                b"createCheckpoint" => ::std::result::Result::Ok(20usize),
                b"dropCheckpoint" => ::std::result::Result::Ok(21usize),
                b"blockingWrites" => ::std::result::Result::Ok(22usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(23usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(24usize),
                b"put" => ::std::result::Result::Ok(25usize),
                b"get" => ::std::result::Result::Ok(26usize),
                b"remove" => ::std::result::Result::Ok(27usize),
                b"removeRange" => ::std::result::Result::Ok(28usize),
                b"getUUID" => ::std::result::Result::Ok(29usize),
                b"lookUpIndex" => ::std::result::Result::Ok(30usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_getBound(_p, _r, _seqid).await,
                1usize => self.handle_boundStats(_p, _r, _seqid).await,
                2usize => self.handle_getProps(_p, _r, _seqid).await,
                3usize => self.handle_getEdgeProps(_p, _r, _seqid).await,
                4usize => self.handle_addVertices(_p, _r, _seqid).await,
                5usize => self.handle_addEdges(_p, _r, _seqid).await,
                6usize => self.handle_deleteEdges(_p, _r, _seqid).await,
                7usize => self.handle_deleteVertices(_p, _r, _seqid).await,
                8usize => self.handle_updateVertex(_p, _r, _seqid).await,
                9usize => self.handle_updateEdge(_p, _r, _seqid).await,
                10usize => self.handle_scanEdge(_p, _r, _seqid).await,
                11usize => self.handle_scanVertex(_p, _r, _seqid).await,
                12usize => self.handle_transLeader(_p, _r, _seqid).await,
                13usize => self.handle_addPart(_p, _r, _seqid).await,
                14usize => self.handle_addLearner(_p, _r, _seqid).await,
                15usize => self.handle_waitingForCatchUpData(_p, _r, _seqid).await,
                16usize => self.handle_removePart(_p, _r, _seqid).await,
                17usize => self.handle_memberChange(_p, _r, _seqid).await,
                18usize => self.handle_checkPeers(_p, _r, _seqid).await,
                19usize => self.handle_getLeaderPart(_p, _r, _seqid).await,
                20usize => self.handle_createCheckpoint(_p, _r, _seqid).await,
                21usize => self.handle_dropCheckpoint(_p, _r, _seqid).await,
                22usize => self.handle_blockingWrites(_p, _r, _seqid).await,
                23usize => self.handle_rebuildTagIndex(_p, _r, _seqid).await,
                24usize => self.handle_rebuildEdgeIndex(_p, _r, _seqid).await,
                25usize => self.handle_put(_p, _r, _seqid).await,
                26usize => self.handle_get(_p, _r, _seqid).await,
                27usize => self.handle_remove(_p, _r, _seqid).await,
                28usize => self.handle_removeRange(_p, _r, _seqid).await,
                29usize => self.handle_getUUID(_p, _r, _seqid).await,
                30usize => self.handle_lookUpIndex(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for StorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: StorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "StorageServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_StorageService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: StorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    pub struct StorageService<'mock> {
        pub getBound: r#impl::storage_service::getBound<'mock>,
        pub boundStats: r#impl::storage_service::boundStats<'mock>,
        pub getProps: r#impl::storage_service::getProps<'mock>,
        pub getEdgeProps: r#impl::storage_service::getEdgeProps<'mock>,
        pub addVertices: r#impl::storage_service::addVertices<'mock>,
        pub addEdges: r#impl::storage_service::addEdges<'mock>,
        pub deleteEdges: r#impl::storage_service::deleteEdges<'mock>,
        pub deleteVertices: r#impl::storage_service::deleteVertices<'mock>,
        pub updateVertex: r#impl::storage_service::updateVertex<'mock>,
        pub updateEdge: r#impl::storage_service::updateEdge<'mock>,
        pub scanEdge: r#impl::storage_service::scanEdge<'mock>,
        pub scanVertex: r#impl::storage_service::scanVertex<'mock>,
        pub transLeader: r#impl::storage_service::transLeader<'mock>,
        pub addPart: r#impl::storage_service::addPart<'mock>,
        pub addLearner: r#impl::storage_service::addLearner<'mock>,
        pub waitingForCatchUpData: r#impl::storage_service::waitingForCatchUpData<'mock>,
        pub removePart: r#impl::storage_service::removePart<'mock>,
        pub memberChange: r#impl::storage_service::memberChange<'mock>,
        pub checkPeers: r#impl::storage_service::checkPeers<'mock>,
        pub getLeaderPart: r#impl::storage_service::getLeaderPart<'mock>,
        pub createCheckpoint: r#impl::storage_service::createCheckpoint<'mock>,
        pub dropCheckpoint: r#impl::storage_service::dropCheckpoint<'mock>,
        pub blockingWrites: r#impl::storage_service::blockingWrites<'mock>,
        pub rebuildTagIndex: r#impl::storage_service::rebuildTagIndex<'mock>,
        pub rebuildEdgeIndex: r#impl::storage_service::rebuildEdgeIndex<'mock>,
        pub put: r#impl::storage_service::put<'mock>,
        pub get: r#impl::storage_service::get<'mock>,
        pub remove: r#impl::storage_service::remove<'mock>,
        pub removeRange: r#impl::storage_service::removeRange<'mock>,
        pub getUUID: r#impl::storage_service::getUUID<'mock>,
        pub lookUpIndex: r#impl::storage_service::lookUpIndex<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::StorageService {
        pub fn mock<'mock>() -> StorageService<'mock> {
            StorageService {
                getBound: r#impl::storage_service::getBound::unimplemented(),
                boundStats: r#impl::storage_service::boundStats::unimplemented(),
                getProps: r#impl::storage_service::getProps::unimplemented(),
                getEdgeProps: r#impl::storage_service::getEdgeProps::unimplemented(),
                addVertices: r#impl::storage_service::addVertices::unimplemented(),
                addEdges: r#impl::storage_service::addEdges::unimplemented(),
                deleteEdges: r#impl::storage_service::deleteEdges::unimplemented(),
                deleteVertices: r#impl::storage_service::deleteVertices::unimplemented(),
                updateVertex: r#impl::storage_service::updateVertex::unimplemented(),
                updateEdge: r#impl::storage_service::updateEdge::unimplemented(),
                scanEdge: r#impl::storage_service::scanEdge::unimplemented(),
                scanVertex: r#impl::storage_service::scanVertex::unimplemented(),
                transLeader: r#impl::storage_service::transLeader::unimplemented(),
                addPart: r#impl::storage_service::addPart::unimplemented(),
                addLearner: r#impl::storage_service::addLearner::unimplemented(),
                waitingForCatchUpData: r#impl::storage_service::waitingForCatchUpData::unimplemented(),
                removePart: r#impl::storage_service::removePart::unimplemented(),
                memberChange: r#impl::storage_service::memberChange::unimplemented(),
                checkPeers: r#impl::storage_service::checkPeers::unimplemented(),
                getLeaderPart: r#impl::storage_service::getLeaderPart::unimplemented(),
                createCheckpoint: r#impl::storage_service::createCheckpoint::unimplemented(),
                dropCheckpoint: r#impl::storage_service::dropCheckpoint::unimplemented(),
                blockingWrites: r#impl::storage_service::blockingWrites::unimplemented(),
                rebuildTagIndex: r#impl::storage_service::rebuildTagIndex::unimplemented(),
                rebuildEdgeIndex: r#impl::storage_service::rebuildEdgeIndex::unimplemented(),
                put: r#impl::storage_service::put::unimplemented(),
                get: r#impl::storage_service::get::unimplemented(),
                remove: r#impl::storage_service::remove::unimplemented(),
                removeRange: r#impl::storage_service::removeRange::unimplemented(),
                getUUID: r#impl::storage_service::getUUID::unimplemented(),
                lookUpIndex: r#impl::storage_service::lookUpIndex::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::StorageService for StorageService<'mock> {
        fn getBound(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetBoundError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getBound.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn boundStats(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryStatsResponse, crate::errors::storage_service::BoundStatsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.boundStats.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getProps(
            &self,
            arg_req: &crate::types::VertexPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::QueryResponse, crate::errors::storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::VertexPropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeProps(
            &self,
            arg_req: &crate::types::EdgePropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::EdgePropResponse, crate::errors::storage_service::GetEdgePropsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEdgeProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::EdgePropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.deleteEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.deleteVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.updateVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.updateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::storage_service::ScanEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.scanEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::storage_service::ScanVertexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.scanVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.transLeader.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddPartError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddPartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addLearner.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.waitingForCatchUpData.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removePart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.memberChange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.checkPeers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getLeaderPart(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderResp, crate::errors::storage_service::GetLeaderPartError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getLeaderPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.blockingWrites.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn put(
            &self,
            arg_req: &crate::types::PutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::PutError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.put.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PutRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GeneralResponse, crate::errors::storage_service::GetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::storage_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getUUID.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookUpIndex(
            &self,
            arg_req: &crate::types::LookUpIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookUpIndexResp, crate::errors::storage_service::LookUpIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.lookUpIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod storage_service {

            pub struct getBound<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::QueryResponse,
                        crate::errors::storage_service::GetBoundError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getBound<'mock> {
                pub fn unimplemented() -> Self {
                    getBound {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getBound",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::QueryResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetBoundError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct boundStats<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::QueryStatsResponse,
                        crate::errors::storage_service::BoundStatsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> boundStats<'mock> {
                pub fn unimplemented() -> Self {
                    boundStats {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "boundStats",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryStatsResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::QueryStatsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::BoundStatsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::VertexPropRequest) -> ::std::result::Result<
                        crate::types::QueryResponse,
                        crate::errors::storage_service::GetPropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getProps<'mock> {
                pub fn unimplemented() -> Self {
                    getProps {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::VertexPropRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::QueryResponse) {
                    self.mock(move |_: crate::types::VertexPropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::VertexPropRequest) -> crate::types::QueryResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetPropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::VertexPropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::EdgePropRequest) -> ::std::result::Result<
                        crate::types::EdgePropResponse,
                        crate::errors::storage_service::GetEdgePropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEdgeProps<'mock> {
                pub fn unimplemented() -> Self {
                    getEdgeProps {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::EdgePropRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getEdgeProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::EdgePropResponse) {
                    self.mock(move |_: crate::types::EdgePropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::EdgePropRequest) -> crate::types::EdgePropResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetEdgePropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::EdgePropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::AddVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addVertices<'mock> {
                pub fn unimplemented() -> Self {
                    addVertices {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::AddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addEdges<'mock> {
                pub fn unimplemented() -> Self {
                    addEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::DeleteEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> deleteEdges<'mock> {
                pub fn unimplemented() -> Self {
                    deleteEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "deleteEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DeleteEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::DeleteVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> deleteVertices<'mock> {
                pub fn unimplemented() -> Self {
                    deleteVertices {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "deleteVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DeleteVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::storage_service::UpdateVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> updateVertex<'mock> {
                pub fn unimplemented() -> Self {
                    updateVertex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "updateVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::UpdateVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::storage_service::UpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> updateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    updateEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "updateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::UpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> ::std::result::Result<
                        crate::types::ScanEdgeResponse,
                        crate::errors::storage_service::ScanEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> scanEdge<'mock> {
                pub fn unimplemented() -> Self {
                    scanEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "scanEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanEdgeResponse) {
                    self.mock(move |_: crate::types::ScanEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> crate::types::ScanEdgeResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::ScanEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> ::std::result::Result<
                        crate::types::ScanVertexResponse,
                        crate::errors::storage_service::ScanVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> scanVertex<'mock> {
                pub fn unimplemented() -> Self {
                    scanVertex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "scanVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanVertexResponse) {
                    self.mock(move |_: crate::types::ScanVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanVertexRequest) -> crate::types::ScanVertexResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::ScanVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct transLeader<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::TransLeaderError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> transLeader<'mock> {
                pub fn unimplemented() -> Self {
                    transLeader {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::TransLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "transLeader",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::TransLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::TransLeaderError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::TransLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::AddPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addPart<'mock> {
                pub fn unimplemented() -> Self {
                    addPart {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddPartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddPartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddPartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addLearner<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::AddLearnerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addLearner<'mock> {
                pub fn unimplemented() -> Self {
                    addLearner {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddLearnerReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "addLearner",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddLearnerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::AddLearnerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddLearnerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct waitingForCatchUpData<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::WaitingForCatchUpDataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> waitingForCatchUpData<'mock> {
                pub fn unimplemented() -> Self {
                    waitingForCatchUpData {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CatchUpDataReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "waitingForCatchUpData",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CatchUpDataReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::WaitingForCatchUpDataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CatchUpDataReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removePart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RemovePartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removePart<'mock> {
                pub fn unimplemented() -> Self {
                    removePart {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemovePartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "removePart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RemovePartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemovePartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemovePartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct memberChange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::MemberChangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> memberChange<'mock> {
                pub fn unimplemented() -> Self {
                    memberChange {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MemberChangeReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "memberChange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::MemberChangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::MemberChangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MemberChangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkPeers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::CheckPeersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> checkPeers<'mock> {
                pub fn unimplemented() -> Self {
                    checkPeers {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CheckPeersReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "checkPeers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CheckPeersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::CheckPeersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CheckPeersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getLeaderPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<
                        crate::types::GetLeaderResp,
                        crate::errors::storage_service::GetLeaderPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getLeaderPart<'mock> {
                pub fn unimplemented() -> Self {
                    getLeaderPart {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getLeaderPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetLeaderResp) {
                    self.mock(move |_: crate::types::GetLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> crate::types::GetLeaderResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetLeaderPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::CreateCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    createCheckpoint {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "createCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CreateCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::CreateCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::DropCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    dropCheckpoint {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "dropCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::DropCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::DropCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct blockingWrites<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::BlockingWritesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> blockingWrites<'mock> {
                pub fn unimplemented() -> Self {
                    blockingWrites {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BlockingSignRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "blockingWrites",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::BlockingSignRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::BlockingWritesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BlockingSignRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct put<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PutRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::PutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> put<'mock> {
                pub fn unimplemented() -> Self {
                    put {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PutRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "put",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::PutRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PutRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::PutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PutRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetRequest) -> ::std::result::Result<
                        crate::types::GeneralResponse,
                        crate::errors::storage_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    get {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GeneralResponse) {
                    self.mock(move |_: crate::types::GetRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetRequest) -> crate::types::GeneralResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    remove {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::RemoveRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::storage_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    removeRange {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::RemoveRangeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUUID<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<
                        crate::types::GetUUIDResp,
                        crate::errors::storage_service::GetUUIDError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getUUID<'mock> {
                pub fn unimplemented() -> Self {
                    getUUID {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUUIDReq| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "getUUID",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetUUIDResp) {
                    self.mock(move |_: crate::types::GetUUIDReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> crate::types::GetUUIDResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::GetUUIDError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUUIDReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookUpIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> ::std::result::Result<
                        crate::types::LookUpIndexResp,
                        crate::errors::storage_service::LookUpIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> lookUpIndex<'mock> {
                pub fn unimplemented() -> Self {
                    lookUpIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookUpIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageService",
                            "lookUpIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::LookUpIndexResp) {
                    self.mock(move |_: crate::types::LookUpIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookUpIndexRequest) -> crate::types::LookUpIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_service::LookUpIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookUpIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod storage_service {

        pub type GetBoundError = ::fbthrift::NonthrowingFunctionError;

        pub type BoundStatsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetPropsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetEdgePropsError = ::fbthrift::NonthrowingFunctionError;

        pub type AddVerticesError = ::fbthrift::NonthrowingFunctionError;

        pub type AddEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type DeleteEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type DeleteVerticesError = ::fbthrift::NonthrowingFunctionError;

        pub type UpdateVertexError = ::fbthrift::NonthrowingFunctionError;

        pub type UpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type ScanEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type ScanVertexError = ::fbthrift::NonthrowingFunctionError;

        pub type TransLeaderError = ::fbthrift::NonthrowingFunctionError;

        pub type AddPartError = ::fbthrift::NonthrowingFunctionError;

        pub type AddLearnerError = ::fbthrift::NonthrowingFunctionError;

        pub type WaitingForCatchUpDataError = ::fbthrift::NonthrowingFunctionError;

        pub type RemovePartError = ::fbthrift::NonthrowingFunctionError;

        pub type MemberChangeError = ::fbthrift::NonthrowingFunctionError;

        pub type CheckPeersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetLeaderPartError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateCheckpointError = ::fbthrift::NonthrowingFunctionError;

        pub type DropCheckpointError = ::fbthrift::NonthrowingFunctionError;

        pub type BlockingWritesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type PutError = ::fbthrift::NonthrowingFunctionError;

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        pub type GetUUIDError = ::fbthrift::NonthrowingFunctionError;

        pub type LookUpIndexError = ::fbthrift::NonthrowingFunctionError;

    }

}
