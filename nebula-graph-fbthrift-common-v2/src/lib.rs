// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type GraphSpaceID = ::std::primitive::i32;

    pub type PartitionID = ::std::primitive::i32;

    pub type TagID = ::std::primitive::i32;

    pub type EdgeType = ::std::primitive::i32;

    pub type EdgeRanking = ::std::primitive::i64;

    pub type VertexID = ::std::vec::Vec<::std::primitive::u8>;

    pub type Timestamp = ::std::primitive::i64;

    pub type IndexID = ::std::primitive::i32;

    pub type Port = ::std::primitive::i32;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Date {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DateTime {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
        pub hour: ::std::primitive::i8,
        pub minute: ::std::primitive::i8,
        pub sec: ::std::primitive::i8,
        pub microsec: ::std::primitive::i32,
        pub timezone: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub enum Value {
        nVal(crate::types::NullType),
        bVal(::std::primitive::bool),
        iVal(::std::primitive::i64),
        fVal(crate::double::Double),
        sVal(::std::vec::Vec<::std::primitive::u8>),
        dVal(crate::types::Date),
        tVal(crate::types::DateTime),
        vVal(crate::types::Vertex),
        eVal(crate::types::Edge),
        pVal(crate::types::Path),
        lVal(crate::types::List),
        mVal(crate::types::Map),
        uVal(crate::types::Set),
        gVal(crate::types::DataSet),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct List {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Map {
        pub kvs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Set {
        pub values: ::std::collections::BTreeSet<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Row {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct DataSet {
        pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub rows: ::std::vec::Vec<crate::types::Row>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Tag {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Vertex {
        pub vid: crate::types::VertexID,
        pub tags: ::std::vec::Vec<crate::types::Tag>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Edge {
        pub src: crate::types::VertexID,
        pub dst: crate::types::VertexID,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Step {
        pub dst: crate::types::Vertex,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Path {
        pub src: crate::types::Vertex,
        pub steps: ::std::vec::Vec<crate::types::Step>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct HostAddr {
        pub host: ::std::string::String,
        pub port: crate::types::Port,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct KeyValue {
        pub key: ::std::vec::Vec<::std::primitive::u8>,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct NullType(pub ::std::primitive::i32);

    impl NullType {
        pub const __NULL__: Self = NullType(0i32);
        pub const NaN: Self = NullType(1i32);
        pub const BAD_DATA: Self = NullType(2i32);
        pub const BAD_TYPE: Self = NullType(3i32);
        pub const ERR_OVERFLOW: Self = NullType(4i32);
        pub const UNKNOWN_PROP: Self = NullType(5i32);
        pub const DIV_BY_ZERO: Self = NullType(6i32);
        pub const OUT_OF_RANGE: Self = NullType(7i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "__NULL__",
                "NaN",
                "BAD_DATA",
                "BAD_TYPE",
                "ERR_OVERFLOW",
                "UNKNOWN_PROP",
                "DIV_BY_ZERO",
                "OUT_OF_RANGE",
            ]
        }
    }

    impl ::std::default::Default for NullType {
        fn default() -> Self {
            NullType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for NullType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                NullType::__NULL__ => "__NULL__",
                NullType::NaN => "NaN",
                NullType::BAD_DATA => "BAD_DATA",
                NullType::BAD_TYPE => "BAD_TYPE",
                NullType::ERR_OVERFLOW => "ERR_OVERFLOW",
                NullType::UNKNOWN_PROP => "UNKNOWN_PROP",
                NullType::DIV_BY_ZERO => "DIV_BY_ZERO",
                NullType::OUT_OF_RANGE => "OUT_OF_RANGE",
                NullType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "NullType::{}", self)
        }
    }

    impl ::std::str::FromStr for NullType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "__NULL__" => ::std::result::Result::Ok(NullType::__NULL__),
                "NaN" => ::std::result::Result::Ok(NullType::NaN),
                "BAD_DATA" => ::std::result::Result::Ok(NullType::BAD_DATA),
                "BAD_TYPE" => ::std::result::Result::Ok(NullType::BAD_TYPE),
                "ERR_OVERFLOW" => ::std::result::Result::Ok(NullType::ERR_OVERFLOW),
                "UNKNOWN_PROP" => ::std::result::Result::Ok(NullType::UNKNOWN_PROP),
                "DIV_BY_ZERO" => ::std::result::Result::Ok(NullType::DIV_BY_ZERO),
                "OUT_OF_RANGE" => ::std::result::Result::Ok(NullType::OUT_OF_RANGE),
                _ => ::anyhow::bail!("Unable to parse {} as NullType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for NullType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for NullType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for NullType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(NullType::from(p.read_i32()?))
        }
    }










    impl ::std::default::Default for self::Date {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Date {}
    unsafe impl ::std::marker::Sync for self::Date {}

    impl ::fbthrift::GetTType for self::Date {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Date");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DateTime {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
                hour: ::std::default::Default::default(),
                minute: ::std::default::Default::default(),
                sec: ::std::default::Default::default(),
                microsec: ::std::default::Default::default(),
                timezone: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DateTime {}
    unsafe impl ::std::marker::Sync for self::DateTime {}

    impl ::fbthrift::GetTType for self::DateTime {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DateTime");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_begin("hour", ::fbthrift::TType::Byte, 4);
            ::fbthrift::Serialize::write(&self.hour, p);
            p.write_field_end();
            p.write_field_begin("minute", ::fbthrift::TType::Byte, 5);
            ::fbthrift::Serialize::write(&self.minute, p);
            p.write_field_end();
            p.write_field_begin("sec", ::fbthrift::TType::Byte, 6);
            ::fbthrift::Serialize::write(&self.sec, p);
            p.write_field_end();
            p.write_field_begin("microsec", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.microsec, p);
            p.write_field_end();
            p.write_field_begin("timezone", ::fbthrift::TType::I32, 8);
            ::fbthrift::Serialize::write(&self.timezone, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let mut field_hour = ::std::option::Option::None;
            let mut field_minute = ::std::option::Option::None;
            let mut field_sec = ::std::option::Option::None;
            let mut field_microsec = ::std::option::Option::None;
            let mut field_timezone = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 4) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 5) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 6) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 8) => field_timezone = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
                hour: field_hour.unwrap_or_default(),
                minute: field_minute.unwrap_or_default(),
                sec: field_sec.unwrap_or_default(),
                microsec: field_microsec.unwrap_or_default(),
                timezone: field_timezone.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for Value {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for Value {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for Value
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Value");
            match self {
                Value::nVal(inner) => {
                    p.write_field_begin("nVal", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::bVal(inner) => {
                    p.write_field_begin("bVal", ::fbthrift::TType::Bool, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::iVal(inner) => {
                    p.write_field_begin("iVal", ::fbthrift::TType::I64, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::fVal(inner) => {
                    p.write_field_begin("fVal", ::fbthrift::TType::Double, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::sVal(inner) => {
                    p.write_field_begin("sVal", ::fbthrift::TType::String, 5);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::dVal(inner) => {
                    p.write_field_begin("dVal", ::fbthrift::TType::Struct, 6);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::tVal(inner) => {
                    p.write_field_begin("tVal", ::fbthrift::TType::Struct, 7);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::vVal(inner) => {
                    p.write_field_begin("vVal", ::fbthrift::TType::Struct, 8);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::eVal(inner) => {
                    p.write_field_begin("eVal", ::fbthrift::TType::Struct, 9);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::pVal(inner) => {
                    p.write_field_begin("pVal", ::fbthrift::TType::Struct, 10);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::lVal(inner) => {
                    p.write_field_begin("lVal", ::fbthrift::TType::Struct, 11);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::mVal(inner) => {
                    p.write_field_begin("mVal", ::fbthrift::TType::Struct, 12);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::uVal(inner) => {
                    p.write_field_begin("uVal", ::fbthrift::TType::Struct, 13);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::gVal(inner) => {
                    p.write_field_begin("gVal", ::fbthrift::TType::Struct, 14);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Value
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::nVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Bool, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::bVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I64, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::iVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::fVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::String, 5, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::sVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 6, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::dVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 7, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::tVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 8, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::vVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 9, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::eVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 10, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::pVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 11, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::lVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 12, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::mVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 13, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::uVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 14, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::gVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "Value",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::List {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::List {}
    unsafe impl ::std::marker::Sync for self::List {}

    impl ::fbthrift::GetTType for self::List {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::List
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("List");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::List
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Map {
        fn default() -> Self {
            Self {
                kvs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Map {}
    unsafe impl ::std::marker::Sync for self::Map {}

    impl ::fbthrift::GetTType for self::Map {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Map
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Map");
            p.write_field_begin("kvs", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.kvs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Map
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_kvs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_kvs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                kvs: field_kvs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Set {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Set {}
    unsafe impl ::std::marker::Sync for self::Set {}

    impl ::fbthrift::GetTType for self::Set {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Set
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Set");
            p.write_field_begin("values", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Set
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Set, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Row {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Row {}
    unsafe impl ::std::marker::Sync for self::Row {}

    impl ::fbthrift::GetTType for self::Row {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Row");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DataSet {
        fn default() -> Self {
            Self {
                column_names: ::std::default::Default::default(),
                rows: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DataSet {}
    unsafe impl ::std::marker::Sync for self::DataSet {}

    impl ::fbthrift::GetTType for self::DataSet {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DataSet");
            p.write_field_begin("column_names", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.column_names, p);
            p.write_field_end();
            p.write_field_begin("rows", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.rows, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_column_names = ::std::option::Option::None;
            let mut field_rows = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                column_names: field_column_names.unwrap_or_default(),
                rows: field_rows.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Tag {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Tag {}
    unsafe impl ::std::marker::Sync for self::Tag {}

    impl ::fbthrift::GetTType for self::Tag {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Tag");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_name = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Vertex {
        fn default() -> Self {
            Self {
                vid: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Vertex {}
    unsafe impl ::std::marker::Sync for self::Vertex {}

    impl ::fbthrift::GetTType for self::Vertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Vertex");
            p.write_field_begin("vid", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.vid, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_vid = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_vid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vid: field_vid.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Edge {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Edge {}
    unsafe impl ::std::marker::Sync for self::Edge {}

    impl ::fbthrift::GetTType for self::Edge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Edge");
            p.write_field_begin("src", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 6);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_src = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 6) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Step {
        fn default() -> Self {
            Self {
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Step {}
    unsafe impl ::std::marker::Sync for self::Step {}

    impl ::fbthrift::GetTType for self::Step {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Step");
            p.write_field_begin("dst", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 5);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 5) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Path {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                steps: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Path {}
    unsafe impl ::std::marker::Sync for self::Path {}

    impl ::fbthrift::GetTType for self::Path {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Path");
            p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("steps", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.steps, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_src = ::std::option::Option::None;
            let mut field_steps = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_steps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                steps: field_steps.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HostAddr {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                port: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostAddr {}
    unsafe impl ::std::marker::Sync for self::HostAddr {}

    impl ::fbthrift::GetTType for self::HostAddr {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostAddr");
            p.write_field_begin("host", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("port", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.port, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_host = ::std::option::Option::None;
            let mut field_port = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                port: field_port.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KeyValue {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KeyValue {}
    unsafe impl ::std::marker::Sync for self::KeyValue {}

    impl ::fbthrift::GetTType for self::KeyValue {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KeyValue");
            p.write_field_begin("key", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_key = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }

}

pub mod errors {
}
pub mod double;
